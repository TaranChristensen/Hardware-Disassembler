00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 2/27/2016 7:01:10 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Master
00000000                             3  * Written by : Circles
00000000                             4  * Date       : ##/##/16
00000000                             5  * Description: Project Master File
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11      INCLUDE "IO.X68"        ; Handles our input and output, as well as which address to refer to
00001000                            12  
00001000  43F9 00001136             13  IOINTRO LEA     IntroMsg,A1      Display the intro
00001006  103C 000E                 14          MOVE.B  #14, D0
0000100A  4E4F                      15          TRAP    #15
0000100C                            16  
0000100C  43F9 00001153             17  IOLOOP  LEA     HexStart,A1        Display the prompt and loop it
00001012  103C 000E                 18          MOVE.B  #14,D0          
00001016  4E4F                      19          TRAP    #15       
00001018                            20  
00001018  43F9 00000100             21          LEA  IOStringLoc,A1     ; Store the string of our user input at StartAddress,A1 
0000101E  103C 0002                 22          MOVE.B  #2,D0           ;   uses Trap #15, Task 2
00001022  4E4F                      23          TRAP    #15             ;
00001024                            24          
00001024  B2BC 00000001             25          CMP.L   #1,D1           ; Compares D1 to the number 1 (eg. String length of 1)
0000102A  6700 00F4                 26          BEQ     IODONE          ; Branch to DONE if they are equal
0000102E                            27          
0000102E  4284                      28          CLR.L   D4              ; Ensure our counter (D4) is 0      
00001030                            29              
00001030  5244                      30  IOASCIItoHEX    ADDQ    #1,D4
00001032  E98A                      31                  LSL.L   #4,D2           ; Scoot D2 a nybble
00001034  1619                      32                  MOVE.B  (A1)+,D3        ; Move a Byte from A1's address to D3
00001036  0403 0030                 33                  SUB.B   #48,D3          ; Sub 48 to turn ASCII 0 into binary 0
0000103A  B63C 0009                 34                  CMP.B   #9,D3           ; If our number is greater than 9..
0000103E  6F02                      35                  BLE.S   IOORTAG         ; .. it must be a character; A-F: 
00001040  5F03                      36                  SUB.B   #7,D3           ; Sub 7 to turn A into 10
00001042  8403                      37  IOORTAG         OR.B    D3,D2           ; Store our nybble into D2
00001044  B204                      38                  CMP.B   D4,D1           ; See if we've read all the characters
00001046  66E8                      39                  BNE.S   IOASCIItoHEX    ; Continue if we haven't
00001048                            40              
00001048  23FC 00000000 000011CC    41          MOVE.L  #0,StartAddress
00001052  23C2 000011CC             42          MOVE.L  D2,StartAddress     ; Store our StartAddress
00001058                            43          
00001058  4281                      44          CLR.L   D1
0000105A                            45          
0000105A                            46          ; ==== OUTPUT OPCODE ===    
0000105A  23FC 00000000 00000100    47          MOVE.L  #0,IOStringLoc      ; == Testing Purposes; not nessessary ==   
00001064                            48          
00001064                            49          ; <Testing section>        
00001064  2479 000011CC             50          MOVE.L  StartAddress,A2     ; Push our start address into A2 
0000106A  24FC 12000000             51          MOVE.L  #$12000000,(A2)+    ; Push OpCode for Move.B D0,D1 into our start address
00001070  24FC 32000000             52          MOVE.L  #$32000000,(A2)+    ; Push OpCode for Move.W D0,D1 into our start address
00001076  24FC 22000000             53          MOVE.L  #$22000000,(A2)+    ; Push OpCode for Move.L D0,D1 into our start address
0000107C                            54          ; </Testing section>
0000107C                            55          
0000107C  2479 000011CC             56          MOVE.L  StartAddress,A2     ; Push our start address into A2 
00001082  43F9 00000100             57          LEA     IOStringLoc,A1      ; Load our IOStringLoc into A1 for string contruction purposes
00001088                            58          
00001088  22FC 23232323             59          MOVE.L  #'####',(A1)+            ; Move our "OpCode location" into our IOStringLoc <---- THIS NEEDS TO BE HEX
0000108E  5841                      60          ADDQ    #4,D1               ; We added 4 new characters                     <---- THIS NEEDS TO BE 8
00001090  22FC 20202020             61          MOVE.L  #'    ',(A1)+        ; Add a spacer into our IOStringLoc
00001096  5841                      62          ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
00001098                            63          
00001098                            64          ; Here we could loop all of the addresses of A2 until End, or something.
00001098  4EB9 000011D0             65          JSR OPGETCODE               ; Get the OpCode pointed at by A2, it's string stored in IOStringLoc
0000109E                            66          
0000109E  22FC 20202020             67          MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
000010A4  5841                      68          ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
000010A6                            69          
000010A6  43F9 00000100             70          LEA     IOStringLoc,A1      ; Now that we've populated the string, load it's beginning
000010AC  103C 0001                 71          MOVE.B  #1,D0               ; Trap task 1 prints a string at A1 with #D1 bytes.
000010B0  4E4F                      72          TRAP    #15
000010B2                            73          
000010B2  43F9 000011B7             74          LEA     UnkEA,A1            ; TEMPORARY Print "<EA>,<EA>"
000010B8  103C 000D                 75          MOVE.B  #13,D0              ;
000010BC  4E4F                      76          TRAP    #15                 ;
000010BE                            77          
000010BE  43F9 000011B1             78          LEA     SPC,A1              ; Puts the space before the opCode
000010C4  103C 000D                 79          MOVE.B  #13,D0
000010C8  4E4F                      80          TRAP    #15
000010CA                            81          ; ==== END OUTPUT OPCODE ====
000010CA                            82  
000010CA  43F9 000011A3             83          LEA     RES,A1          ; Output the beginning of the message
000010D0  103C 000E                 84          MOVE.B  #14,D0  
000010D4  4E4F                      85          TRAP    #15
000010D6                            86  
000010D6                            87          ; ==== OUTPUT USER INPUT ====
000010D6                            88          ; The following outputs the input, converting what we've saved in HEX to ASCII
000010D6                            89          ; We won't need this in the final version, but the below code should be handy
000010D6                            90          ;  for print out EA values
000010D6  2439 000011CC             91          MOVE.L  StartAddress,D2 ; Ensure our address is actually at D2
000010DC  7208                      92          MOVEQ   #8,D1           ; There are 8 characters in the hex of our address
000010DE  4284                      93          CLR.L   D4              ; Ensure our counter (D4) is 0
000010E0  43F9 00000100             94          LEA     IOStringLoc,A1  ; Load our IO String location, to store our output at  
000010E6                            95          
000010E6  5244                      96  IOHEXtoASCII    ADDQ    #1,D4
000010E8  E99A                      97                  ROL.L   #4,D2           ; Get the left-most nyblle to the front..
000010EA  1602                      98                  MOVE.B  D2,D3           ; .. Put the front-most byte into D3    
000010EC  C63C 000F                 99                  AND.B   #$0F,D3         ; Distill D3 down to the original left-most nybble
000010F0  B63C 0009                100                  CMP.B   #9,D3           ; See if our number is greater than 9..
000010F4  6F00 0004                101                  BLE     IODIGIT         ; If it is 9 or less, it's a digit..
000010F8  5E03                     102                  ADD.B   #7,D3           ; Otherwise it is a digit, and needs an additional 7
000010FA  0603 0030                103  IODIGIT         ADD.B   #48,D3          ; We now how the nybble's ASCII code
000010FE  12C3                     104                  MOVE.B  D3,(A1)+        ; Move the ASCII code into the output string at A1
00001100  B204                     105                  CMP.B   D4,D1           ; See if we've read all the characters
00001102  66E2                     106                  BNE.S   IOHEXtoASCII    ; Continue if we haven't
00001104                           107          
00001104  43F9 00000100            108          LEA     IOStringLoc,A1  ; Now that we've populated the string, load it's beginning
0000110A  103C 0001                109          MOVE.B  #1,D0           ; Trap task 1 prints a string at A1 with #D1 bytes.
0000110E  4E4F                     110          TRAP    #15
00001110                           111          ; ==== END OUTPUT USER INPUT ====
00001110                           112  
00001110  43F9 000011B1            113          LEA     SPC,A1          Puts the space after the number
00001116  103C 000D                114          MOVE.B  #13,D0
0000111A  4E4F                     115          TRAP    #15
0000111C                           116  
0000111C  6000 FEEE                117          BRA     IOLOOP
00001120                           118          
00001120  43F9 000011C1            119  IODONE  LEA     OUTRO,A1        Display the ending message 
00001126  103C 000E                120          MOVE.B  #14,D0
0000112A  4E4F                     121          TRAP    #15
0000112C  103C 0009                122          MOVE.B  #9,D0
00001130  4E4F                     123          TRAP    #15             Halt Simulator
00001132                           124          
00001132  FFFF FFFF                125          SIMHALT
00001136                           126          
00001136  =0000000D                127  CR              EQU     $0D         
00001136  =0000000A                128  LF              EQU     $0A 
00001136  =00000100                129  IOStringLoc     EQU     $0100   ; This is where we will store the string of the user input, and other strings
00001136                           130  
00001136= 54 65 61 6D 20 43 ...    131  IntroMsg        DC.B    'Team Circles Disassembler ',CR,LF,0     Intro
00001153= 50 6C 65 61 73 65 ...    132  HexStart        DC.B    'Please enter a full hexidecimal address to get started, or',CR,LF,'type in 0 to quit: ',0         Prompt for the user
000011A3= 59 6F 75 20 74 79 ...    133  RES             DC.B    'You typed in ',0                        Response to the user
000011B1= 20 20 20 20 20 00        134  SPC             DC.B    '     ',0                                tab
000011B7= 3C 45 41 3E 2C 3C ...    135  UnkEA           DC.B    '<EA>,<EA>',0                            Interim message for unkown EAs.
000011C1= 47 6F 6F 64 62 79 ...    136  OUTRO           DC.B    'Goodbye !',0                            Outro message
000011CC                           137  StartAddress    DS.L    1
000011D0                           138  
000011D0                           139  
000011D0                           140  
000011D0                           141  
000011D0                           142  -------------------- end include --------------------
000011D0                           143      INCLUDE "OpCode.X68"    ; Handles determining OpCodes
000011D0                           144  
000011D0                           145  
000011D0                           146  ; Here we assume that A2 contains the address pointing to our OpCode, and
000011D0                           147  ;  we assume that A1 contains the address pointing to our IOStringLoc
000011D0  2A1A                     148  OPGETCODE   MOVE.L  (A2)+,D5    ; Push our OpCode into D5
000011D2  E99D                     149              ROL.L   #4,D5       ; Rotate our OpCode 1 nybble left
000011D4  1C05                     150              MOVE.B  D5,D6       ; Push the nybble's byte into D6
000011D6  0206 000F                151              ANDI.B  #$0F,D6     ; Isolate our opcode nybble
000011DA  BC3C 0001                152              CMP.B   #$01,D6     
000011DE  670E                     153              BEQ.S   MOVEB       ; MOVE.B
000011E0  BC3C 0003                154              CMP.B   #$03,D6     
000011E4  6716                     155              BEQ.S   MOVEW       ; MOVE.W
000011E6  BC3C 0002                156              CMP.B   #$02,D6
000011EA  671E                     157              BEQ.S   MOVEL       ; MOVE.L
000011EC                           158              
000011EC  602A                     159              BRA.S   UNKNOWN
000011EE                           160              
000011EE                           161  MOVEB
000011EE  22FC 4D4F5645            162              MOVE.L  #'MOVE',(A1)+
000011F4  32FC 2E42                163              MOVE.W  #'.B',(A1)+
000011F8  5C41                     164              ADDQ    #6,D1           ; We added 6 new characters to our IOStringLoc 
000011FA  4E75                     165              RTS
000011FC                           166  MOVEW
000011FC  22FC 4D4F5645            167              MOVE.L  #'MOVE',(A1)+
00001202  32FC 2E57                168              MOVE.W  #'.W',(A1)+
00001206  5C41                     169              ADDQ    #6,D1           ; We added 6 new characters to our IOStringLoc 
00001208  4E75                     170              RTS
0000120A                           171  MOVEL
0000120A  22FC 4D4F5645            172              MOVE.L  #'MOVE',(A1)+
00001210  32FC 2E4C                173              MOVE.W  #'.L',(A1)+
00001214  5C41                     174              ADDQ    #6,D1           ; We added 6 new characters to our IOStringLoc 
00001216  4E75                     175              RTS
00001218                           176  
00001218                           177  UNKNOWN
00001218  22FC 3F3F3F3F            178              MOVE.L  #'????',(A1)+
0000121E  5841                     179              ADDQ    #4,D1           ; We added 4 new characters to our IOStringLoc 
00001220  4E75                     180              RTS
00001222                           181  
00001222                           182  
00001222                           183  
00001222                           184  -------------------- end include --------------------
00001222                           185      INCLUDE "EA.X68"        ; Handles EA types
00001222                           186  
00001222  143C 00EA                187      MOVE.B  #$EA,D2
00001226                           188      
00001226                           189  
00001226                           190  -------------------- end include --------------------
00001226                           191      
00001226  FFFF FFFF                192      SIMHALT             ; halt simulator
0000122A                           193  
0000122A                           194  * Put variables and constants here
0000122A                           195  
0000122A                           196      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
CR                  D
HEXSTART            1153
INTROMSG            1136
IOASCIITOHEX        1030
IODIGIT             10FA
IODONE              1120
IOHEXTOASCII        10E6
IOINTRO             1000
IOLOOP              100C
IOORTAG             1042
IOSTRINGLOC         100
LF                  A
MOVEB               11EE
MOVEL               120A
MOVEW               11FC
OPGETCODE           11D0
OUTRO               11C1
RES                 11A3
SPC                 11B1
START               1000
STARTADDRESS        11CC
UNKEA               11B7
UNKNOWN             1218
