00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 3/5/2016 9:59:17 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Master
00000000                             3  * Written by : Circles
00000000                             4  * Date       : ##/##/16
00000000                             5  * Description: Project Master File
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11      INCLUDE "IO.X68"        ; Handles our input and output, as well as which address to refer to
00001000                            12  
00001000  52B9 0000136A             13  IOINTRO         ADD.L   #$00000001,COUNTER
00001006  43F9 0000122C             14                  LEA     IntroMsg,A1        Display the intro
0000100C  103C 000E                 15                  MOVE.B  #14, D0
00001010  4E4F                      16                  TRAP    #15
00001012                            17  
00001012  43F9 00001249             18  IOLOOP          LEA     HexStart,A1        Display the prompt and loop it
00001018  103C 000E                 19                  MOVE.B  #14,D0          
0000101C  4E4F                      20                  TRAP    #15   
0000101E  54B9 0000136A             21                  ADD.L   #$00000002,COUNTER  
00001024                            22  
00001024  43F9 00000100             23                  LEA     IOStringLoc,A1     Store the string of our user input at StartAddress,A1 
0000102A  103C 0002                 24                  MOVE.B  #2,D0              uses Trap #15, Task 2
0000102E  4E4F                      25                  TRAP    #15              
00001030                            26          
00001030  B2BC 00000001             27                  CMP.L   #1,D1              Compares D1 to the number 1 (eg. String length of 1)
00001036  6700 01DE                 28                  BEQ     IODONE             Branch to DONE if they are equal
0000103A                            29          
0000103A  4284                      30                  CLR.L   D4                 Ensure our counter (D4) is 0 
0000103C                            31  
0000103C  4EB9 0000108A             32                  JSR     LENGTH_CHECK 
00001042  4282                      33                  CLR.L   D2  
00001044  BA3C 0001                 34                  CMP.B   #1,D5              if 1 then it passed the tests         
00001048                            35                  
00001048  6700 0098                 36                  BEQ     IOASCIItoHEX
0000104C  60C4                      37                  BRA     IOLOOP
0000104E                            38                  
0000104E  0CB9 0000001D 0000136A    39  CHECK31         CMP.L   #$0000001D,COUNTER compare the counter to 29
00001058  6E00 0004                 40                  BGT     ENTERCHECK         counter is at at least 30
0000105C  4E75                      41                  RTS                        counter is still low
0000105E                            42  
0000105E  43F9 0000136A             43  ENTERCHECK      LEA     ENTERPROMPT,A1     display the enter prompt
00001064  123C 000E                 44                  MOVE.B  #14,D1
00001068  4E4F                      45                  TRAP    #15
0000106A                            46                  
0000106A  2E01                      47                  MOVE.L  D1,D7              store what was previously in D1
0000106C                            48                  
0000106C  123C 0002                 49                  MOVE.B  #2,D1              wait for the user to hit enter
00001070  4E4F                      50                  TRAP    #15
00001072  06B9 00000000 0000136A    51                  ADD.L   #$00000000,COUNTER clear the counter
0000107C  52B9 0000136A             52                  ADD.L   #$00000001,COUNTER add one to the counter
00001082                            53                  
00001082  4281                      54                  CLR.L   D1
00001084  2207                      55                  MOVE.L  D7,D1              move what was in D1 at the start back
00001086  4287                      56                  CLR.L   D7
00001088                            57                  
00001088  4E75                      58                  RTS
0000108A                            59                  
0000108A  4285                      60  LENGTH_CHECK    CLR.L   D5                 store the result of the test
0000108C  7C00                      61                  MOVEQ   #$0,D6             make D6 0
0000108E  B206                      62                  CMP.B   D6,D1              see if null
00001090  6700 0010                 63                  BEQ     BAD_LENGTH         if null then branch to bad input
00001094  0C41 0008                 64                  CMPI    #$8,D1             see if it is more than 8 characters long
00001098  6E00 0008                 65                  BGT     BAD_LENGTH         if more than 8 branch to bad input
0000109C  1A3C 0001                 66                  MOVE.B  #$1,D5             passed the length checks so move 1
000010A0  4E75                      67                  RTS                        go back
000010A2                            68                  
000010A2  7A00                      69  BAD_LENGTH      MOVEQ   #$0,D5             did not pass the test
000010A4  43F9 0000131C             70                  LEA     FAIL_INPUT,A1      load bad input message
000010AA  103C 000E                 71                  MOVE.B  #14,D0          
000010AE  4E4F                      72                  TRAP    #15 
000010B0  4E75                      73                  RTS                        go back
000010B2                            74                  
000010B2  4286                      75  TEST_ODD        CLR.L   D6           
000010B4  4285                      76                  CLR.L   D5
000010B6  7A02                      77                  MOVE.L  #$00000002,D5      divide by 2 to see remainder
000010B8  2C02                      78                  MOVE.L  D2,D6              create a copy of the input in D7
000010BA  8CC5                      79                  DIVU    D5,D6              divide the hex number by 2
000010BC  4846                      80                  SWAP    D6                 put the remainder on the far left
000010BE  BC3C 0001                 81                  CMP.B   #1,D6              see if the remainder is one
000010C2  6700 000A                 82                  BEQ     BAD_EVEN           branch to to even
000010C6  4286                      83                  CLR.L   D6
000010C8  4285                      84                  CLR.L   D5
000010CA  6000 009C                 85                  BRA     OUTPUTOPCODE       was even so keep going
000010CE                            86                  
000010CE                            87                  
000010CE  4285                      88  BAD_EVEN        CLR.L   D5
000010D0  4286                      89                  CLR.L   D6
000010D2  43F9 0000131C             90                  LEA     FAIL_INPUT,A1      load bad input message  
000010D8  103C 000E                 91                  MOVE.B  #14,D0          
000010DC  4E4F                      92                  TRAP    #15 
000010DE  6000 FF32                 93                  BRA     IOLOOP             go back to the beginning
000010E2                            94                  
000010E2                            95              
000010E2  5244                      96  IOASCIItoHEX    ADDQ    #1,D4
000010E4  E98A                      97                  LSL.L   #4,D2              Scoot D2 a nybble
000010E6  1619                      98                  MOVE.B  (A1)+,D3           Move a Byte from A1's address to D3
000010E8  0403 0030                 99                  SUB.B   #48,D3             Sub 48 to turn ASCII 0 into binary 0
000010EC  B63C 0009                100                  CMP.B   #9,D3              If our number is greater than 9..
000010F0  6F02                     101                  BLE.S   IOORTAG            .. it must be a character; A-F: 
000010F2  5F03                     102                  SUB.B   #7,D3              Sub 7 to turn A into 10
000010F4  8403                     103  IOORTAG         OR.B    D3,D2              Store our nybble into D2
000010F6  B204                     104                  CMP.B   D4,D1              See if we've read all the characters
000010F8  66E8                     105                  BNE.S   IOASCIItoHEX       Continue if we haven't
000010FA                           106              
000010FA                           107              
000010FA  23FC 00000000 00001362   108                  MOVE.L  #0,StartAddress
00001104  23C2 00001362            109                  MOVE.L  D2,StartAddress    Store our StartAddress
0000110A                           110                  
0000110A                           111                  ;BRA     TEST_ODD          ******************** need test_odd to not always branch to outputopcode **************************
0000110A                           112                  
0000110A  4281                     113                  CLR.L   D1
0000110C                           114                  ;The Labels of this section are the same as the previous (different names)
0000110C                           115                  ;due to errors that I was getting with bracnhing and overwriting 
0000110C                           116                  ;data registers
0000110C                           117                  
0000110C  43F9 0000129F            118  ENDLOOP         LEA     HexEnd,A1          load the ending address prompt
00001112  103C 000E                119                  MOVE.B  #14,D0
00001116  4E4F                     120                  TRAP    #15  
00001118                           121                  
00001118  43F9 00000100            122                  LEA     IOStringLoc,A1     Store the string of our user input at StartAddress,A1 
0000111E  103C 0002                123                  MOVE.B  #2,D0              uses Trap #15, Task 2
00001122  4E4F                     124                  TRAP    #15              
00001124                           125          
00001124  B2BC 00000001            126                  CMP.L   #1,D1              Compares D1 to the number 1 (eg. String length of 1)
0000112A  6700 00EA                127                  BEQ     IODONE             Branch to DONE if they are equal
0000112E                           128          
0000112E  4284                     129                  CLR.L   D4                 Ensure our counter (D4) is 0 
00001130                           130  
00001130  4EB8 108A                131                  JSR     LENGTH_CHECK       check to make sure the length is ok
00001134  BA3C 0001                132                  CMP.B   #1,D5              if 1 then it passed the tests         
00001138                           133  
00001138  6700 0004                134                  BEQ     IOASCIItoHEX2      convert to hex
0000113C  60CE                     135                  BRA     ENDLOOP
0000113E                           136                  
0000113E  5244                     137  IOASCIItoHEX2   ADDQ    #1,D4
00001140  E98A                     138                  LSL.L   #4,D2              Scoot D2 a nybble
00001142  1619                     139                  MOVE.B  (A1)+,D3           Move a Byte from A1's address to D3
00001144  0403 0030                140                  SUB.B   #48,D3             Sub 48 to turn ASCII 0 into binary 0
00001148  B63C 0009                141                  CMP.B   #9,D3              If our number is greater than 9..
0000114C  6F02                     142                  BLE.S   IOORTAG2           .. it must be a character; A-F: 
0000114E  5F03                     143                  SUB.B   #7,D3              Sub 7 to turn A into 10
00001150  8403                     144  IOORTAG2        OR.B    D3,D2              Store our nybble into D2
00001152  B204                     145                  CMP.B   D4,D1              See if we've read all the characters
00001154  66E8                     146                  BNE.S   IOASCIItoHEX2      Continue if we haven't
00001156                           147              
00001156                           148    
00001156  23FC 00000000 00001366   149                  MOVE.L  #0,EndingAddress
00001160  23C2 00001366            150                  MOVE.L  D2,EndingAddress   Store our EndingAddress
00001166                           151                  
00001166                           152                  ;BRA     TEST_ODD
00001166                           153                  
00001166  4281                     154                  CLR.L   D1
00001168                           155          
00001168  23FC 00000000 00000100   156  OUTPUTOPCODE    MOVE.L  #0,IOStringLoc     ********** Testing purposes ********** 
00001172                           157          
00001172                           158                  ; <Testing section>        
00001172  2479 00001362            159                  MOVE.L  StartAddress,A2    Push our start address into A2 
00001178  24FC 48A7FFFE            160                  MOVE.L  #$48A7FFFE,(A2)+   Push OpCode for MOVEM.L (A7)+,A0-A6/D0-D7 into our start address
0000117E  34FC 3200                161                  MOVE.W  #$3200,(A2)+       Push OpCode for Move.W D0,D1 into our start address
00001182  34FC 2200                162                  MOVE.W  #$2200,(A2)+       Push OpCode for Move.L D0,D1 into our start address
00001186                           163                  ; </Testing section>
00001186                           164          
00001186  2479 00001362            165                  MOVE.L  StartAddress,A2    Push our start address into A2 
0000118C  43F9 00000100            166                  LEA     IOStringLoc,A1     Load our IOStringLoc into A1 for string contruction purposes
00001192                           167          
00001192                           168                  ; Here we could loop all of the addresses of A2 until End, or something.
00001192  22FC 23232323            169                  MOVE.L  #'####',(A1)+      Move our "OpCode location" into our IOStringLoc <---- THIS NEEDS TO BE HEX
00001198  5841                     170                  ADDQ    #4,D1              We added 4 new characters                       <---- THIS NEEDS TO BE 8
0000119A  22FC 20202020            171                  MOVE.L  #'    ',(A1)+      Add a spacer into our IOStringLoc
000011A0  5841                     172                  ADDQ    #4,D1              We added 4 bytes, aka 4 spaces
000011A2                           173          
000011A2  4EB9 000013AE            174                  JSR OPGETCODE              Get the OpCode pointed at by A2, it's string stored in IOStringLoc
000011A8                           175                  
000011A8  43F9 00000100            176                  LEA     IOStringLoc,A1     Now that we've populated the string, load it's beginning
000011AE  103C 0001                177                  MOVE.B  #1,D0              Trap task 1 prints a string at A1 with #D1 bytes.
000011B2  4E4F                     178                  TRAP    #15
000011B4                           179          
000011B4                           180                  ;LEA     UnkEA,A1          TEMPORARY Print "<EA>,<EA>"
000011B4                           181                  ;MOVE.B  #13,D0              
000011B4                           182                  ;TRAP    #15                 
000011B4                           183          
000011B4  43F9 00001302            184                  LEA     SPC,A1             Puts the space before the opCode
000011BA  103C 000D                185                  MOVE.B  #13,D0
000011BE  4E4F                     186                  TRAP    #15
000011C0                           187                  
000011C0                           188                  
000011C0                           189  
000011C0  43F9 000012F4            190                  LEA     RES,A1             Output the beginning of the message
000011C6  103C 000E                191                  MOVE.B  #14,D0  
000011CA  4E4F                     192                  TRAP    #15
000011CC                           193  
000011CC                           194                  ; The following outputs the input, converting what we've saved in HEX to ASCII
000011CC                           195                  ; We won't need this in the final version, but the below code should be handy
000011CC                           196                  ;  for print out EA values
000011CC  2439 00001362            197                  MOVE.L  StartAddress,D2    Ensure our address is actually at D2
000011D2  7208                     198                  MOVEQ   #8,D1              There are 8 characters in the hex of our address
000011D4  4284                     199                  CLR.L   D4                 Ensure our counter (D4) is 0
000011D6  43F9 00000100            200                  LEA     IOStringLoc,A1     Load our IO String location, to store our output at  
000011DC                           201  
000011DC                           202          
000011DC  5244                     203  IOHEXtoASCII    ADDQ    #1,D4
000011DE  E99A                     204                  ROL.L   #4,D2              Get the left-most nyblle to the front..
000011E0  1602                     205                  MOVE.B  D2,D3              .. Put the front-most byte into D3    
000011E2  C63C 000F                206                  AND.B   #$0F,D3            Distill D3 down to the original left-most nybble
000011E6  B63C 0009                207                  CMP.B   #9,D3              See if our number is greater than 9..
000011EA  6F00 0004                208                  BLE     IODIGIT            If it is 9 or less, it's a digit..
000011EE  5E03                     209                  ADD.B   #7,D3              Otherwise it is a digit, and needs an additional 7
000011F0  0603 0030                210  IODIGIT         ADD.B   #48,D3             We now how the nybble's ASCII code
000011F4  12C3                     211                  MOVE.B  D3,(A1)+           Move the ASCII code into the output string at A1
000011F6  B204                     212                  CMP.B   D4,D1              See if we've read all the characters
000011F8  66E2                     213                  BNE.S   IOHEXtoASCII       Continue if we haven't
000011FA                           214          
000011FA  43F9 00000100            215                  LEA     IOStringLoc,A1     Now that we've populated the string, load it's beginning
00001200  103C 0001                216                  MOVE.B  #1,D0              Trap task 1 prints a string at A1 with #D1 bytes.
00001204  4E4F                     217                  TRAP    #15
00001206                           218  
00001206  43F9 00001302            219                  LEA     SPC,A1             Puts the space after the number
0000120C  103C 000D                220                  MOVE.B  #13,D0
00001210  4E4F                     221                  TRAP    #15
00001212                           222  
00001212  6000 FDFE                223                  BRA     IOLOOP
00001216                           224          
00001216  43F9 00001312            225  IODONE          LEA     OUTRO,A1           Display the ending message 
0000121C  103C 000E                226                  MOVE.B  #14,D0
00001220  4E4F                     227                  TRAP    #15
00001222  103C 0009                228                  MOVE.B  #9,D0
00001226  4E4F                     229                  TRAP    #15                Halt Simulator
00001228                           230          
00001228  FFFF FFFF                231                  SIMHALT
0000122C                           232          
0000122C  =0000000D                233  CR              EQU     $0D         
0000122C  =0000000A                234  LF              EQU     $0A 
0000122C  =00000100                235  IOStringLoc     EQU     $0100              This is where we will store the string of the user input, and other strings
0000122C                           236  
0000122C= 54 65 61 6D 20 43 ...    237  IntroMsg        DC.B    'Team Circles Disassembler ',CR,LF,0     Intro
00001249= 45 6E 74 65 72 20 ...    238  HexStart        DC.B    'Enter a starting address in hex of length 8 or less and even, or',CR,LF,'type in 0 to quit: ',0 Prompt for the user
0000129F= 45 6E 74 65 72 20 ...    239  HexEnd          DC.B    'Enter an ending address in hex of length 8 or less and even, or',CR,LF,'type in 0 to quit: ',0 Prompt for the user
000012F4= 59 6F 75 20 74 79 ...    240  RES             DC.B    'You typed in ',0                        Response to the user
00001302= 20 20 20 20 20 00        241  SPC             DC.B    '     ',0                                tab
00001308= 3C 45 41 3E 2C 3C ...    242  UnkEA           DC.B    '<EA>,<EA>',0                            Interim message for unkown EAs.
00001312= 47 6F 6F 64 62 79 ...    243  OUTRO           DC.B    'Goodbye !',0                            Outro message
0000131C= 49 20 61 6D 20 73 ...    244  FAIL_INPUT      DC.B    'I am sorry, but you typed an address that did not meet the criteria',CR,LF,0 
00001362                           245  StartAddress    DS.L    1
00001366                           246  EndingAddress   DS.L    1
0000136A                           247  COUNTER         DS.L    0 keep track of the lines on the screen
0000136A= 54 68 65 20 73 63 ...    248  ENTERPROMPT     DC.B    'The screen limit has been reached, please press enter to continue',CR,LF,0
000013AE                           249  
000013AE                           250  
000013AE                           251  
000013AE                           252  
000013AE                           253  
000013AE                           254  -------------------- end include --------------------
000013AE                           255      INCLUDE "OpCode.X68"    ; Handles determining OpCodes
000013AE                           256  
000013AE                           257  
000013AE                           258  ; Here we assume that A2 contains the address pointing to our OpCode, and
000013AE                           259  ;  we assume that A1 contains the address pointing to our IOStringLoc
000013AE  3A1A                     260  OPGETCODE   MOVE.W  (A2)+,D5    ; Push our OpCode into D5
000013B0  2C05                     261              MOVE.L  D5,D6       ; Also store the OpCode in D6
000013B2  E09E                     262              ROR.L   #8,D6       ; Rotate our OpCode to right-most nybble
000013B4  E89E                     263              ROR.L   #4,D6       ; 
000013B6  0206 000F                264              ANDI.B  #$0F,D6     ; Isolate our opcode nybble
000013BA  BC3C 0000                265              CMP.B   #$00,D6
000013BE  6700 0066                266              BEQ     ADDI        ; ADDI (Worked on)
000013C2  BC3C 0001                267              CMP.B   #$01,D6     
000013C6  6700 010A                268              BEQ     MOVEB       ; MOVE.B
000013CA  BC3C 0003                269              CMP.B   #$03,D6     
000013CE  6700 0112                270              BEQ     MOVEW       ; MOVE.W
000013D2  BC3C 0002                271              CMP.B   #$02,D6
000013D6  6700 011A                272              BEQ     MOVEL       ; MOVE.L
000013DA  BC3C 0004                273              CMP.B   #$04,D6
000013DE  6700 0150                274              BEQ     CNRJML      ; CLR or NOP or RTS or JSR or MOVEM or LEA (Implement)(Working on NOP,RTS,CLR)
000013E2  BC3C 0006                275              CMP.B   #$06,D6
000013E6  6700 0272                276              BEQ     Bcc         ; Bcc (BCC, BGT, BLE) (Implement)
000013EA  BC3C 0007                277              CMP.B   #$07,D6
000013EE  6700 026C                278              BEQ     MOVEQ       ; MOVEQ (Implement)
000013F2  BC3C 0008                279              CMP.B   #$08,D6
000013F6  6700 0266                280              BEQ     DIVU        ; DIVU (Implement)
000013FA  BC3C 0009                281              CMP.B   #$09,D6
000013FE  6700 0260                282              BEQ     SUB         ; SUB (Implement)
00001402  BC3C 000B                283              CMP.B   #$0B,D6
00001406  6700 025A                284              BEQ     CMP         ; CMP (Implement)
0000140A  BC3C 000C                285              CMP.B   #$0C,D6
0000140E  6700 0254                286              BEQ     MULSAND     ; MULS or AND opcodes (Implement AND)
00001412  BC3C 000D                287              CMP.B   #$0D,D6
00001416  6700 0362                288              BEQ     ADDADDA     ; ADD or ADDA (Implement)
0000141A  BC3C 000E                289              CMP.B   #$0E,D6 
0000141E  6700 035C                290              BEQ     ASLSRO      ; ASd (ASR) or LSd (LSL) or ROd (ROL) (Implement)
00001422  6000 035A                291              BRA     UNKNOWN  
00001426                           292     
00001426                           293  ADDI                                    ; Confirmed first left-most 4 bits of ADDI
00001426  2C05                     294              MOVE.L  D5,D6               ; Push D5 into D6
00001428  E09E                     295              ROR.L   #8,D6               ; Rotate left-most middle nybble to the right-most nybble
0000142A  0206 000F                296              ANDI.B  #$0F,D6             ; Isolate opcode nybble
0000142E  BC3C 0006                297              CMP.B   #$06,D6             ; If it matches ADDI's left-most middle nybble, branch
00001432  6700 0006                298              BEQ     ADDI8               ; First 8 left-most bits of ADDI confirmed 
00001436  6000 0346                299              BRA     UNKNOWN             ; else unknown                       
0000143A                           300              
0000143A                           301  ADDI8                                   ; Confirmed first left-most 8 bits of ADDI
0000143A                           302  
0000143A  2C05                     303              MOVE.L  D5,D6              ; Push D5 into D6 (Copy OPcode over isolated nybble)
0000143C  EC8E                     304              LSR.L   #6,D6              ; Shift six bits to the right
0000143E  0286 00000003            305              ANDI.L  #$0003,D6          ; Isolate the size bits
00001444                           306                         
00001444  BCBC 00000000            307              CMP.L   #$0000,D6          ; See if the size is '00'..
0000144A  6700 001A                308              BEQ     ADDIB              ; ..If so, it's ANDI.B
0000144E  BCBC 00000001            309              CMP.L   #$0001,D6          ; See if the size is '01'..
00001454  6700 0034                310              BEQ     ADDIW              ; ..If so, it's ANDI.W
00001458  BCBC 00000002            311              CMP.L   #$0002,D6          ; See if the size is '10'..
0000145E  6700 004E                312              BEQ     ADDIL              ; ..If so, it's ANDI.L
00001462                           313              
00001462  6000 031A                314              BRA     UNKNOWN            ; If it isn't any, then it's Unknown
00001466                           315              
00001466                           316  ADDIB       
00001466  22FC 41444449            317              MOVE.L  #'ADDI',(A1)+
0000146C  32FC 2E42                318              MOVE.W  #'.B',(A1)+
00001470  5C41                     319              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
00001472                           320              
00001472  22FC 20202020            321              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
00001478  5841                     322              ADDQ    #4,D1              ; We added 4 bytes, aka 4 spaces
0000147A                           323              
0000147A  2C05                     324              MOVE.L  D5,D6              ; Push D5 into D6
0000147C  0286 0000003F            325              ANDI.L  #$003F,D6          ; Isolate the Src EA bits 
00001482  4EB9 00001796            326              JSR EAGETSRCEA             ; Find and print the code stored in D6
00001488                           327              
00001488  4E75                     328              RTS
0000148A                           329              
0000148A                           330  ADDIW       
0000148A  22FC 41444449            331              MOVE.L  #'ADDI',(A1)+
00001490  32FC 2E57                332              MOVE.W  #'.W',(A1)+
00001494  5C41                     333              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
00001496                           334              
00001496  22FC 20202020            335              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
0000149C  5841                     336              ADDQ    #4,D1              ; We added 4 bytes, aka 4 spaces
0000149E                           337              
0000149E  2C05                     338              MOVE.L  D5,D6              ; Push D5 into D6
000014A0  0286 0000003F            339              ANDI.L  #$003F,D6          ; Isolate the Src EA bits 
000014A6  4EB9 00001796            340              JSR EAGETSRCEA             ; Find and print the code stored in D6
000014AC  4E75                     341              RTS
000014AE                           342              
000014AE                           343  ADDIL      
000014AE  22FC 41444449            344              MOVE.L  #'ADDI',(A1)+
000014B4  32FC 2E4C                345              MOVE.W  #'.L',(A1)+
000014B8  5C41                     346              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
000014BA                           347              
000014BA  22FC 20202020            348              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
000014C0  5841                     349              ADDQ    #4,D1              ; We added 4 bytes, aka 4 spaces
000014C2                           350              
000014C2  2C05                     351              MOVE.L  D5,D6              ; Push D5 into D6
000014C4  0286 0000003F            352              ANDI.L  #$003F,D6          ; Isolate the Src EA bits 
000014CA  4EB9 00001796            353              JSR EAGETSRCEA             ; Find and print the code stored in D6
000014D0                           354                  
000014D0  4E75                     355              RTS 
000014D2                           356                
000014D2  22FC 4D4F5645            357  MOVEB       MOVE.L  #'MOVE',(A1)+
000014D8  32FC 2E42                358              MOVE.W  #'.B',(A1)+
000014DC  5C41                     359              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
000014DE                           360              
000014DE  6000 0022                361              BRA MOVEOP
000014E2                           362              
000014E2  22FC 4D4F5645            363  MOVEW       MOVE.L  #'MOVE',(A1)+
000014E8  32FC 2E57                364              MOVE.W  #'.W',(A1)+
000014EC  5C41                     365              ADDQ    #6,D1               ; We added 6 new characters to our IOStringLoc 
000014EE                           366              
000014EE  6000 0012                367              BRA MOVEOP
000014F2                           368              
000014F2  22FC 4D4F5645            369  MOVEL       MOVE.L  #'MOVE',(A1)+
000014F8  32FC 2E4C                370              MOVE.W  #'.L',(A1)+
000014FC  5C41                     371              ADDQ    #6,D1               ; We added 6 new characters to our IOStringLoc 
000014FE                           372              
000014FE  6000 0002                373              BRA MOVEOP
00001502                           374              
00001502  22FC 20202020            375  MOVEOP      MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
00001508  5841                     376              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
0000150A                           377              
0000150A  2C05                     378              MOVE.L  D5,D6               ; Push D5 into D6
0000150C  0286 0000003F            379              ANDI.L  #$003F,D6           ; Isolate the Src EA bits 
00001512  4EB9 00001796            380              JSR EAGETSRCEA              ; Find and print the code stored in D6
00001518                           381              
00001518  12FC 002C                382              MOVE.B  #',',(A1)+
0000151C  5241                     383              ADDQ    #1,D1
0000151E                           384              
0000151E  2C05                     385              MOVE.L  D5,D6               ; Push D5 into D6
00001520  EC8E                     386              LSR.L   #6,D6               ; Shift six bits to the right
00001522  0286 0000003F            387              ANDI.L  #$003F,D6           ; Isolate the Dst EA bits
00001528  4EB9 000017CE            388              JSR EAGETDSTEA
0000152E  4E75                     389              RTS
00001530                           390              
00001530                           391  ; This label determines if the code is either CLR or NOP or RTS or JSR or MOVEM or LEA
00001530                           392  ; Here we assume that the first left-most four bits equal 0100            
00001530                           393  CNRJML      
00001530  2C05                     394              MOVE.L  D5,D6              ; Push D5 into D6 (Copy OPcode over isolated nybble)
00001532                           395              
00001532                           396              *NOP & RTS's machine code is uniquely hardcoded, check first
00001532  BCBC 00004E71            397              CMP.L   #$4E71,D6          ; See if the OPcode matches NOP's hardcode
00001538  6700 0060                398              BEQ     NOP
0000153C  BCBC 00004E75            399              CMP.L   #$4E75,D6          ; See if the OPcode matches RTS's hardcode
00001542  6700 006A                400              BEQ     RTS
00001546                           401                                         ; CLR's middle most left nybble is unique (0010)
00001546  E09E                     402              ROR.L   #8,D6              ; Rotate our OpCode to right-most nybble
00001548  0206 000F                403              ANDI.B  #$0F,D6            ; Isolate our opcode nybble
0000154C  BC3C 0002                404              CMP.B   #$02,D6            ; See if matches nybble
00001550  6700 0046                405              BEQ     CLR               
00001554                           406              
00001554  2C05                     407              MOVE.L  D5,D6              ; Push D5 into D6
00001556  E08E                     408              LSR.L   #8,D6              ; Shift 8 bits to the right
00001558                           409              
00001558  0806 0000                410              BTST    #$00,D6            ; See if our right-most bit is set
0000155C  6600 00F0                411              BNE     LEA                ; If our bit is set, branch to LEA     
00001560                           412              
00001560  E28E                     413              LSR.L   #1,D6              ; Shift another bit
00001562  0806 0000                414              BTST    #$00,D6            ; See if our right-most bit is set
00001566  6600 005A                415              BNE     JSR                ; If this one is set, branch to JSR
0000156A                           416              
0000156A  6000 0062                417              BRA     MOVEM
0000156E                           418                                         ; LEA's middle most left nybble is unique (xxx1)
0000156E  0806 0001                419              BTST    #1,D6              ; Check the right most bit's value
00001572  6700 00DA                420              BEQ     LEA                ; If equals 1, branch
00001576                           421                 
00001576                           422                                         ; MOVEM's middle most left nybble is unique (1x00)
00001576  E29E                     423              ROR.L   #1,D6              ; first bit must be 0, rotate 1 bit 
00001578  0806 0000                424              BTST    #0,D6               ; Compare again for 00 match
0000157C  6700 0050                425              BEQ     MOVEM                           
00001580                           426                                         
00001580  2C05                     427              MOVE.L  D5,D6              ; Push D5 into D6; JSR's middle nybbles are unique (1110 10xx)
00001582  EC9E                     428              ROR.L   #6,D6              ; Rotate 6 bits
00001584  0286 000000FF            429              ANDI.L  #$00FF,D6          ; Isolate the 8 known bits (00 1110 10)
0000158A  BCBC 0000003A            430              CMP.L   #$003A,D6          ; Compare
00001590  6700 0030                431              BEQ     JSR                ; Branch
00001594                           432              
00001594  6000 01E8                433              BRA     UNKNOWN            ; If it doesnt any match, then it's Unknown
00001598                           434  
00001598                           435  
00001598                           436  ;  Here we assume the first left-most 8 bits have been confirmed: 0100 0010
00001598                           437  CLR         *(Implement)
00001598                           438  
00001598  4E75                     439              RTS
0000159A                           440              
0000159A                           441  ;  Here we assume that all 16 bits have been confirmed 
0000159A                           442  NOP
0000159A  32FC 4E4F                443              MOVE.W  #'NO',(A1)+
0000159E  12FC 0050                444              MOVE.B  #'P',(A1)+
000015A2  5641                     445              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
000015A4                           446              
000015A4  22FC 20202020            447              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
000015AA  5841                     448              ADDQ    #4,D1              ; We added 4 bytes, aka 4 spaces        
000015AC  4E75                     449              RTS
000015AE                           450  
000015AE                           451  ;  Here we assume that all 16 bits have been confirmed            
000015AE                           452  RTS         
000015AE  32FC 5254                453              MOVE.W  #'RT',(A1)+
000015B2  12FC 0053                454              MOVE.B  #'S',(A1)+
000015B6  5641                     455              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
000015B8                           456              
000015B8  22FC 20202020            457              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
000015BE  5841                     458              ADDQ    #4,D1              ; We added 4 bytes, aka 4 spaces        
000015C0  4E75                     459              RTS
000015C2                           460              
000015C2                           461  
000015C2                           462  ;  Here we assume the first left-most 10 bits have been confirmed: 0100 1110 10 
000015C2                           463  JSR         *(Implement)
000015C2  32FC 4A53                464              MOVE.W  #'JS',(A1)+
000015C6  12FC 0052                465              MOVE.B  #'R',(A1)+
000015CA  5641                     466              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
000015CC  4E75                     467              RTS
000015CE                           468              
000015CE                           469  
000015CE                           470  ;  Here we assume that these left-most have been confirmed, where - have not been confirmed: 0100 --00
000015CE                           471  MOVEM       *(Implement)
000015CE  22FC 4D4F5645            472              MOVE.L  #'MOVE',(A1)+
000015D4  32FC 4D2E                473              MOVE.W  #'M.',(A1)+
000015D8  5C41                     474              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
000015DA                           475              
000015DA  2C05                     476              MOVE.L  D5,D6              ; Copy our OpCode
000015DC  EC8E                     477              LSR.L   #6,D6              ; Shift it 6 bits to the right
000015DE  0806 0000                478              BTST    #$00,D6            ; If our size bit is 0..
000015E2  6700 0006                479              BEQ     MOVEMW             ; .. Its a MOVEM of size W
000015E6  6000 000C                480              BRA     MOVEML             ; .. Otherwise it's of size L
000015EA                           481  
000015EA  12FC 0057                482  MOVEMW      MOVE.B  #'W',(A1)+
000015EE  5241                     483              ADDQ    #1,D1              ; We've added another character into IOStringLoc
000015F0  6000 0008                484              BRA     MOVEMOP            ; MovemOp label, to skip MovemL label
000015F4                           485              
000015F4  12FC 004C                486  MOVEML      MOVE.B  #'L',(A1)+
000015F8  5241                     487              ADDQ    #1,D1              ; We've added another character into IOStringLoc
000015FA                           488              
000015FA  12FC 0020                489  MOVEMOP     MOVE.B  #' ',(A1)+         ; Add a spacer into our IOStringLoc
000015FE  32FC 2020                490              MOVE.W  #'  ',(A1)+        ;
00001602  12FC 0020                491              MOVE.B  #' ',(A1)+         ;
00001606  5841                     492              ADDQ    #4,D1              ; We added 4 bytes, aka 4 spaces 
00001608                           493              
00001608  E88E                     494              LSR.L   #4,D6              ; Shift our OpCode 4 bits to the left of Size (going to the right)
0000160A  0806 0000                495              BTST    #$00,D6            ; Check our Direction bit
0000160E  6700 0006                496              BEQ     MOVEMPRED          ; If it's 0, our direction is Pre Decrement (eg. Move TO the stack)
00001612  6000 001E                497              BRA     MOVEMPOSTI         ; Otherwise, it's Post Increment (eg. Move FROM the stack)
00001616                           498              
00001616                           499  MOVEMPRED   ; This part is where we get the gross A0-A6/D0-D7 part
00001616  4EB9 00001952            500              JSR     EAMOVEMPRED  
0000161C                           501              
0000161C  12FC 002C                502              MOVE.B  #',',(A1)+
00001620  5241                     503              ADDQ    #1,D1
00001622                           504              
00001622  2C05                     505              MOVE.L  D5,D6              ; Copy our OpCode to D6
00001624  0286 0000003F            506              ANDI.L  #$3F,D6            ; Isolate our EA src bits
0000162A                           507              
0000162A  4EB9 00001796            508              JSR EAGETSRCEA  
00001630                           509            
00001630  4E75                     510              RTS
00001632                           511  
00001632  2C05                     512  MOVEMPOSTI  MOVE.L  D5,D6              ; Copy our OpCode to D6
00001634  0286 0000003F            513              ANDI.L  #$3F,D6            ; Isolate our EA src bits
0000163A                           514              
0000163A  4EB9 00001796            515              JSR EAGETSRCEA  
00001640                           516              
00001640  12FC 002C                517              MOVE.B  #',',(A1)+
00001644  5241                     518              ADDQ    #1,D1
00001646                           519              
00001646                           520              ; This part is where we get the gross A0-A6/D0-D7 part
00001646  4EB9 00001868            521              JSR     EAMOVEMPOSTI
0000164C                           522              
0000164C  4E75                     523              RTS
0000164E                           524              
0000164E                           525  
0000164E                           526  ;  Here we assume that these left-most have been confirmed, where - have not been confirmed: 0100 ---1            
0000164E                           527  LEA         *(Implement)
0000164E  32FC 4C45                528              MOVE.W  #'LE',(A1)+
00001652  12FC 0041                529              MOVE.B  #'A',(A1)+
00001656  5641                     530              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
00001658  4E75                     531              RTS      
0000165A                           532              
0000165A                           533  Bcc         *(Implement)
0000165A                           534                   
0000165A  4E75                     535              RTS
0000165C                           536              
0000165C                           537  MOVEQ       *(Implement)
0000165C                           538                   
0000165C  4E75                     539              RTS 
0000165E                           540              
0000165E                           541  DIVU        *(Implement)
0000165E                           542                   
0000165E  4E75                     543              RTS
00001660                           544              
00001660                           545  SUB         *(Implement)
00001660                           546                   
00001660  4E75                     547              RTS
00001662                           548    
00001662                           549  CMP         *(Implement)
00001662                           550                   
00001662  4E75                     551              RTS         
00001664                           552         
00001664                           553  ; This label determines if the code is either MULS or AND, by looking at it's size bits     
00001664  2C05                     554  MULSAND     MOVE.L  D5,D6               ; Copy D5 into D6
00001666  EC8E                     555              LSR.L   #6,D6               ; Shift the size bits to the far right
00001668  0206 0007                556              ANDI.B  #$7,D6              ; Isolate the size bits
0000166C  BC3C 0007                557              CMP.B   #7,D6               ; See if the size is '111'..
00001670  6704                     558              BEQ.S   MULS                ; ..If so, it's a MULS opcode
00001672  6000 003A                559              BRA     AND                 ; Otherwise, it's an AND code
00001676                           560          
00001676  22FC 4D554C53            561  MULS        MOVE.L  #'MULS',(A1)+
0000167C  5841                     562              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
0000167E                           563              
0000167E  22FC 20202020            564              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
00001684  5841                     565              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
00001686                           566              
00001686  2C05                     567              MOVE.L  D5,D6               ; Copy D5 into D6
00001688  0286 0000003F            568              ANDI.L  #$003F,D6           ; Isolate the Src EA bits
0000168E  4EB9 00001796            569              JSR EAGETSRCEA
00001694                           570              
00001694  12FC 002C                571              MOVE.B  #',',(A1)+
00001698  5241                     572              ADDQ    #1,D1
0000169A                           573              
0000169A  2C05                     574              MOVE.L  D5,D6               ; Copy D5 into D6
0000169C  E09E                     575              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
0000169E  E29E                     576              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
000016A0  0286 00000003            577              ANDI.L  #$0003,D6           ; Isolate the Dn Destination bits
000016A6  4EF9 00001802            578              JMP EADN
000016AC                           579              
000016AC  4E75                     580              RTS
000016AE                           581              
000016AE                           582  ; At this point, we know D6 is the size of our opcode
000016AE  22FC 414E442E            583  AND         MOVE.L  #'AND.',(A1)+
000016B4  5841                     584              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000016B6                           585              
000016B6  BC3C 0006                586              CMP.B   #%0110,D6            ; See if D6 is size "%100" through "%110"..
000016BA  6700 0026                587              BEQ     ANDLEA              ; If it is, our OpCode is in the format of..
000016BE  BC3C 0005                588              CMP.B   #%101,D6            ; .. Dn ~ <EA> --> <EA>
000016C2  6700 0028                589              BEQ     ANDWEA
000016C6  BC3C 0004                590              CMP.B   #%100,D6
000016CA  6700 002A                591              BEQ     ANDBEA
000016CE                           592              
000016CE  BC3C 0002                593              CMP.B   #%10,D6             ; See if D6 is size "%000" through "%010"..
000016D2  6700 005A                594              BEQ     ANDLDN              ; If it is, our OpCode is in the format of..
000016D6  BC3C 0001                595              CMP.B   #%01,D6             ; .. <EA> ~ Dn --> Dn
000016DA  6700 005C                596              BEQ     ANDWDN
000016DE  6000 0062                597              BRA     ANDBDN              ; == 000 at this point
000016E2                           598              
000016E2  12FC 004C                599  ANDLEA      MOVE.B  #'L',(A1)+
000016E6  5241                     600              ADDQ    #1,D1               ; We added 1 byte into D1
000016E8  6000 0016                601              BRA     ANDEA
000016EC                           602              
000016EC  12FC 0057                603  ANDWEA      MOVE.B  #'W',(A1)+
000016F0  5241                     604              ADDQ    #1,D1               ; We added 1 byte into D1
000016F2  6000 000C                605              BRA     ANDEA
000016F6                           606  
000016F6  12FC 0042                607  ANDBEA      MOVE.B  #'B',(A1)+
000016FA  5241                     608              ADDQ    #1,D1               ; We added 1 byte into D1
000016FC  6000 0002                609              BRA     ANDEA
00001700                           610  
00001700  12FC 0009                611  ANDEA       MOVE.B  #$09,(A1)+          ; Add a spacer into our IOStringLoc
00001704  5241                     612              ADDQ    #1,D1               ; We added 4 bytes, aka 4 spaces
00001706                           613              
00001706  2C05                     614              MOVE.L  D5,D6
00001708  E08E                     615              LSR.L   #8,D6               ; Shift our OpCode a total of 9 bits to the right
0000170A  E28E                     616              LSR.L   #1,D6               ; 
0000170C  0286 00000007            617              ANDI.L  #$07,D6             ; Isolate our data register
00001712                           618              
00001712  4EB9 00001802            619              JSR EADN
00001718                           620              
00001718  12FC 002C                621              MOVE.B  #',',(A1)+
0000171C  5241                     622              ADDQ    #1,D1
0000171E                           623              
0000171E  2C05                     624              MOVE.L  D5,D6               ; Copy our OpCode again
00001720  0286 0000003F            625              ANDI.L  #$3F,D6             ; Isolate our EA bits
00001726                           626              
00001726  4EB9 00001796            627              JSR EAGETSRCEA  
0000172C                           628              
0000172C  4E75                     629              RTS
0000172E                           630              
0000172E  12FC 004C                631  ANDLDN      MOVE.B  #'L',(A1)+
00001732  5241                     632              ADDQ    #1,D1               ; We added 1 byte into D1
00001734  6000 0016                633              BRA ANDDN
00001738                           634              
00001738  12FC 0057                635  ANDWDN      MOVE.B  #'W',(A1)+
0000173C  5241                     636              ADDQ    #1,D1               ; We added 1 byte into D1
0000173E  6000 000C                637              BRA ANDDN
00001742                           638  
00001742  12FC 0042                639  ANDBDN      MOVE.B  #'B',(A1)+
00001746  5241                     640              ADDQ    #1,D1               ; We added 1 byte into D1
00001748  6000 0002                641              BRA ANDDN  
0000174C                           642  
0000174C                           643  ANDDN
0000174C  12FC 0009                644              MOVE.B  #$09,(A1)+          ; Add a spacer into our IOStringLoc
00001750  5241                     645              ADDQ    #1,D1               ; We added 4 bytes, aka 4 spaces
00001752                           646              
00001752  2C05                     647              MOVE.L  D5,D6               ; Copy our OpCode again
00001754  0286 0000003F            648              ANDI.L  #$3F,D6             ; Isolate our EA bits
0000175A                           649              
0000175A  4EB9 00001796            650              JSR EAGETSRCEA              
00001760                           651              
00001760  12FC 002C                652              MOVE.B  #',',(A1)+
00001764  5241                     653              ADDQ    #1,D1
00001766                           654              
00001766  2C05                     655              MOVE.L  D5,D6
00001768  E08E                     656              LSR.L   #8,D6               ; Shift our OpCode a total of 9 bits to the right
0000176A  E28E                     657              LSR.L   #1,D6               ; 
0000176C  0286 00000007            658              ANDI.L  #$07,D6             ; Isolate our data register
00001772                           659              
00001772  4EB9 00001802            660              JSR EADN
00001778                           661              
00001778  4E75                     662              RTS
0000177A                           663  
0000177A                           664  ; This label determines if the code is either ADD or ADDA           
0000177A                           665  ADDADDA     *(Implement)
0000177A                           666                   
0000177A  4E75                     667              RTS
0000177C                           668  
0000177C                           669  ; This label determines if the code is either ASd (ASR) or LSd (LSL) or ROd (ROL) 
0000177C                           670  ASLSRO      *(Implement)
0000177C                           671                   
0000177C  4E75                     672              RTS
0000177E                           673  UNKNOWN
0000177E  22FC 3F3F3F3F            674              MOVE.L  #'????',(A1)+
00001784  5841                     675              ADDQ    #4,D1           ; We added 4 new characters to our IOStringLoc 
00001786                           676              
00001786  22FC 20202020            677              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
0000178C  5841                     678              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
0000178E  32FC 2020                679              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
00001792  5441                     680              ADDQ    #2,D1               ; We added 2 bytes, aka 2 spaces
00001794                           681          
00001794  4E75                     682              RTS
00001796                           683  
00001796                           684  
00001796                           685  -------------------- end include --------------------
00001796                           686      INCLUDE "EA.X68"        ; Handles EA types
00001796                           687  
00001796                           688  
00001796                           689  ; It is assumed that D6 contains the bits for the EA, algined to the far right. D5 contains
00001796                           690  ;  the original full op-code being reffered to. We assume that A2 contains the address 
00001796                           691  ;  pointing to the start of our EA address (if applicable), and we assume that A1 contains
00001796                           692  ;  the address pointing to our IOStringLoc. D1 contains the current length to be printed from A1
00001796                           693  
00001796                           694  ; For this method, D6 is in the format of: <3 bits Src Mode><3 bits Src Reg> 
00001796                           695  EAGETSRCEA  
00001796  E69E                     696      ROR.L   #3,D6       ; Rotate our bits 3 to the right
00001798  1E06                     697      MOVE.B  D6,D7       ; Store the mode of the EA in D7
0000179A  E79E                     698      ROL.L   #3,D6       ; Rotate our 3 bits back
0000179C  0286 00000007            699      ANDI.L  #$0007,D6   ; Isolate the 3 rightmost bits as 'Reg'
000017A2  BE3C 0000                700      CMP.B   #0,D7       ; See if the mode == '000'
000017A6  6700 005A                701      BEQ     EADN
000017AA                           702  
000017AA  BE3C 0001                703      CMP.B   #1,D7       ; See if the mode == '001'
000017AE  6700 0060                704      BEQ     EAAN        ; Address Register Direct
000017B2                           705      
000017B2  BE3C 0002                706      CMP.B   #2,D7       ; See if the mode == '010'
000017B6  6700 0066                707      BEQ     EAANI       ; Address Register Indirect
000017BA                           708      
000017BA  BE3C 0003                709      CMP.B   #3,D7       ; See if the mode == '011'
000017BE  6700 0074                710      BEQ     EAAPOST     ; Address Register Indirect with Post increment
000017C2                           711      
000017C2  BE3C 0004                712      CMP.B   #4,D7       ; See if the mode == '100'
000017C6  6700 0086                713      BEQ     EAAPRE      ; Address Register Indirect with Pre increment
000017CA                           714      
000017CA                           715  
000017CA  6000 026E                716      BRA     EAUNKN
000017CE                           717  
000017CE                           718  ; For this method, D6 is in the format of: <3 bits Dst Reg><3 bits Dst Mode> 
000017CE                           719  EAGETDSTEA  
000017CE  1E06                     720      MOVE.B  D6,D7       ; Store the right-most byte into D7
000017D0  CE3C 0007                721      AND.B   #$07,D7     ; Isolate 3 rightmost bits as 'Mode'
000017D4  E68E                     722      LSR.L   #3,D6       ; Shift D6 to the right 3 bits (D6 Byte = 'Reg')
000017D6  BE3C 0000                723      CMP.B   #0,D7       ; See if the mode == '000'
000017DA  6700 0026                724      BEQ     EADN
000017DE                           725  
000017DE  BE3C 0001                726      CMP.B   #1,D7       ; See if the mode == '001'
000017E2  6700 002C                727      BEQ     EAAN        ; Address Register Direct
000017E6                           728      
000017E6  BE3C 0002                729      CMP.B   #2,D7       ; See if the mode == '010'
000017EA  6700 0032                730      BEQ     EAANI       ; Address Register Indirect
000017EE                           731      
000017EE  BE3C 0003                732      CMP.B   #3,D7       ; See if the mode == '011'
000017F2  6700 0040                733      BEQ     EAAPOST     ; Address Register Indirect with Post increment
000017F6                           734      
000017F6  BE3C 0004                735      CMP.B   #4,D7       ; See if the mode == '100'
000017FA  6700 0052                736      BEQ     EAAPRE      ; Address Register Indirect with Pre increment
000017FE                           737      
000017FE                           738  
000017FE  6000 023A                739      BRA     EAUNKN
00001802                           740           
00001802                           741  ;If the EA is a Dn EA    
00001802                           742  ;This method assume D6 contains the Reg for Dn  
00001802                           743  EADN
00001802  12FC 0044                744      MOVE.B  #'D',(A1)+
00001806  0606 0030                745      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
0000180A  12C6                     746      MOVE.B  D6,(A1)+
0000180C  5441                     747      ADDQ    #2,D1
0000180E  4E75                     748      RTS
00001810                           749  ;If the EA is a An EA    
00001810                           750  ;This method assume D6 contains the Reg for An  
00001810                           751  EAAN
00001810  12FC 0041                752      MOVE.B  #'A',(A1)+
00001814  0606 0030                753      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
00001818  12C6                     754      MOVE.B  D6,(A1)+
0000181A  5441                     755      ADDQ    #2,D1
0000181C  4E75                     756      RTS
0000181E                           757  
0000181E                           758  ;If the EA is a (An) EA    
0000181E                           759  ;This method assume D6 contains the Reg for (An)  
0000181E                           760  EAANI
0000181E  12FC 0028                761      MOVE.B  #'(',(A1)+
00001822  12FC 0041                762      MOVE.B  #'A',(A1)+
00001826  0606 0030                763      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
0000182A  12C6                     764      MOVE.B  D6,(A1)+
0000182C  12FC 0029                765      MOVE.B  #')',(A1)+
00001830  5841                     766      ADDQ    #4,D1
00001832  4E75                     767      RTS
00001834                           768  ;If the EA is a (An)+ EA    
00001834                           769  ;This method assume D6 contains the Reg for (An)+  
00001834                           770  EAAPOST
00001834  12FC 0028                771      MOVE.B  #'(',(A1)+
00001838  12FC 0041                772      MOVE.B  #'A',(A1)+
0000183C  0606 0030                773      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
00001840  12C6                     774      MOVE.B  D6,(A1)+
00001842  12FC 0029                775      MOVE.B  #')',(A1)+
00001846  12FC 002B                776      MOVE.B  #'+',(A1)+
0000184A  5A41                     777      ADDQ    #5,D1
0000184C  4E75                     778      RTS
0000184E                           779  ;If the EA is a -(An) EA    
0000184E                           780  ;This method assume D6 contains the Reg for -(An) 
0000184E                           781  EAAPRE
0000184E  12FC 002D                782      MOVE.B  #'-',(A1)+
00001852  12FC 0028                783      MOVE.B  #'(',(A1)+
00001856  12FC 0041                784      MOVE.B  #'A',(A1)+
0000185A  0606 0030                785      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
0000185E  12C6                     786      MOVE.B  D6,(A1)+
00001860  12FC 0029                787      MOVE.B  #')',(A1)+
00001864  5A41                     788      ADDQ    #5,D1
00001866  4E75                     789      RTS 
00001868                           790      
00001868                           791  ; MOVEM's (A7)+,A0-A6,D0-D7 format
00001868                           792  ; Gets the follow-up WORD in order to process it
00001868                           793  EAMOVEMPOSTI
00001868  3C1A                     794      MOVE.W  (A2)+,D6    ; Get follow-up word for processing
0000186A                           795      
0000186A  2E3C 000000FF            796      MOVE.L  #$FF,D7     ; Initilize D7 to be our counter
00001870                           797      
00001870  EE9E                     798      ROR.L   #7,D6       ; Shift our new bits seven to the right
00001872                           799  IANSL    ; Increment An Start Loop  
00001872  5247                     800      ADDQ    #1,D7       ; Itterate D7
00001874  E29E                     801      ROR.L   #1,D6       ; Rotate one bit to the right  
00001876  BE3C 0008                802      CMP.B   #8,D7       ; Check if we've hit A8
0000187A  6700 0056                803      BEQ     INOA        ; If we have, break the loop
0000187E  0806 0000                804      BTST    #$00,D6     ; Check the far right bit
00001882  67EE                     805      BEQ     IANSL       ; If it isn't 1, continue checking
00001884                           806      
00001884  12FC 0041                807      MOVE.B  #'A',(A1)+
00001888                           808      
00001888  0607 0030                809      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
0000188C  12C7                     810      MOVE.B  D7,(A1)+
0000188E  5441                     811      ADDQ    #2,D1
00001890                           812      
00001890  0407 002F                813      SUB.B   #47,D7      ; Balance out out D7 from ASCII conversion
00001894  E29E                     814      ROR.L   #1,D6       ; Rotate one bit to the right  
00001896  BE3C 0008                815      CMP.B   #8,D7       ; Check if we've hit A8
0000189A  6700 003A                816      BEQ     INOEA       ; If we have, break the loop
0000189E  0806 0000                817      BTST    #$00,D6     ; Check the far right bit
000018A2  6700 0032                818      BEQ     INOEA       ; If it is 0, skip past -A
000018A6                           819  IANEL    ; Increment An End Loop  
000018A6  5247                     820      ADDQ    #1,D7       ; Itterate D7
000018A8  E29E                     821      ROR.L   #1,D6       ; Rotate one bit to the right  
000018AA  BE3C 0008                822      CMP.B   #8,D7       ; Check if we've hit A8
000018AE  6700 0008                823      BEQ     IANELE      ; If we have, break the loop
000018B2  0806 0000                824      BTST    #$00,D6     ; Check the far right bit
000018B6  66EE                     825      BNE     IANEL       ; If it isn't 0, continue checking    
000018B8                           826  IANELE
000018B8  5347                     827      SUBQ    #1,D7
000018BA                           828      
000018BA  12FC 002D                829      MOVE.B  #'-',(A1)+
000018BE  12FC 0041                830      MOVE.B  #'A',(A1)+
000018C2                           831      
000018C2  0607 0030                832      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
000018C6  12C7                     833      MOVE.B  D7,(A1)+
000018C8  5641                     834      ADDQ    #3,D1
000018CA  0407 0030                835      SUB.B   #48,D7      ; SUB 48 into D7 for ASCII conversion
000018CE  6000 0006                836      BRA     INOEA       ; Branch past the 'No An Skip Label'
000018D2                           837  
000018D2                           838  INOA     ; No An Skip label 
000018D2  08C7 001F                839      BSET.L  #$1F,D7     ; Set our MSB to equal 1
000018D6                           840   
000018D6                           841  INOEA    ; No An Ending (aka Single An) Skip Label
000018D6  5207                     842      ADD.B   #1,D7       ; Add 1 for 0ing balance
000018D8  0887 0008                843      BCLR    #$08,D7     ; Incase we're iterated base FF in A
000018DC  EFBE                     844      ROL.L   D7,D6       ; Rotate our A bits back into view
000018DE  E19E                     845      ROL.L   #8,D6       ; Rotate our D bits back into place
000018E0  E39E                     846      ROL.L   #1,D6       ; Rotate an extra bit over, to account for the loop
000018E2  1E3C 00FF                847      MOVE.B  #$FF,D7     ; Initilize D7
000018E6                           848  
000018E6                           849  IDNSL    ; Increment Dn Start Loop  
000018E6  5247                     850      ADDQ    #1,D7       ; Itterate D7
000018E8  E29E                     851      ROR.L   #1,D6       ; Rotate one bit to the right  
000018EA  BE3C 0008                852      CMP.B   #8,D7       ; Check if we've hit D8
000018EE  6700 0060                853      BEQ     ENDEAMOVEMPI ; If we have, break the loop
000018F2  0806 0000                854      BTST    #$00,D6     ; Check the far right bit
000018F6  67EE                     855      BEQ     IDNSL       ; If it isn't 1, continue checking     
000018F8                           856      
000018F8                           857      ; The issue with the below line:
000018F8                           858      ;  We need to skip / if there are no An registers, as we do in INOA
000018F8                           859      ;  We also need to skip / if there are no Dn registers, as we do here
000018F8                           860      ;  However, we need to skip / if there are no An's, but we still need to run
000018F8                           861      ;   the above code to determine the starting Dn, so we use the MSB of D7
000018F8                           862      ;   as a boolean to determine if we had an An
000018F8  0807 001F                863      BTST    #$1F,D7     ; If our MSB is equal to 1, we have no A
000018FC  6600 0008                864      BNE     INOA2       ; .. So, skip the /
00001900  12FC 002F                865      MOVE.B  #'/',(A1)+
00001904  5241                     866      ADDQ    #1,D1
00001906                           867  INOA2     ; 2nd No An Skip label 
00001906  0887 001F                868      BCLR    #$1F,D7     ; If our MSB is set, clear it
0000190A  12FC 0044                869      MOVE.B  #'D',(A1)+
0000190E  0607 0030                870      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
00001912  12C7                     871      MOVE.B  D7,(A1)+    
00001914  5441                     872      ADDQ    #2,D1
00001916                           873      
00001916  0407 002F                874      SUB.B   #47,D7      ; Balance out our D7 from ASCII conversion
0000191A  E29E                     875      ROR.L   #1,D6       ; Rotate one bit to the right  
0000191C  BE3C 0008                876      CMP.B   #8,D7       ; Check if we've hit A8
00001920  6700 002E                877      BEQ     ENDEAMOVEMPI  ; If we have, break to the end
00001924  0806 0000                878      BTST    #$00,D6     ; Check the far right bit
00001928  6700 0026                879      BEQ     ENDEAMOVEMPI ; If it is 0, we have no -Dn
0000192C                           880  IDNEL    ; Increment Dn End Loop  
0000192C  5247                     881      ADDQ    #1,D7       ; Itterate D7
0000192E  E29E                     882      ROR.L   #1,D6       ; Rotate one bit to the right  
00001930  BE3C 0008                883      CMP.B   #8,D7       ; Check if we've hit A8
00001934  6700 0008                884      BEQ     INENLE      ; If we have, break the loop
00001938  0806 0000                885      BTST    #$00,D6     ; Check the far right bit
0000193C  66EE                     886      BNE     IDNEL       ; If it isn't 0, continue checking    
0000193E                           887  INENLE
0000193E  5347                     888      SUBQ    #1,D7
00001940                           889      
00001940  12FC 002D                890      MOVE.B  #'-',(A1)+
00001944  12FC 0044                891      MOVE.B  #'D',(A1)+
00001948                           892  
00001948  0607 0030                893      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
0000194C  12C7                     894      MOVE.B  D7,(A1)+
0000194E  5641                     895      ADDQ    #3,D1 
00001950                           896      ; If no Dn, skip to the end
00001950                           897  ENDEAMOVEMPI
00001950  4E75                     898      RTS
00001952                           899      
00001952                           900  EAMOVEMPRED
00001952  3C1A                     901      MOVE.W  (A2)+,D6    ; Get follow-up word for processing
00001954                           902      
00001954  2E3C 000000FF            903      MOVE.L  #$FF,D7     ; Initilize D7 to be our counter
0000195A                           904      
0000195A  E09E                     905      ROR.L   #8,D6       ; Shift our new bits eight to the right
0000195C                           906  DANSL    ; Decrement An Start Loop  
0000195C  5247                     907      ADDQ    #1,D7       ; Itterate D7
0000195E  E39E                     908      ROL.L   #1,D6       ; Rotate one bit to the left  
00001960  BE3C 0008                909      CMP.B   #8,D7       ; Check if we've hit A8
00001964  6700 0056                910      BEQ     DNOA        ; If we have, break the loop
00001968  0806 0000                911      BTST    #$00,D6     ; Check the far right bit
0000196C  67EE                     912      BEQ     DANSL       ; If it isn't 1, continue checking
0000196E                           913      
0000196E  12FC 0041                914      MOVE.B  #'A',(A1)+
00001972                           915      
00001972  0607 0030                916      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
00001976  12C7                     917      MOVE.B  D7,(A1)+
00001978  5441                     918      ADDQ    #2,D1
0000197A                           919      
0000197A  0407 002F                920      SUB.B   #47,D7      ; Balance out out D7 from ASCII conversion
0000197E  E39E                     921      ROL.L   #1,D6       ; Rotate one bit to the left  
00001980  BE3C 0008                922      CMP.B   #8,D7       ; Check if we've hit A8
00001984  6700 003A                923      BEQ     DNOEA       ; If we have, break the loop
00001988  0806 0000                924      BTST    #$00,D6     ; Check the far right bit
0000198C  6700 0032                925      BEQ     DNOEA       ; If it is 0, skip past -A
00001990                           926  DANEL    ; Decrement An End Loop  
00001990  5247                     927      ADDQ    #1,D7       ; Itterate D7
00001992  E39E                     928      ROL.L   #1,D6       ; Rotate one bit to the left  
00001994  BE3C 0008                929      CMP.B   #8,D7       ; Check if we've hit A8
00001998  6700 0008                930      BEQ     DANELE      ; If we have, break the loop
0000199C  0806 0000                931      BTST    #$00,D6     ; Check the far right bit
000019A0  66EE                     932      BNE     DANEL       ; If it isn't 0, continue checking    
000019A2                           933  DANELE
000019A2  5347                     934      SUBQ    #1,D7
000019A4                           935      
000019A4  12FC 002D                936      MOVE.B  #'-',(A1)+
000019A8  12FC 0041                937      MOVE.B  #'A',(A1)+
000019AC                           938      
000019AC  0607 0030                939      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
000019B0  12C7                     940      MOVE.B  D7,(A1)+
000019B2  5641                     941      ADDQ    #3,D1
000019B4  0407 0030                942      SUB.B   #48,D7      ; SUB 48 into D7 for ASCII conversion
000019B8  6000 0006                943      BRA     DNOEA       ; Branch past the 'No An Skip Label'
000019BC                           944  
000019BC                           945  DNOA     ; No An Skip label 
000019BC  08C7 001F                946      BSET.L  #$1F,D7     ; Set our MSB to equal 1
000019C0                           947   
000019C0                           948  DNOEA    ; No An Ending (aka Single An) Skip Label
000019C0  5207                     949      ADD.B   #1,D7       ; Add 1 for 0ing balance
000019C2  0887 0008                950      BCLR    #$08,D7     ; Incase we're iterated base FF in A
000019C6  EEBE                     951      ROR.L   D7,D6       ; Rotate our A bits back into view
000019C8  E09E                     952      ROR.L   #8,D6       ; Rotate our D bits back into place
000019CA                           953      ;ROR.L   #1,D6       ; Rotate an extra bit over, to account for the loop
000019CA  1E3C 00FF                954      MOVE.B  #$FF,D7     ; Initilize D7
000019CE                           955  
000019CE                           956  DDNSL    ; Decrement Dn Start Loop  
000019CE  5247                     957      ADDQ    #1,D7       ; Itterate D7
000019D0  E39E                     958      ROL.L   #1,D6       ; Rotate one bit to the right  
000019D2  BE3C 0008                959      CMP.B   #8,D7       ; Check if we've hit D8
000019D6  6700 0060                960      BEQ     ENDEAMOVEMPD ; If we have, break the loop
000019DA  0806 0000                961      BTST    #$00,D6     ; Check the far right bit
000019DE  67EE                     962      BEQ     DDNSL       ; If it isn't 1, continue checking     
000019E0                           963      
000019E0                           964      ; The issue with the below line:
000019E0                           965      ;  We need to skip / if there are no An registers, as we do in INOA
000019E0                           966      ;  We also need to skip / if there are no Dn registers, as we do here
000019E0                           967      ;  However, we need to skip / if there are no An's, but we still need to run
000019E0                           968      ;   the above code to determine the starting Dn, so we use the MSB of D7
000019E0                           969      ;   as a boolean to determine if we had an An
000019E0  0807 001F                970      BTST    #$1F,D7     ; If our MSB is equal to 1, we have no A
000019E4  6600 0008                971      BNE     DNOA2       ; .. So, skip the /
000019E8  12FC 002F                972      MOVE.B  #'/',(A1)+
000019EC  5241                     973      ADDQ    #1,D1
000019EE                           974  DNOA2     ; 2nd No An Skip label 
000019EE  0887 001F                975      BCLR    #$1F,D7     ; If our MSB is set, clear it
000019F2  12FC 0044                976      MOVE.B  #'D',(A1)+
000019F6  0607 0030                977      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
000019FA  12C7                     978      MOVE.B  D7,(A1)+    
000019FC  5441                     979      ADDQ    #2,D1
000019FE                           980      
000019FE  0407 002F                981      SUB.B   #47,D7      ; Balance out our D7 from ASCII conversion
00001A02  E39E                     982      ROL.L   #1,D6       ; Rotate one bit to the right  
00001A04  BE3C 0008                983      CMP.B   #8,D7       ; Check if we've hit A8
00001A08  6700 002E                984      BEQ     ENDEAMOVEMPD  ; If we have, break to the end
00001A0C  0806 0000                985      BTST    #$00,D6     ; Check the far right bit
00001A10  6700 0026                986      BEQ     ENDEAMOVEMPD ; If it is 0, we have no -Dn
00001A14                           987  DDNEL    ; Decrement Dn End Loop  
00001A14  5247                     988      ADDQ    #1,D7       ; Itterate D7
00001A16  E39E                     989      ROL.L   #1,D6       ; Rotate one bit to the right  
00001A18  BE3C 0008                990      CMP.B   #8,D7       ; Check if we've hit A8
00001A1C  6700 0008                991      BEQ     DNENLE      ; If we have, break the loop
00001A20  0806 0000                992      BTST    #$00,D6     ; Check the far right bit
00001A24  66EE                     993      BNE     DDNEL       ; If it isn't 0, continue checking    
00001A26                           994  DNENLE
00001A26  5347                     995      SUBQ    #1,D7
00001A28                           996      
00001A28  12FC 002D                997      MOVE.B  #'-',(A1)+
00001A2C  12FC 0044                998      MOVE.B  #'D',(A1)+
00001A30                           999  
00001A30  0607 0030               1000      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
00001A34  12C7                    1001      MOVE.B  D7,(A1)+
00001A36  5641                    1002      ADDQ    #3,D1 
00001A38                          1003      ; If no Dn, skip to the end
00001A38                          1004  ENDEAMOVEMPD
00001A38  4E75                    1005      RTS
00001A3A                          1006  
00001A3A                          1007  
00001A3A                          1008  ; If the EA is unknown
00001A3A                          1009  EAUNKN
00001A3A  12FC 003C               1010      MOVE.B  #'<',(A1)+  ; We did this byte-by-byte in case A1 is at an odd register
00001A3E  12FC 0045               1011      MOVE.B  #'E',(A1)+
00001A42  12FC 0041               1012      MOVE.B  #'A',(A1)+
00001A46  12FC 003E               1013      MOVE.B  #'>',(A1)+
00001A4A  5841                    1014      ADDQ    #4,D1
00001A4C  4E75                    1015      RTS
00001A4E                          1016  
00001A4E                          1017  
00001A4E                          1018  
00001A4E                          1019  
00001A4E                          1020  
00001A4E                          1021  
00001A4E                          1022  -------------------- end include --------------------
00001A4E                          1023      
00001A4E  FFFF FFFF               1024      SIMHALT             ; halt simulator
00001A52                          1025  
00001A52                          1026  * Put variables and constants here
00001A52                          1027  
00001A52                          1028      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDADDA             177A
ADDI                1426
ADDI8               143A
ADDIB               1466
ADDIL               14AE
ADDIW               148A
AND                 16AE
ANDBDN              1742
ANDBEA              16F6
ANDDN               174C
ANDEA               1700
ANDLDN              172E
ANDLEA              16E2
ANDWDN              1738
ANDWEA              16EC
ASLSRO              177C
BAD_EVEN            10CE
BAD_LENGTH          10A2
BCC                 165A
CHECK31             104E
CLR                 1598
CMP                 1662
CNRJML              1530
COUNTER             136A
CR                  D
DANEL               1990
DANELE              19A2
DANSL               195C
DDNEL               1A14
DDNSL               19CE
DIVU                165E
DNENLE              1A26
DNOA                19BC
DNOA2               19EE
DNOEA               19C0
EAAN                1810
EAANI               181E
EAAPOST             1834
EAAPRE              184E
EADN                1802
EAGETDSTEA          17CE
EAGETSRCEA          1796
EAMOVEMPOSTI        1868
EAMOVEMPRED         1952
EAUNKN              1A3A
ENDEAMOVEMPD        1A38
ENDEAMOVEMPI        1950
ENDINGADDRESS       1366
ENDLOOP             110C
ENTERCHECK          105E
ENTERPROMPT         136A
FAIL_INPUT          131C
HEXEND              129F
HEXSTART            1249
IANEL               18A6
IANELE              18B8
IANSL               1872
IDNEL               192C
IDNSL               18E6
INENLE              193E
INOA                18D2
INOA2               1906
INOEA               18D6
INTROMSG            122C
IOASCIITOHEX        10E2
IOASCIITOHEX2       113E
IODIGIT             11F0
IODONE              1216
IOHEXTOASCII        11DC
IOINTRO             1000
IOLOOP              1012
IOORTAG             10F4
IOORTAG2            1150
IOSTRINGLOC         100
JSR                 15C2
LEA                 164E
LENGTH_CHECK        108A
LF                  A
MOVEB               14D2
MOVEL               14F2
MOVEM               15CE
MOVEML              15F4
MOVEMOP             15FA
MOVEMPOSTI          1632
MOVEMPRED           1616
MOVEMW              15EA
MOVEOP              1502
MOVEQ               165C
MOVEW               14E2
MULS                1676
MULSAND             1664
NOP                 159A
OPGETCODE           13AE
OUTPUTOPCODE        1168
OUTRO               1312
RES                 12F4
RTS                 15AE
SPC                 1302
START               1000
STARTADDRESS        1362
SUB                 1660
TEST_ODD            10B2
UNKEA               1308
UNKNOWN             177E
