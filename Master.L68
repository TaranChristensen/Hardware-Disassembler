00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 3/13/2016 9:31:16 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Master
00000000                             3  * Written by : Circles
00000000                             4  * Date       : ##/##/16
00000000                             5  * Description: Project Master File
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11      INCLUDE "IO.X68"        ; Handles our input and output, as well as which address to refer to
00001000  47F9 000017BE             12                  LEA     COUNTER,A3         initialize the COUNTER variable
00001006  26BC 00000000             13                  MOVE.L  #0,(A3)            clear the variable
0000100C                            14                  
0000100C                            15  
0000100C  0693 00000016             16  IOINTRO         ADD.L   #$00000016,(A3)    COUNTER++
00001012  43F9 00001264             17                  LEA     IntroMsg,A1        Display the intro
00001018  103C 000E                 18                  MOVE.B  #14, D0
0000101C  4E4F                      19                  TRAP    #15
0000101E                            20                  
0000101E  43F9 00001461             21                  LEA     Intro2,A1        Display the intro
00001024  103C 000E                 22                  MOVE.B  #14, D0
00001028  4E4F                      23                  TRAP    #15
0000102A                            24  
0000102A  43F9 00001632             25  IOLOOP          LEA     HexStart,A1        Display the prompt and loop it
00001030  103C 000E                 26                  MOVE.B  #14,D0          
00001034  4E4F                      27                  TRAP    #15   
00001036  5493                      28                  ADD.L   #$00000002,(A3)    COUNTER++ COUNTER++
00001038                            29  
00001038                            30  
00001038  43F9 00000100             31                  LEA     IOStringLoc,A1     Store the string of our user input at StartAddress,A1 
0000103E  103C 0002                 32                  MOVE.B  #2,D0              uses Trap #15, Task 2
00001042  4E4F                      33                  TRAP    #15              
00001044                            34          
00001044  4284                      35                  CLR.L   D4                 Ensure our counter (D4) is 0 
00001046                            36  
00001046  4EB9 00001088             37                  JSR     LENGTH_CHECK 
0000104C  4282                      38                  CLR.L   D2  
0000104E  BA3C 0001                 39                  CMP.B   #1,D5              if 1 then it passed the tests         
00001052                            40                  
00001052  6700 00A0                 41                  BEQ     IOASCIItoHEX
00001056  60D2                      42                  BRA     IOLOOP
00001058                            43                  
00001058  0C93 0000001F             44  CHECK31         CMP.L   #$0000001F,(A3)    compare the counter to 29
0000105E  6E00 0004                 45                  BGT     ENTERCHECK         counter is at at least 30
00001062  4E75                      46                  RTS                        counter is still low
00001064                            47  
00001064  4280                      48  ENTERCHECK      CLR.L   D0
00001066  43F9 000016F3             49                  LEA     ENTERPROMPT,A1     display the enter prompt
0000106C  103C 000E                 50                  MOVE.B  #14,D0
00001070  4E4F                      51                  TRAP    #15
00001072                            52                  
00001072  227C 00002000             53                  MOVE.L  #$2000,A1  
00001078                            54  
00001078  103C 0002                 55                  MOVE.B  #2,D0              wait for the user to hit enter
0000107C  4E4F                      56                  TRAP    #15
0000107E                            57                  
0000107E  26BC 00000000             58                  MOVE.L  #0,(A3)            clear the counter
00001084  5293                      59                  ADD.L   #$00000001,(A3)    COUNTER++
00001086                            60               
00001086  4E75                      61                  RTS
00001088                            62                  
00001088  4285                      63  LENGTH_CHECK    CLR.L   D5                 store the result of the test
0000108A  7C00                      64                  MOVEQ   #$0,D6             make D6 0
0000108C  B206                      65                  CMP.B   D6,D1              see if null
0000108E  6700 0010                 66                  BEQ     BAD_LENGTH         if null then branch to bad input
00001092  0C41 0008                 67                  CMPI    #$8,D1             see if it is more than 8 characters long
00001096  6E00 0008                 68                  BGT     BAD_LENGTH         if more than 8 branch to bad input
0000109A  1A3C 0001                 69                  MOVE.B  #$1,D5             passed the length checks so move 1
0000109E  4E75                      70                  RTS                        go back
000010A0                            71                  
000010A0  7A00                      72  BAD_LENGTH      MOVEQ   #$0,D5             did not pass the test
000010A2  43F9 000016AD             73                  LEA     FAIL_INPUT,A1      load bad input message
000010A8  103C 000E                 74                  MOVE.B  #14,D0          
000010AC  4E4F                      75                  TRAP    #15 
000010AE  5293                      76                  ADD.L   #$00000001,(A3)    COUNTER++
000010B0  4E75                      77                  RTS                        go back
000010B2                            78                  
000010B2  43F9 00001735             79  STARTLESSTHNEND LEA     STARTGTEND,A1      load the error 
000010B8  103C 000E                 80                  MOVE.B  #14,D0
000010BC  4E4F                      81                  TRAP    #15
000010BE  5293                      82                  ADD.L   #$00000001,(A3)    COUNTER++
000010C0  6000 FF68                 83                  BRA     IOLOOP             go back to the start
000010C4                            84  
000010C4                            85  
000010C4  4286                      86  TEST_ODD        CLR.L   D6           
000010C6  4285                      87                  CLR.L   D5
000010C8  7A02                      88                  MOVE.L  #$00000002,D5      divide by 2 to see remainder
000010CA  3C02                      89                  MOVE.W  D2,D6              create a copy of the input in D6
000010CC  8CC5                      90                  DIVU    D5,D6              divide the hex number by 2
000010CE                            91                  
000010CE  4846                      92                  SWAP    D6                 put the remainder on the far right
000010D0                            93                  
000010D0  BC3C 0001                 94                  CMP.B   #1,D6              see if the remainder is one
000010D4  6700 0008                 95                  BEQ     BAD_EVEN           branch to bad even
000010D8                            96              
000010D8  4286                      97                  CLR.L   D6
000010DA  4285                      98                  CLR.L   D5
000010DC                            99   
000010DC  4E75                     100                  RTS       
000010DE                           101                  
000010DE  4285                     102  BAD_EVEN        CLR.L   D5
000010E0  4286                     103                  CLR.L   D6
000010E2  43F9 000016AD            104                  LEA     FAIL_INPUT,A1      load bad input message  
000010E8  103C 000E                105                  MOVE.B  #14,D0          
000010EC  4E4F                     106                  TRAP    #15 
000010EE  5293                     107                  ADD.L   #$00000001,(A3)    COUNTER++
000010F0  6000 FF38                108                  BRA     IOLOOP             go back to the beginning
000010F4                           109                  
000010F4                           110  
000010F4  5244                     111  IOASCIItoHEX    ADDQ    #1,D4
000010F6  E98A                     112                  LSL.L   #4,D2              Scoot D2 a nybble
000010F8  1619                     113                  MOVE.B  (A1)+,D3           Move a Byte from A1's address to D3
000010FA  0403 0030                114                  SUB.B   #48,D3             Sub 48 to turn ASCII 0 into binary 0
000010FE  B63C 0009                115                  CMP.B   #9,D3              If our number is greater than 9..
00001102  6F02                     116                  BLE.S   IOORTAG            .. it must be a character; A-F: 
00001104  5F03                     117                  SUB.B   #7,D3              Sub 7 to turn A into 10
00001106  8403                     118  IOORTAG         OR.B    D3,D2              Store our nybble into D2
00001108  B204                     119                  CMP.B   D4,D1              See if we've read all the characters
0000110A  66E8                     120                  BNE.S   IOASCIItoHEX       Continue if we haven't
0000110C                           121              
0000110C                           122              
0000110C  23FC 00000000 000017B6   123                  MOVE.L  #0,StartAddress
00001116  23C2 000017B6            124                  MOVE.L  D2,StartAddress    Store our StartAddress
0000111C                           125                  
0000111C  4EB8 10C4                126                  JSR     TEST_ODD           test if the address is odd
00001120                           127                  
00001120  4281                     128                  CLR.L   D1
00001122  4282                     129                  CLR.L   D2
00001124                           130  
00001124                           131  
00001124  43F9 0000164F            132  ENDLOOP         LEA     HexEnd,A1          load the ending address prompt
0000112A  103C 000E                133                  MOVE.B  #14,D0
0000112E  4E4F                     134                  TRAP    #15  
00001130  5493                     135                  ADD.L   #$00000002,(A3)
00001132                           136                  
00001132  43F9 00000100            137                  LEA     IOStringLoc,A1     Store the string of our user input at StartAddress,A1 
00001138  103C 0002                138                  MOVE.B  #2,D0              uses Trap #15, Task 2
0000113C  4E4F                     139                  TRAP    #15              
0000113E                           140          
0000113E  4284                     141                  CLR.L   D4                 Ensure our counter (D4) is 0 
00001140                           142  
00001140  4EB8 1088                143                  JSR     LENGTH_CHECK       check to make sure the length is ok
00001144  BA3C 0001                144                  CMP.B   #1,D5              if 1 then it passed the tests         
00001148                           145  
00001148  6700 0004                146                  BEQ     IOASCIItoHEX2      convert to hex
0000114C  60D6                     147                  BRA     ENDLOOP
0000114E                           148                  
0000114E  5244                     149  IOASCIItoHEX2   ADDQ    #1,D4
00001150  E98A                     150                  LSL.L   #4,D2              Scoot D2 a nybble
00001152  1619                     151                  MOVE.B  (A1)+,D3           Move a Byte from A1's address to D3
00001154  0403 0030                152                  SUB.B   #48,D3             Sub 48 to turn ASCII 0 into binary 0
00001158  B63C 0009                153                  CMP.B   #9,D3              If our number is greater than 9..
0000115C  6F02                     154                  BLE.S   IOORTAG2           .. it must be a character; A-F: 
0000115E  5F03                     155                  SUB.B   #7,D3              Sub 7 to turn A into 10
00001160  8403                     156  IOORTAG2        OR.B    D3,D2              Store our nybble into D2
00001162  B204                     157                  CMP.B   D4,D1              See if we've read all the characters
00001164  66E8                     158                  BNE.S   IOASCIItoHEX2      Continue if we haven't
00001166                           159              
00001166                           160    
00001166  23FC 00000000 000017BA   161                  MOVE.L  #0,EndingAddress
00001170  23C2 000017BA            162                  MOVE.L  D2,EndingAddress   Store our EndingAddress
00001176                           163                  
00001176  4EB8 10C4                164                  JSR     TEST_ODD           tezt if the ending address is odd
0000117A                           165                  
0000117A  2479 000017B6            166                  MOVE.L  StartAddress,A2    Push our start address into A2
00001180                           167                  
00001180  B5F9 000017BA            168                  CMP.L   EndingAddress,A2   compare the ending address with the startingaddress
00001186  6E00 FF2A                169                  BGT     STARTLESSTHNEND    branch if the starting is greater than the ending
0000118A                           170                  
0000118A  4281                     171                  CLR.L   D1
0000118C                           172                  
0000118C  2479 000017B6            173                  MOVE.L  StartAddress,A2    Push our start address into A2 
00001192                           174                  
00001192                           175  
00001192  23FC 00000000 00000100   176  OUTPUTOPCODE    MOVE.L  #0,IOStringLoc     ********** Testing purposes ********** 
0000119C  4281                     177                  CLR.L   D1
0000119E                           178          
0000119E                           179  
0000119E  43F9 00000100            180                  LEA     IOStringLoc,A1     Load our IOStringLoc into A1 for string contruction purposes
000011A4                           181          
000011A4  2C0A                     182                  MOVE.L  A2,D6
000011A6  4244                     183                  CLR     D4
000011A8  4846                     184                  SWAP    D6
000011AA  4EB9 00002664            185                  JSR     EAHEXtoASCII
000011B0  4244                     186                  CLR     D4
000011B2  4846                     187                  SWAP    D6
000011B4  4EB9 00002664            188                  JSR     EAHEXtoASCII
000011BA  22FC 20202020            189                  MOVE.L  #'    ',(A1)+      Add a spacer into our IOStringLoc
000011C0  32FC 2020                190                  MOVE.W  #'  ',(A1)+      Add a spacer into our IOStringLoc
000011C4  5C41                     191                  ADDQ    #6,D1              We added 4 bytes, aka 4 spaces
000011C6                           192          
000011C6  4EB9 000017C2            193                  JSR OPGETCODE              Get the OpCode pointed at by A2, it's string stored in IOStringLoc
000011CC                           194                  
000011CC  43F9 00000100            195                  LEA     IOStringLoc,A1     Now that we've populated the string, load it's beginning
000011D2  103C 0001                196                  MOVE.B  #1,D0              Trap task 1 prints a string at A1 with #D1 bytes.
000011D6  4E4F                     197                  TRAP    #15           
000011D8                           198          
000011D8  43F9 0000166B            199                  LEA     SPC,A1             Puts the space before the opCode
000011DE  103C 000D                200                  MOVE.B  #13,D0
000011E2  4E4F                     201                  TRAP    #15
000011E4                           202                  
000011E4  5293                     203                  ADD.L   #$00000001,(A3)    COUNTER++
000011E6  4EB8 1058                204                  JSR     CHECK31
000011EA                           205                  
000011EA  B5F9 000017BA            206                  CMP.L   EndingAddress,A2   compare the current address with the ending address
000011F0  6DA0                     207                  BLT     OUTPUTOPCODE       if the current is less than the ending keep looping
000011F2                           208  
000011F2                           209  
000011F2                           210                  ; The following outputs the input, converting what we've saved in HEX to ASCII
000011F2                           211                  ; We won't need this in the final version, but the below code should be handy
000011F2                           212                  ;  for print out EA values
000011F2  2439 000017B6            213                  MOVE.L  StartAddress,D2    Ensure our address is actually at D2
000011F8  7208                     214                  MOVEQ   #8,D1              There are 8 characters in the hex of our address
000011FA  4284                     215                  CLR.L   D4                 Ensure our counter (D4) is 0
000011FC  43F9 00000100            216                  LEA     IOStringLoc,A1     Load our IO String location, to store our output at  
00001202                           217  
00001202                           218          
00001202  5244                     219  IOHEXtoASCII    ADDQ    #1,D4
00001204  E99A                     220                  ROL.L   #4,D2              Get the left-most nyblle to the front..
00001206  1602                     221                  MOVE.B  D2,D3              .. Put the front-most byte into D3    
00001208  C63C 000F                222                  AND.B   #$0F,D3            Distill D3 down to the original left-most nybble
0000120C  B63C 0009                223                  CMP.B   #9,D3              See if our number is greater than 9..
00001210  6F00 0004                224                  BLE     IODIGIT            If it is 9 or less, it's a digit..
00001214  5E03                     225                  ADD.B   #7,D3              Otherwise it is a digit, and needs an additional 7
00001216  0603 0030                226  IODIGIT         ADD.B   #48,D3             We now how the nybble's ASCII code
0000121A  12C3                     227                  MOVE.B  D3,(A1)+           Move the ASCII code into the output string at A1
0000121C  B204                     228                  CMP.B   D4,D1              See if we've read all the characters
0000121E  66E2                     229                  BNE.S   IOHEXtoASCII       Continue if we haven't
00001220                           230  
00001220  43F9 0000177F            231                  LEA     CONTINUE,A1        ask if the user wnats to exit
00001226  103C 000E                232                  MOVE.B  #14,D0
0000122A  4E4F                     233                  TRAP    #15
0000122C                           234                  
0000122C  123C 0000                235                  MOVE.B  #0,D1              clear D1
00001230  103C 0005                236                  MOVE.B  #5,D0              keybaord echo trap task
00001234  4E4F                     237                  TRAP    #15
00001236                           238                  
00001236  43F9 000017B2            239                  LEA     SPACER,A1          println
0000123C  103C 000E                240                  MOVE.B  #14,D0
00001240  4E4F                     241                  TRAP    #15
00001242                           242                  
00001242  B23C 0071                243                  CMP.B   #$71,D1            compare with lowercase q
00001246  6700 0006                244                  BEQ     IODONE             if equal then go to the end
0000124A                           245  
0000124A  6000 FDDE                246                  BRA     IOLOOP             not equal so go to the beginning
0000124E                           247          
0000124E                           248        
0000124E  43F9 0000167B            249  IODONE          LEA     OUTRO,A1           Display the ending message 
00001254  103C 000E                250                  MOVE.B  #14,D0
00001258  4E4F                     251                  TRAP    #15
0000125A  103C 0009                252                  MOVE.B  #9,D0
0000125E  4E4F                     253                  TRAP    #15                Halt Simulator
00001260                           254          
00001260  FFFF FFFF                255                  SIMHALT
00001264                           256          
00001264  =0000000D                257  CR              EQU     $0D         
00001264  =0000000A                258  LF              EQU     $0A 
00001264  =00000100                259  IOStringLoc     EQU     $0100              This is where we will store the string of the user input, and other strings
00001264                           260  
00001264                           261  
00001264= 20 20 20 20 20 20 ...    262  IntroMsg        DC.B '                              -----------',CR,LF
0000128F= 20 20 20 20 20 20 ...    263                  DC.B '                            /             \',CR,LF
000012BC= 20 20 20 20 20 20 ...    264                  DC.B '                           /     TEAM      \',CR,LF
000012EA= 20 20 20 20 20 20 ...    265                  DC.B '                          /                 \',CR,LF
00001319= 20 20 20 20 20 20 ...    266                  DC.B '                         |                   |',CR,LF
00001349= 20 20 20 20 20 20 ...    267                  DC.B '                         |      CIRCLES      |',CR,LF
00001379= 20 20 20 20 20 20 ...    268                  DC.B '                         |                   |',CR,LF
000013A9= 20 20 20 20 20 20 ...    269                  DC.B '                          \                 /',CR,LF
000013D8= 20 20 20 20 20 20 ...    270                  DC.B '                           \ DISSASSEMBLER /',CR,LF
00001406= 20 20 20 20 20 20 ...    271                  DC.B '                            \             /',CR,LF
00001433= 20 20 20 20 20 20 ...    272                  DC.B '                              -----------',CR,LF,CR,LF,0
00001461                           273                  
00001461= 54 68 69 73 20 70 ...    274  Intro2          DC.B    'This program will dissassemble machine code into readable code',CR,LF
000014A1= 49 74 20 77 69 6C ...    275                  DC.B    'It will ask for a starting and ending address',CR,LF
000014D0= 50 6C 65 61 73 65 ...    276                  DC.B    'Please type both in hex, with a length of 8 or less',CR,LF
00001505= 41 6E 64 20 6E 6F ...    277                  DC.B    'And not ending in an odd number',CR,LF
00001526= 49 66 20 61 6E 20 ...    278                  DC.B    'If an address is input that does not meet the criteria',CR,LF
0000155E= 54 68 65 20 70 72 ...    279                  DC.B    'The program will start over at the starting address prompt',CR,LF
0000159A= 57 68 65 6E 20 74 ...    280                  DC.B    'When the program has reached the ending address',CR,LF
000015CB= 49 74 20 77 69 6C ...    281                  DC.B    'It will ask if you want to try again with different addresses',CR,LF
0000160A= 57 68 65 6E 20 74 ...    282                  DC.B    'When this happens press "q" to exit.',CR,LF,CR,0
00001632                           283                  
00001632= 0D 0A 45 6E 74 65 ...    284  HexStart        DC.B    CR,LF,'Enter a starting address: ',0 Prompt for the user
0000164F= 0D 0A 45 6E 74 65 ...    285  HexEnd          DC.B    CR,LF,'Enter an ending address: ',0 Prompt for the user
0000166B= 20 20 20 20 20 00        286  SPC             DC.B    '     ',0                                tab
00001671= 3C 45 41 3E 2C 3C ...    287  UnkEA           DC.B    '<EA>,<EA>',0                            Interim message for unkown EAs.
0000167B= 0D 0A 54 68 61 6E ...    288  OUTRO           DC.B    CR,LF,'Thank you for using Team Circles Dissassembler!',0                            Outro message
000016AD= 49 20 61 6D 20 73 ...    289  FAIL_INPUT      DC.B    'I am sorry, but you typed an address that did not meet the criteria',CR,LF,0 
000016F3= 54 68 65 20 73 63 ...    290  ENTERPROMPT     DC.B    'The screen limit has been reached, please press enter to continue',0
00001735= 54 68 65 20 65 6E ...    291  STARTGTEND      DC.B    'The ending address was less than the starting address, please try again',CR,LF,0
0000177F= 0D 0A 50 72 65 73 ...    292  CONTINUE        DC.B    CR,LF,'Press "q" to quit or anything else to continue: ',0 ask to exit
000017B2= 0D 0A 00                 293  SPACER          DC.B    CR,LF,0 put the new line after the keyboard input
000017B5                           294  
000017B5                           295  
000017B6                           296  StartAddress    DS.L    1
000017BA                           297  EndingAddress   DS.L    1
000017BE                           298  COUNTER         DS.L    1 keep track of the lines on the screen
000017C2                           299  
000017C2                           300  
000017C2                           301  
000017C2                           302  
000017C2                           303  
000017C2                           304  
000017C2                           305  
000017C2                           306  
000017C2                           307  
000017C2                           308  
000017C2                           309  
000017C2                           310  
000017C2                           311  
000017C2                           312  
000017C2                           313  
000017C2                           314  
000017C2                           315  
000017C2                           316  
000017C2                           317  
000017C2                           318  
000017C2                           319  
000017C2                           320  
000017C2                           321  
000017C2                           322  
000017C2                           323  -------------------- end include --------------------
000017C2                           324      INCLUDE "OpCode.X68"    ; Handles determining OpCodes
000017C2                           325  
000017C2                           326  
000017C2                           327  ; Here we assume that A2 contains the address pointing to our OpCode, and
000017C2                           328  ;  we assume that A1 contains the address pointing to our IOStringLoc
000017C2  3A1A                     329  OPGETCODE   MOVE.W  (A2)+,D5    ; Push our OpCode into D5
000017C4  2C05                     330              MOVE.L  D5,D6       ; Also store the OpCode in D6
000017C6  E09E                     331              ROR.L   #8,D6       ; Rotate our OpCode to right-most nybble
000017C8  E89E                     332              ROR.L   #4,D6       ; 
000017CA  0206 000F                333              ANDI.B  #$0F,D6     ; Isolate our opcode nybble
000017CE  BC3C 0000                334              CMP.B   #$00,D6
000017D2  6700 0066                335              BEQ     ADDI        ; ADDI 
000017D6  BC3C 0001                336              CMP.B   #$01,D6     
000017DA  6700 0194                337              BEQ     MOVE        ; MOVE.B
000017DE  BC3C 0003                338              CMP.B   #$03,D6     
000017E2  6700 018C                339              BEQ     MOVE        ; MOVE.W
000017E6  BC3C 0002                340              CMP.B   #$02,D6
000017EA  6700 0184                341              BEQ     MOVE        ; MOVE.L
000017EE  BC3C 0004                342              CMP.B   #$04,D6
000017F2  6700 0232                343              BEQ     CNRJML      ; CLR or NOP or RTS or JSR or MOVEM or LEA
000017F6  BC3C 0006                344              CMP.B   #$06,D6
000017FA  6700 0522                345              BEQ     Bcc         ; Bcc (BCC, BGT, BLE) 
000017FE  BC3C 0007                346              CMP.B   #$07,D6
00001802  6700 0626                347              BEQ     MOVEQ       ; MOVEQ 
00001806  BC3C 0008                348              CMP.B   #$08,D6
0000180A  6700 0670                349              BEQ     DIVU        ; DIVU
0000180E  BC3C 0009                350              CMP.B   #$09,D6
00001812  6700 06BA                351              BEQ     SUB         ; SUB
00001816  BC3C 000B                352              CMP.B   #$0B,D6
0000181A  6700 0798                353              BEQ     CMP         ; CMP 
0000181E  BC3C 000C                354              CMP.B   #$0C,D6
00001822  6700 0834                355              BEQ     MULSAND     ; MULS or AND opcodes
00001826  BC3C 000D                356              CMP.B   #$0D,D6
0000182A  6700 09C8                357              BEQ     ADDADDA     ; ADD or ADDA
0000182E  BC3C 000E                358              CMP.B   #$0E,D6 
00001832  6700 0B10                359              BEQ     ASLSRO      ; ASd (ASR) or LSd (LSL) or ROd (ROL)
00001836  6000 0CAE                360              BRA     UNKNOWN  
0000183A                           361              
0000183A                           362  ;  Here we assume the first left-most 4 bits have been confirmed: 0000
0000183A  2C05                     363  ADDI        MOVE.L  D5,D6               ; Push D5 into D6
0000183C  E09E                     364              ROR.L   #8,D6               ; Rotate left-most middle nybble to the right-most nybble
0000183E  0206 000F                365              ANDI.B  #$0F,D6             ; Isolate opcode nybble
00001842  BC3C 0006                366              CMP.B   #$06,D6             ; If it matches ADDI's left-most middle nybble, branch
00001846  6700 0006                367              BEQ     ADDI8               ; First 8 left-most bits of ADDI confirmed 
0000184A  6000 0C9A                368              BRA     UNKNOWN             ; else unknown                       
0000184E                           369  
0000184E                           370  ;  Here we assume the first left-most 8 bits have been confirmed: 0000 0110            
0000184E                           371  ADDI8                                  ; Two consecutive tests for illegal Src EA Modes
0000184E  2C05                     372              MOVE.L  D5,D6              ; Push D5 into D6 
00001850  0286 0000003F            373              ANDI.L  #$003F,D6          ; Isolate the Src EA bits
00001856  BCBC 0000003C            374              CMP.L   #$003C,D6          ; Compare with illegal EA mode #<data>
0000185C  6700 0C88                375              BEQ     UNKNOWN
00001860                           376              
00001860  E69E                     377              ROR.L   #3,D6              ; Roll 3 bits right
00001862  0286 00000007            378              ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
00001868  BCBC 00000001            379              CMP.L   #$0001, D6         ; Compare with illegal mode An
0000186E  6700 0C76                380              BEQ     UNKNOWN
00001872                           381              *--------------
00001872                           382                                  
00001872  2C05                     383              MOVE.L  D5,D6              ; Push D5 into D6 
00001874  EC8E                     384              LSR.L   #6,D6              ; Shift six bits to the right
00001876  0286 00000003            385              ANDI.L  #$0003,D6          ; Isolate the size bits
0000187C                           386                         
0000187C  BCBC 00000000            387              CMP.L   #$0000,D6          ; See if the size is '00'..
00001882  6700 001A                388              BEQ     ADDIB              ; ..If so, it's ANDI.B
00001886  BCBC 00000001            389              CMP.L   #$0001,D6          ; See if the size is '01'..
0000188C  6700 0054                390              BEQ     ADDIW              ; ..If so, it's ANDI.W
00001890  BCBC 00000002            391              CMP.L   #$0002,D6          ; See if the size is '10'..
00001896  6700 008A                392              BEQ     ADDIL              ; ..If so, it's ANDI.L
0000189A                           393              
0000189A  6000 0C4A                394              BRA     UNKNOWN            ; If it isn't any, then it's Unknown
0000189E                           395  
0000189E  22FC 41444449            396  ADDIB       MOVE.L  #'ADDI',(A1)+
000018A4  32FC 2E42                397              MOVE.W  #'.B',(A1)+
000018A8  22FC 20202020            398              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
000018AE  5041                     399              ADDQ    #8,D1              ; We added 10 bytes, aka 4 spaces 6 characters
000018B0  5441                     400              ADDQ    #2,D1
000018B2                           401              
000018B2  32FC 2324                402              MOVE.W  #'#$',(A1)+
000018B6  5441                     403              ADDQ    #2,D1
000018B8                           404              
000018B8  4246                     405              CLR     D6
000018BA  4244                     406              CLR     D4
000018BC  3C1A                     407              MOVE.W  (A2)+,D6
000018BE  0246 000F                408              ANDI.W  #$0F,D6
000018C2  4EB9 00002664            409              JSR     EAHEXtoASCII
000018C8                           410                          
000018C8  12FC 002C                411              MOVE.B #',',(A1)+      ; Add a spacer into our IOStringLoc
000018CC  5241                     412              ADDQ    #1,D1              ; We added 4 bytes, aka 4 spaces
000018CE                           413              
000018CE  2C05                     414              MOVE.L  D5,D6              ; Push D5 into D6
000018D0  0286 0000003F            415              ANDI.L  #$003F,D6          ; Isolate the Dst EA bits 
000018D6  103C 0001                416              MOVE.B  #1,D0              ; Push 3 into D0 to indicate bytesize
000018DA  4EB9 0000250A            417              JSR EAGETSRCEA             ; Find and print the code stored in D6 
000018E0                           418              
000018E0  4E75                     419              RTS
000018E2                           420              
000018E2  22FC 41444449            421  ADDIW       MOVE.L  #'ADDI',(A1)+
000018E8  32FC 2E57                422              MOVE.W  #'.W',(A1)+
000018EC  22FC 20202020            423              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
000018F2  5041                     424              ADDQ    #8,D1              ; We added 10 bytes, aka 4 spaces 6 characters
000018F4  5441                     425              ADDQ    #2,D1
000018F6                           426              
000018F6  32FC 2324                427              MOVE.W  #'#$',(A1)+
000018FA  5441                     428              ADDQ    #2,D1
000018FC                           429              
000018FC  4246                     430              CLR     D6
000018FE  4244                     431              CLR     D4
00001900  3C1A                     432              MOVE.W  (A2)+,D6
00001902  4EB9 00002664            433              JSR     EAHEXtoASCII
00001908                           434                          
00001908  12FC 002C                435              MOVE.B  #',',(A1)+      ; Add a spacer into our IOStringLoc
0000190C  5241                     436              ADDQ    #1,D1              ; We added 4 bytes, aka 4 spaces
0000190E                           437              
0000190E  2C05                     438              MOVE.L  D5,D6              ; Push D5 into D6
00001910  0286 0000003F            439              ANDI.L  #$003F,D6          ; Isolate the Dst EA bits 
00001916  103C 0002                440              MOVE.B  #2,D0              ; Push 3 into D0 to indicate wordsize
0000191A  4EB9 0000250A            441              JSR EAGETSRCEA             ; Find and print the code stored in D6 
00001920                           442              
00001920  4E75                     443              RTS
00001922                           444              
00001922  22FC 41444449            445  ADDIL       MOVE.L  #'ADDI',(A1)+
00001928  32FC 2E4C                446              MOVE.W  #'.L',(A1)+
0000192C  22FC 20202020            447              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
00001932  5041                     448              ADDQ    #8,D1              ; We added 10 bytes, aka 4 spaces 6 characters
00001934  5441                     449              ADDQ    #2,D1
00001936                           450              
00001936  32FC 2324                451              MOVE.W  #'#$',(A1)+
0000193A  5441                     452              ADDQ    #2,D1
0000193C                           453              
0000193C  4246                     454              CLR     D6
0000193E  4244                     455              CLR     D4
00001940  2C1A                     456              MOVE.L  (A2)+,D6
00001942  4846                     457              SWAP    D6
00001944  4EB9 00002664            458              JSR     EAHEXtoASCII
0000194A  4244                     459              CLR     D4
0000194C  4246                     460              CLR     D6
0000194E  4846                     461              SWAP    D6
00001950  4EB9 00002664            462              JSR     EAHEXtoASCII
00001956                           463                          
00001956  12FC 002C                464              MOVE.B  #',',(A1)+      ; Add a spacer into our IOStringLoc
0000195A  5241                     465              ADDQ    #1,D1              ; We added 4 bytes, aka 4 spaces
0000195C                           466              
0000195C  2C05                     467              MOVE.L  D5,D6              ; Push D5 into D6
0000195E  0286 0000003F            468              ANDI.L  #$003F,D6          ; Isolate the Dst EA bits 
00001964  103C 0003                469              MOVE.B  #3,D0              ; Push 3 into D0 to indicate longsize
00001968  4EB9 0000250A            470              JSR EAGETSRCEA             ; Find and print the code stored in D6 
0000196E                           471              
0000196E  4E75                     472              RTS
00001970                           473                
00001970                           474  ;  Here we assume the first left-most 4 bits are: 0001, 0011, or 0010
00001970                           475  MOVE                                   ; Two consecutive tests for illegal Dst EA Modes
00001970  2C05                     476              MOVE.L  D5,D6              ; Push D5 into D6
00001972  EC9E                     477              ROR.L   #6,D6              ; Roll 6 bits right 
00001974  0286 0000003F            478              ANDI.L  #$003F,D6          ; Isolate the Dst EA bits
0000197A  BCBC 00000027            479              CMP.L   #$0027, D6         ; Compare with illegal EA mode #<data>
00001980  6700 0B64                480              BEQ     UNKNOWN
00001984                           481              
00001984  0286 00000007            482              ANDI.L  #$0007,D6          ; Isolate the 3 Dst (Mode) bits
0000198A  BCBC 00000001            483              CMP.L   #$0001, D6         ; Compare with illegal mode An
00001990  6700 0B54                484              BEQ     UNKNOWN
00001994                           485              *----------------                   
00001994  2C05                     486              MOVE.L  D5,D6              ; Push D5 into D6 
00001996  EC8E                     487              LSR.L   #6,D6              ; Shift six bits to the right
00001998  EC8E                     488              LSR.L   #6,D6              ; Shift six bits to the right
0000199A  0286 00000003            489              ANDI.L  #$0003,D6          ; Isolate the size bits
000019A0                           490                         
000019A0  BCBC 00000001            491              CMP.L   #$0001,D6          ; See if the size is '01'..
000019A6  6700 001A                492              BEQ     MOVEB              ; ..If so, it's MOVE.B
000019AA  BCBC 00000003            493              CMP.L   #$0003,D6          ; See if the size is '11'..
000019B0  6700 0022                494              BEQ     MOVEW              ; ..If so, it's MOVE.W
000019B4  BCBC 00000002            495              CMP.L   #$0002,D6          ; See if the size is '10'..
000019BA  6700 002A                496              BEQ     MOVEL              ; ..If so, it's MOVE.L
000019BE                           497              
000019BE  6000 0B26                498              BRA     UNKNOWN            ; If it isn't any, then it's Unknown
000019C2                           499              
000019C2                           500  
000019C2                           501  
000019C2  22FC 4D4F5645            502  MOVEB       MOVE.L  #'MOVE',(A1)+
000019C8  32FC 2E42                503              MOVE.W  #'.B',(A1)+
000019CC  5C41                     504              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
000019CE                           505              
000019CE  7001                     506              MOVE.L  #1,D0               ; Put 1 into D0 to indicate it's a bytesize
000019D0                           507              
000019D0  6000 0026                508              BRA MOVEOP
000019D4                           509              
000019D4  22FC 4D4F5645            510  MOVEW       MOVE.L  #'MOVE',(A1)+
000019DA  32FC 2E57                511              MOVE.W  #'.W',(A1)+
000019DE  5C41                     512              ADDQ    #6,D1               ; We added 6 new characters to our IOStringLoc 
000019E0                           513              
000019E0  7002                     514              MOVE.L  #2,D0               ; Put 2 into D0 to indicate it's a wordsize
000019E2                           515              
000019E2  6000 0014                516              BRA MOVEOP
000019E6                           517              
000019E6  22FC 4D4F5645            518  MOVEL       MOVE.L  #'MOVE',(A1)+
000019EC  32FC 2E4C                519              MOVE.W  #'.L',(A1)+
000019F0  5C41                     520              ADDQ    #6,D1               ; We added 6 new characters to our IOStringLoc 
000019F2                           521              
000019F2  7003                     522              MOVE.L  #3,D0               ; Put 3 into D0 to indicate it's a longsize
000019F4                           523              
000019F4  6000 0002                524              BRA MOVEOP
000019F8                           525              
000019F8  22FC 20202020            526  MOVEOP      MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
000019FE  5841                     527              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
00001A00                           528              
00001A00  2C05                     529              MOVE.L  D5,D6               ; Push D5 into D6
00001A02  0286 0000003F            530              ANDI.L  #$003F,D6           ; Isolate the Src EA bits 
00001A08  4EB9 0000250A            531              JSR EAGETSRCEA              ; Find and print the code stored in D6
00001A0E                           532              
00001A0E  12FC 002C                533              MOVE.B  #',',(A1)+
00001A12  5241                     534              ADDQ    #1,D1
00001A14                           535              
00001A14  2C05                     536              MOVE.L  D5,D6               ; Push D5 into D6
00001A16  EC8E                     537              LSR.L   #6,D6               ; Shift six bits to the right
00001A18  0286 0000003F            538              ANDI.L  #$003F,D6           ; Isolate the Dst EA bits
00001A1E  4EB9 0000254A            539              JSR EAGETDSTEA
00001A24  4E75                     540              RTS
00001A26                           541              
00001A26                           542  ; This label determines if the code is either CLR or NOP or RTS or JSR or MOVEM or LEA
00001A26                           543  ; Here we assume that the first left-most four bits equal 0100            
00001A26                           544  CNRJML      
00001A26  2C05                     545              MOVE.L  D5,D6              ; Push D5 into D6 (Copy OPcode over isolated nybble)
00001A28                           546              
00001A28                           547              *NOP & RTS's machine code is uniquely hardcoded, check first
00001A28  BCBC 00004E71            548              CMP.L   #$4E71,D6          ; See if the OPcode matches NOP's hardcode
00001A2E  6700 010A                549              BEQ     NOP
00001A32  BCBC 00004E75            550              CMP.L   #$4E75,D6          ; See if the OPcode matches RTS's hardcode
00001A38  6700 011A                551              BEQ     RTS
00001A3C                           552                                         ; CLR's middle most left nybble is unique (0010)
00001A3C  E09E                     553              ROR.L   #8,D6              ; Rotate our OpCode to right-most nybble
00001A3E  0206 000F                554              ANDI.B  #$0F,D6            ; Isolate our opcode nybble
00001A42  BC3C 0002                555              CMP.B   #$02,D6            ; See if matches nybble
00001A46  6700 0042                556              BEQ     CLR               
00001A4A                           557              
00001A4A                           558                                         ; LEA's left-most 10 bits are 0100 --- (111)
00001A4A  2C05                     559              MOVE.L  D5,D6              ; Push D5 into D6
00001A4C  EC8E                     560              LSR.L   #6,D6              ; Shift 6 bits to the right 
00001A4E  0286 00000007            561              ANDI.L  #$0007,D6          ; Isolate 3 right-most bits
00001A54  BCBC 00000007            562              CMP.L   #$0007,D6          ; See if matches 111
00001A5A  6700 023E                563              BEQ     LEA                ; If equals, branch to LEA     
00001A5E                           564              
00001A5E                           565                                         ; JSR's left-most 10 bits are 0100 (111 010)
00001A5E  2C05                     566              MOVE.L  D5,D6              ; Push D5 into D6
00001A60  EC8E                     567              LSR.L   #6,D6              ; Shift 6 bits to the right
00001A62  0286 0000003F            568              ANDI.L  #$003F,D6          ; Isolate 6 right-most bit
00001A68  BCBC 0000003A            569              CMP.L   #$003A,D6          ; See if matches 11 1010
00001A6E  6700 00FE                570              BEQ     JSR                ; If equals, branch JSR
00001A72                           571                 
00001A72                           572                                         ; MOVEM's left-most 9 bits are 0100 1- (001)
00001A72  2C05                     573              MOVE.L  D5,D6              ; Push D5 into D6
00001A74  EE8E                     574              LSR.L   #7,D6              ; Shift 7 bits to the right
00001A76  0286 00000007            575              ANDI.L  #$0007,D6          ; Isolate 3 right-most bit
00001A7C  BCBC 00000001            576              CMP.L   #$0001,D6          ; See if matches 001
00001A82  6700 0156                577              BEQ     MOVEM              ; If equals, branch MOVEM
00001A86                           578        
00001A86  6000 0A5E                579              BRA     UNKNOWN            ; If it doesnt any match, then it's Unknown
00001A8A                           580  
00001A8A                           581  
00001A8A                           582  ;  Here we assume the first left-most 8 bits have been confirmed: 0100 0010
00001A8A                           583  CLR                                    ; Two consecutive tests for illegal Src EA Modes
00001A8A  2C05                     584              MOVE.L  D5,D6              ; Push D5 into D6 
00001A8C  0286 0000003F            585              ANDI.L  #$003F,D6          ; Isolate the Src EA bits
00001A92  BCBC 0000003C            586              CMP.L   #$003C, D6         ; Compare with illegal EA mode #<data>
00001A98  6700 0A4C                587              BEQ     UNKNOWN
00001A9C                           588              
00001A9C  E69E                     589              ROR.L   #3,D6              ; Roll 3 bits right
00001A9E  0286 00000007            590              ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
00001AA4  BCBC 00000001            591              CMP.L   #$0001,D6          ; Compare with illegal mode An
00001AAA  6700 0A3A                592              BEQ     UNKNOWN
00001AAE                           593              *----------------
00001AAE                           594              
00001AAE  2C05                     595              MOVE.L  D5,D6              ; Push D5 into D6
00001AB0  EC8E                     596              LSR.L   #6,D6              ; Shift six bits to the right
00001AB2  0286 00000003            597              ANDI.L  #$0003,D6          ; Isolate the two size bits
00001AB8                           598                         
00001AB8  BCBC 00000000            599              CMP.L   #$0000,D6          ; See if the size is '00'..
00001ABE  6700 001A                600              BEQ     CLRB               ; ..If so, it's CLR.B
00001AC2  BCBC 00000001            601              CMP.L   #$0001,D6          ; See if the size is '01'..
00001AC8  6700 0026                602              BEQ     CLRW               ; ..If so, it's CLR.W
00001ACC  BCBC 00000002            603              CMP.L   #$0002,D6          ; See if the size is '10'..
00001AD2  6700 0032                604              BEQ     CLRL               ; ..If so, it's CLR.L
00001AD6                           605              
00001AD6  6000 0A0E                606              BRA     UNKNOWN            ; If it isn't any, then it's Unknown
00001ADA                           607              
00001ADA  32FC 434C                608  CLRB        MOVE.W  #'CL',(A1)+
00001ADE  12FC 0052                609              MOVE.B  #'R',(A1)+
00001AE2  12FC 002E                610              MOVE.B  #'.',(A1)+
00001AE6  12FC 0042                611              MOVE.B  #'B',(A1)+
00001AEA  5A41                     612              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
00001AEC  6000 002E                613              BRA     CLROP
00001AF0                           614              
00001AF0  32FC 434C                615  CLRW        MOVE.W  #'CL',(A1)+
00001AF4  12FC 0052                616              MOVE.B  #'R',(A1)+
00001AF8  12FC 002E                617              MOVE.B  #'.',(A1)+
00001AFC  12FC 0057                618              MOVE.B  #'W',(A1)+
00001B00  5A41                     619              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
00001B02  6000 0018                620              BRA     CLROP
00001B06                           621  
00001B06  32FC 434C                622  CLRL        MOVE.W  #'CL',(A1)+
00001B0A  12FC 0052                623              MOVE.B  #'R',(A1)+
00001B0E  12FC 002E                624              MOVE.B  #'.',(A1)+
00001B12  12FC 004C                625              MOVE.B  #'L',(A1)+
00001B16  5A41                     626              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
00001B18  6000 0002                627              BRA     CLROP
00001B1C                           628              
00001B1C  12FC 0020                629  CLROP       MOVE.B  #' ',(A1)+
00001B20  32FC 2020                630              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
00001B24  32FC 2020                631              MOVE.W  #'  ',(A1)+
00001B28  5A41                     632              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces
00001B2A                           633              
00001B2A  2C05                     634              MOVE.L  D5,D6              ; Push D5 into D6
00001B2C  0286 0000003F            635              ANDI.L  #$003F,D6          ; Isolate the Src EA bits 
00001B32  4EB9 0000250A            636              JSR EAGETSRCEA             ; Find and print the code stored in D6
00001B38                           637  
00001B38  4E75                     638              RTS
00001B3A                           639              
00001B3A                           640  ;  Here we assume that all 16 bits have been confirmed 
00001B3A                           641  NOP
00001B3A  32FC 4E4F                642              MOVE.W  #'NO',(A1)+
00001B3E  12FC 0050                643              MOVE.B  #'P',(A1)+
00001B42  5641                     644              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
00001B44                           645              
00001B44  12FC 0020                646              MOVE.B  #' ',(A1)+       ; Add a spacer into our IOStringLoc
00001B48  32FC 2020                647              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
00001B4C  32FC 2020                648              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
00001B50  5A41                     649              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces        
00001B52  4E75                     650              RTS
00001B54                           651  
00001B54                           652  ;  Here we assume that all 16 bits have been confirmed            
00001B54                           653  RTS         
00001B54  32FC 5254                654              MOVE.W  #'RT',(A1)+
00001B58  12FC 0053                655              MOVE.B  #'S',(A1)+
00001B5C  5641                     656              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
00001B5E                           657              
00001B5E  12FC 0020                658              MOVE.B  #' ',(A1)+       ; Add a spacer into our IOStringLoc
00001B62  32FC 2020                659              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
00001B66  32FC 2020                660              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
00001B6A  5A41                     661              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces        
00001B6C  4E75                     662              RTS
00001B6E                           663              
00001B6E                           664  
00001B6E                           665  ;  Here we assume the first left-most 10 bits have been confirmed: 0100 1110 10 
00001B6E                           666  JSR                                    ; Five consecutive tests for illegal Src EA Modes
00001B6E  2C05                     667              MOVE.L  D5,D6              ; Push D5 into D6 
00001B70  0286 0000003F            668              ANDI.L  #$003F,D6          ; Isolate the Src EA bits
00001B76  BCBC 0000003C            669              CMP.L   #$003C, D6         ; Compare with illegal EA mode #<data>
00001B7C  6700 0968                670              BEQ     UNKNOWN
00001B80                           671              
00001B80  E69E                     672              ROR.L   #3,D6              ; Roll 3 bits right
00001B82  0286 00000007            673              ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
00001B88  BCBC 00000000            674              CMP.L   #$0000,D6          ; Compare with illegal mode Dn
00001B8E  6700 0956                675              BEQ     UNKNOWN
00001B92  BCBC 00000001            676              CMP.L   #$0001,D6          ; Compare with illegal mode An
00001B98  6700 094C                677              BEQ     UNKNOWN
00001B9C  BCBC 00000003            678              CMP.L   #$0003,D6          ; Compare with illegal mode (An)+
00001BA2  6700 0942                679              BEQ     UNKNOWN
00001BA6  BCBC 00000004            680              CMP.L   #$0004,D6          ; Compare with illegal mode -(An)
00001BAC  6700 0938                681              BEQ     UNKNOWN
00001BB0                           682              *----------------
00001BB0                           683  
00001BB0  32FC 4A53                684              MOVE.W  #'JS',(A1)+
00001BB4  12FC 0052                685              MOVE.B  #'R',(A1)+
00001BB8  5641                     686              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
00001BBA                           687              
00001BBA  12FC 0020                688              MOVE.B  #' ',(A1)+
00001BBE  32FC 2020                689              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
00001BC2  22FC 20202020            690              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
00001BC8  5E41                     691              ADDQ    #7,D1              ; We added 4 bytes, aka 4 spaces
00001BCA  2C05                     692              MOVE.L  D5,D6              ; Push D5 into D6
00001BCC                           693              
00001BCC  0286 0000003F            694              ANDI.L  #$003F,D6          ; Isolate the Src EA bits 
00001BD2  4EB9 0000250A            695              JSR EAGETSRCEA             ; Find and print the code stored in D6 
00001BD8  4E75                     696              RTS
00001BDA                           697              
00001BDA                           698  
00001BDA                           699  ;  Here we assume that these left-most bits have been confirmed, where - have not been confirmed: 0100 -- 001
00001BDA                           700  MOVEM                                  ; Four consecutive tests for illegal Src EA Modes
00001BDA  2C05                     701              MOVE.L  D5,D6              ; Push D5 into D6 
00001BDC  0286 0000003F            702              ANDI.L  #$003F,D6          ; Isolate the Src EA bits
00001BE2  BCBC 0000003C            703              CMP.L   #$003C, D6         ; Compare with illegal EA mode #<data>
00001BE8  6700 08FC                704              BEQ     UNKNOWN
00001BEC                           705              
00001BEC  E69E                     706              ROR.L   #3,D6              ; Roll 3 bits right
00001BEE  0286 00000007            707              ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
00001BF4  BCBC 00000000            708              CMP.L   #$0000,D6          ; Compare with illegal mode Dn
00001BFA  6700 08EA                709              BEQ     UNKNOWN
00001BFE  BCBC 00000001            710              CMP.L   #$0001,D6          ; Compare with illegal mode An
00001C04  6700 08E0                711              BEQ     UNKNOWN
00001C08                           712              
00001C08  2C05                     713              MOVE.L  D5,D6              ; Copy D5 into D6
00001C0A  0246 0438                714              ANDI.W  #$0438,D6          ; Isolate our direction and EA mode bits
00001C0E  BC7C 0018                715              CMP.W   #$0018,D6          ; If it equals $0018..
00001C12  6700 08D2                716              BEQ     UNKNOWN            ; Dr 0, (An)+ case..
00001C16  BC7C 0420                717              CMP.W   #$0420,D6          ; If it equals $0420..
00001C1A  6700 08CA                718              BEQ     UNKNOWN            ; Dr 1, -(An) case..
00001C1E                           719              *----------------
00001C1E                           720  
00001C1E  22FC 4D4F5645            721              MOVE.L  #'MOVE',(A1)+
00001C24  32FC 4D2E                722              MOVE.W  #'M.',(A1)+
00001C28  5C41                     723              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
00001C2A                           724              
00001C2A  2C05                     725              MOVE.L  D5,D6              ; Copy our OpCode
00001C2C  EC8E                     726              LSR.L   #6,D6              ; Shift it 6 bits to the right
00001C2E  0806 0000                727              BTST    #$00,D6            ; If our size bit is 0..
00001C32  6700 0006                728              BEQ     MOVEMW             ; .. Its a MOVEM of size W
00001C36  6000 000C                729              BRA     MOVEML             ; .. Otherwise it's of size L
00001C3A                           730  
00001C3A  12FC 0057                731  MOVEMW      MOVE.B  #'W',(A1)+
00001C3E  5241                     732              ADDQ    #1,D1              ; We've added another character into IOStringLoc
00001C40  6000 0008                733              BRA     MOVEMOP            ; MovemOp label, to skip MovemL label
00001C44                           734              
00001C44  12FC 004C                735  MOVEML      MOVE.B  #'L',(A1)+
00001C48  5241                     736              ADDQ    #1,D1              ; We've added another character into IOStringLoc
00001C4A                           737              
00001C4A  12FC 0020                738  MOVEMOP     MOVE.B  #' ',(A1)+         ; Add a spacer into our IOStringLoc
00001C4E  32FC 2020                739              MOVE.W  #'  ',(A1)+        ;
00001C52  5641                     740              ADDQ    #3,D1              ; We added 4 bytes, aka 4 spaces 
00001C54                           741              
00001C54  E88E                     742              LSR.L   #4,D6              ; Shift our OpCode 4 bits to the left of Size (going to the right)
00001C56  0806 0000                743              BTST    #$00,D6            ; Check our Direction bit
00001C5A  6700 0006                744              BEQ     MOVEMPRED          ; If it's 0, our direction is Pre Decrement (eg. Move TO the stack)
00001C5E  6000 001E                745              BRA     MOVEMPOSTI         ; Otherwise, it's Post Increment (eg. Move FROM the stack)
00001C62                           746              
00001C62                           747  MOVEMPRED   ; This part is where we get the gross A0-A6/D0-D7 part
00001C62  4EB9 0000279E            748              JSR     EAMOVEMPRED  
00001C68                           749              
00001C68  12FC 002C                750              MOVE.B  #',',(A1)+
00001C6C  5241                     751              ADDQ    #1,D1
00001C6E                           752              
00001C6E  2C05                     753              MOVE.L  D5,D6              ; Copy our OpCode to D6
00001C70  0286 0000003F            754              ANDI.L  #$3F,D6            ; Isolate our EA src bits
00001C76                           755              
00001C76  4EB9 0000250A            756              JSR EAGETSRCEA  
00001C7C                           757            
00001C7C  4E75                     758              RTS
00001C7E                           759  
00001C7E  2C05                     760  MOVEMPOSTI  MOVE.L  D5,D6              ; Copy our OpCode to D6
00001C80  0286 0000003F            761              ANDI.L  #$3F,D6            ; Isolate our EA src bits
00001C86                           762              
00001C86  4EB9 0000250A            763              JSR EAGETSRCEA  
00001C8C                           764              
00001C8C  12FC 002C                765              MOVE.B  #',',(A1)+
00001C90  5241                     766              ADDQ    #1,D1
00001C92                           767              
00001C92                           768              ; This part is where we get the gross A0-A6/D0-D7 part
00001C92  4EB9 00002688            769              JSR     EAMOVEMPOSTI
00001C98                           770              
00001C98  4E75                     771              RTS
00001C9A                           772              
00001C9A                           773  
00001C9A                           774  ;  Here we assume that these left-most bits have been confirmed, where - have not been confirmed: 0100 --- 111            
00001C9A                           775  LEA                                    ; Five consecutive tests for illegal Src EA Modes
00001C9A  2C05                     776              MOVE.L  D5,D6              ; Push D5 into D6 
00001C9C  0286 0000003F            777              ANDI.L  #$003F,D6          ; Isolate the Src EA bits
00001CA2  BCBC 0000003C            778              CMP.L   #$003C, D6         ; Compare with illegal EA mode #<data>
00001CA8  6700 083C                779              BEQ     UNKNOWN
00001CAC                           780              
00001CAC  E69E                     781              ROR.L   #3,D6              ; Roll 3 bits right
00001CAE  0286 00000007            782              ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
00001CB4  BCBC 00000000            783              CMP.L   #$0000,D6          ; Compare with illegal mode Dn
00001CBA  6700 082A                784              BEQ     UNKNOWN
00001CBE  BCBC 00000001            785              CMP.L   #$0001,D6          ; Compare with illegal mode An
00001CC4  6700 0820                786              BEQ     UNKNOWN
00001CC8  BCBC 00000003            787              CMP.L   #$0003,D6          ; Compare with illegal mode (An)+
00001CCE  6700 0816                788              BEQ     UNKNOWN
00001CD2  BCBC 00000004            789              CMP.L   #$0004,D6          ; Compare with illegal mode -(An)
00001CD8  6700 080C                790              BEQ     UNKNOWN
00001CDC                           791              *----------------
00001CDC                           792              
00001CDC  32FC 4C45                793              MOVE.W  #'LE',(A1)+
00001CE0  12FC 0041                794              MOVE.B  #'A',(A1)+
00001CE4  5641                     795              ADDQ    #3,D1               ; We added 3 new characters to our IOStringLoc 
00001CE6                           796               
00001CE6  12FC 0020                797              MOVE.B  #' ',(A1)+          ; Added an extra space here, due to only 3 character OpCode
00001CEA  22FC 20202020            798              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
00001CF0  32FC 2020                799              MOVE.W  #'  ',(A1)+ 
00001CF4  5E41                     800              ADDQ    #7,D1               ; We added 4 bytes, aka 4 spaces
00001CF6                           801              
00001CF6  2C05                     802              MOVE.L  D5,D6               ; Copy D5 into D6
00001CF8  0286 0000003F            803              ANDI.L  #$003F,D6           ; Isolate the Src EA bits
00001CFE  4EB9 0000250A            804              JSR EAGETSRCEA
00001D04                           805              
00001D04  12FC 002C                806              MOVE.B  #',',(A1)+
00001D08  5241                     807              ADDQ    #1,D1
00001D0A                           808              
00001D0A  2C05                     809              MOVE.L  D5,D6               ; Copy D5 into D6
00001D0C  E09E                     810              ROR.L   #8,D6               ; Rotate 9 bits to the right (An Dst bits)
00001D0E  E29E                     811              ROR.L   #1,D6               ; 
00001D10  0286 00000005            812              ANDI.L  #$0005,D6           ; Isolate the An Destination bits
00001D16  4EF9 00002594            813              JMP EAAN
00001D1C  4E75                     814              RTS      
00001D1E                           815              
00001D1E  2C05                     816  Bcc         MOVE.L  D5,D6               ; Copy our OpCode into D6
00001D20  E15E                     817              ROL.W   #8,D6               ; Rotate our condition bit into place
00001D22  0206 000F                818              ANDI.B  #$0F,D6             ; Isolate the right-most nybble (condition)
00001D26                           819              
00001D26  BC3C 0004                820              CMP.B   #%0100,D6           ; See if our Condition is '0100'
00001D2A  6700 0016                821              BEQ     BCCOP               ; If it is, we have a BCC operation
00001D2E  BC3C 000E                822              CMP.B   #%1110,D6           ; See if our Condition is '1110'
00001D32  6700 001C                823              BEQ     BGTOP               ; If it is, we have a BGT operation
00001D36  BC3C 000F                824              CMP.B   #%1111,D6           ; See if our Condition is '1111'
00001D3A  6700 0022                825              BEQ     BLEOP               ; If it is, we have a BLE operation
00001D3E                           826              
00001D3E  6000 07A6                827              BRA     UNKNOWN             ; Otherwise we don't know what kind of operation we have
00001D42                           828              
00001D42  32FC 4243                829  BCCOP       MOVE.W  #'BC',(A1)+
00001D46  12FC 0043                830              MOVE.B  #'C',(A1)+
00001D4A  5641                     831              ADDQ    #3,D1               ; We've added three characters into our IOStringLoc
00001D4C  6000 001E                832              BRA     BccSIZE             ; Branch to find our Bcc Op's Size
00001D50                           833              
00001D50  32FC 4247                834  BGTOP       MOVE.W  #'BG',(A1)+
00001D54  12FC 0054                835              MOVE.B  #'T',(A1)+
00001D58  5641                     836              ADDQ    #3,D1               ; We've added three characters into our IOStringLoc
00001D5A  6000 0010                837              BRA     BccSIZE             ; Branch to find our Bcc Op's Size
00001D5E                           838              
00001D5E  32FC 424C                839  BLEOP       MOVE.W  #'BL',(A1)+
00001D62  12FC 0045                840              MOVE.B  #'E',(A1)+
00001D66  5641                     841              ADDQ    #3,D1               ; We've added three characters into our IOStringLoc
00001D68  6000 0002                842              BRA     BccSIZE             ; Branch to find our Bcc Op's Size
00001D6C                           843  
00001D6C                           844  BccSIZE     ; Find Displacement value
00001D6C                           845              ; Branch to proper displacement value label
00001D6C                           846              ; Store the value of A2 into D7
00001D6C                           847              ; Get our total displacement into D6
00001D6C                           848              ; Print the new address as D7 +/- D6
00001D6C                           849              
00001D6C  12FC 0020                850              MOVE.B  #' ',(A1)+       ; Add a spacer into our IOStringLoc
00001D70  32FC 2020                851              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
00001D74  32FC 2020                852              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
00001D78  32FC 2020                853              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
00001D7C  5E41                     854              ADDQ    #7,D1              ; We added 4 bytes, aka 4 spaces   
00001D7E                           855              
00001D7E  12FC 0024                856              MOVE.B  #'$',(A1)+
00001D82  5241                     857              ADDQ    #1,D1
00001D84                           858              
00001D84  2C05                     859              MOVE.L  D5,D6
00001D86  0286 000000FF            860              ANDI.L  #$FF,D6             ; Isolate our Size bits
00001D8C  BC3C 0000                861              CMP.B   #$00,D6             ; If it's equal to $00..
00001D90  6700 0032                862              BEQ     Bcc16               ; .. It has a 16 bit displacement
00001D94  0286 000000FF            863              ANDI.L  #$FF,D6             ; If it's equal to $FF..
00001D9A  6700 0050                864              BEQ     Bcc32               ; .. It has a 32 bit displacement
00001D9E                           865              ; Otherwise, it's an 8 bit displacement
00001D9E                           866              
00001D9E  2E0A                     867              MOVE.L  A2,D7               ; Get our initial address
00001DA0  4A06                     868              TST.B   D6                  ; Is D6 negative?
00001DA2  6B00 0010                869              BMI     Bcc8NEG             ; Branch to Negative
00001DA6                           870              
00001DA6  DE46                     871              ADD.W   D6,D7               ; Otherwise, Add what we have to D7
00001DA8                           872              
00001DA8  2C07                     873              MOVE.L  D7,D6               ; Push our expected address into D6 to print
00001DAA  4244                     874              CLR     D4                  ; Clear counter
00001DAC  4EB9 00002664            875              JSR     EAHEXtoASCII        ; Print
00001DB2                           876              
00001DB2  4E75                     877              RTS 
00001DB4                           878              
00001DB4  4406                     879  Bcc8NEG     NEG.B   D6 
00001DB6  9E46                     880              SUB.W   D6,D7
00001DB8                           881              
00001DB8  2C07                     882              MOVE.L  D7,D6               ; Push our expected address into D6 to print
00001DBA  4244                     883              CLR     D4                  ; Clear counter
00001DBC  4EB9 00002664            884              JSR     EAHEXtoASCII        ; Print
00001DC2                           885              
00001DC2  4E75                     886              RTS  
00001DC4                           887           
00001DC4  2E0A                     888  Bcc16       MOVE.L  A2,D7               ; Get our initial address
00001DC6  3C1A                     889              MOVE.W  (A2)+,D6
00001DC8  4A46                     890              TST.W   D6                  ; Is D6 negative?
00001DCA  6B00 0010                891              BMI     Bcc16NEG             ; Branch to Negative
00001DCE                           892              
00001DCE  DE86                     893              ADD.L   D6,D7               ; Otherwise, Add what we have to D7
00001DD0                           894              
00001DD0  2C07                     895              MOVE.L  D7,D6               ; Push our expected address into D6 to print
00001DD2  4244                     896              CLR     D4                  ; Clear counter
00001DD4  4EB9 00002664            897              JSR     EAHEXtoASCII        ; Print
00001DDA                           898              
00001DDA  4E75                     899              RTS 
00001DDC  4446                     900  Bcc16NEG    NEG.W   D6 
00001DDE  9E86                     901              SUB.L   D6,D7
00001DE0                           902              
00001DE0  2C07                     903              MOVE.L  D7,D6               ; Push our expected address into D6 to print
00001DE2  4244                     904              CLR     D4                  ; Clear counter
00001DE4  4EB9 00002664            905              JSR     EAHEXtoASCII        ; Print
00001DEA                           906              
00001DEA  4E75                     907              RTS  
00001DEC                           908  
00001DEC                           909  
00001DEC  2E0A                     910  Bcc32       MOVE.L  A2,D7               ; Get our initial address
00001DEE  2C1A                     911              MOVE.L  (A2)+,D6
00001DF0  4A86                     912              TST.L   D6                  ; Is D6 negative?
00001DF2  6BE8                     913              BMI     Bcc16NEG            ; Branch to Negative
00001DF4                           914              
00001DF4  DE86                     915              ADD.L   D6,D7               ; Otherwise, Add what we have to D7
00001DF6                           916              
00001DF6  2C07                     917              MOVE.L  D7,D6               ; Push our expected address into D6 to print
00001DF8  4244                     918              CLR     D4                  ; Clear counter
00001DFA  4846                     919              SWAP    D6
00001DFC  4EB9 00002664            920              JSR     EAHEXtoASCII        ; Print
00001E02  4244                     921              CLR     D4                  ; Clear counter
00001E04  4846                     922              SWAP    D6
00001E06  4EB9 00002664            923              JSR     EAHEXtoASCII        ; Print
00001E0C                           924              
00001E0C  4E75                     925              RTS 
00001E0E                           926  
00001E0E  4486                     927  Bcc32NEG    NEG.L   D6 
00001E10  9E86                     928              SUB.L   D6,D7
00001E12                           929              
00001E12  2C07                     930              MOVE.L  D7,D6               ; Push our expected address into D6 to print
00001E14  4244                     931              CLR     D4                  ; Clear counter
00001E16  4846                     932              SWAP    D6
00001E18  4EB9 00002664            933              JSR     EAHEXtoASCII        ; Print
00001E1E  4244                     934              CLR     D4                  ; Clear counter
00001E20  4846                     935              SWAP    D6
00001E22  4EB9 00002664            936              JSR     EAHEXtoASCII        ; Print
00001E28                           937      
00001E28  4E75                     938              RTS           
00001E2A                           939  MOVEQ
00001E2A  22FC 4D4F5645            940              MOVE.L  #'MOVE',(A1)+
00001E30  12FC 0051                941              MOVE.B  #'Q',(A1)+
00001E34  5A41                     942              ADDQ    #5,D1               ; We added 4 new characters to our IOStringLoc
00001E36                           943              
00001E36  12FC 0020                944              MOVE.B  #' ',(A1)+
00001E3A  32FC 2020                945              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
00001E3E  32FC 2020                946              MOVE.W  #'  ',(A1)+
00001E42  5841                     947              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
00001E44                           948              
00001E44  2C05                     949              MOVE.L  D5,D6               ; Copy D5 into D6
00001E46  0286 000000FF            950              ANDI.L  #$00FF,D6           ; Isolate the Src EA bits
00001E4C                           951              
00001E4C  12FC 0023                952              MOVE.B  #'#',(A1)+
00001E50  12FC 0024                953              MOVE.B  #'$',(A1)+
00001E54  5241                     954              ADDQ    #1,D1               ; We added 4 bytes, aka 4 spaces
00001E56  183C 0002                955              MOVE.B  #2,D4               ; "Start" at 2 characters
00001E5A  E19E                     956              ROL.L   #$8,D6
00001E5C  4EB9 00002664            957              JSR     EAHEXtoASCII
00001E62                           958              
00001E62  12FC 002C                959              MOVE.B  #',',(A1)+
00001E66  5241                     960              ADDQ    #1,D1
00001E68                           961              
00001E68  2C05                     962              MOVE.L  D5,D6               ; Copy D5 into D6
00001E6A  E09E                     963              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00001E6C  E29E                     964              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00001E6E  0286 00000007            965              ANDI.L  #$0007,D6           ; Isolate the Dn Destination bits
00001E74  4EF9 00002586            966              JMP EADN
00001E7A                           967              
00001E7A  4E75                     968              RTS 
00001E7C                           969              
00001E7C                           970  DIVU 
00001E7C                           971                                         ; One test for illegal Src EA Mode
00001E7C  2C05                     972              MOVE.L  D5,D6              ; Push D5 into D6   
00001E7E  E69E                     973              ROR.L   #3,D6              ; Roll 3 bits right
00001E80  0286 00000007            974              ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
00001E86  BCBC 00000001            975              CMP.L   #$0001,D6          ; Compare with illegal mode An
00001E8C  6700 0658                976              BEQ     UNKNOWN
00001E90                           977              *----------------       
00001E90  22FC 44495655            978              MOVE.L  #'DIVU',(A1)+
00001E96  5841                     979              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001E98                           980              
00001E98  22FC 20202020            981              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
00001E9E  32FC 2020                982              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
00001EA2  5C41                     983              ADDQ    #6,D1               ; We added 4 bytes, aka 4 spaces
00001EA4                           984              
00001EA4  2C05                     985              MOVE.L  D5,D6               ; Copy D5 into D6
00001EA6  0286 0000003F            986              ANDI.L  #$003F,D6           ; Isolate the Src EA bits
00001EAC  7002                     987              MOVE.L  #2,D0               ; Put 2 into D0 to indicate it's a wordsize
00001EAE  4EB9 0000250A            988              JSR EAGETSRCEA
00001EB4                           989              
00001EB4  12FC 002C                990              MOVE.B  #',',(A1)+
00001EB8  5241                     991              ADDQ    #1,D1
00001EBA                           992              
00001EBA  2C05                     993              MOVE.L  D5,D6               ; Copy D5 into D6
00001EBC  E09E                     994              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00001EBE  E29E                     995              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00001EC0  0286 00000007            996              ANDI.L  #$0007,D6           ; Isolate the Dn Destination bits
00001EC6  4EF9 00002586            997              JMP EADN
00001ECC                           998              
00001ECC  4E75                     999              RTS
00001ECE                          1000  
00001ECE                          1001              
00001ECE  2C05                    1002  SUB         MOVE.L  D5,D6               ; Copy D5 into D6
00001ED0  EC8E                    1003              LSR.L   #6,D6               ; Shift the size bits to the far right
00001ED2  0206 0004               1004              ANDI.B  #$4,D6              ; Isolate the size bits    
00001ED6                          1005                   
00001ED6  BC3C 0004               1006              CMP.B   #%0100,D6           ; See if D6 is size "%100" through "%110"..
00001EDA  6700 0026               1007              BEQ     SUBEA              ; If it is, our OpCode is in the format of..
00001EDE                          1008              
00001EDE  2C05                    1009              MOVE.L  D5,D6               ; Copy D5 into D6
00001EE0  EC8E                    1010              LSR.L   #6,D6               ; Shift the size bits to the far right
00001EE2  0206 0007               1011              ANDI.B  #$7,D6              ; Isolate the size bits    
00001EE6                          1012              
00001EE6  BC3C 0002               1013              CMP.B   #%10,D6             ; See if D6 is size "%000" through "%010"..
00001EEA  6700 0092               1014              BEQ     SUBLDN              ; If it is, our OpCode is in the format of..
00001EEE  BC3C 0001               1015              CMP.B   #%01,D6             ; .. <EA> ~ Dn --> Dn
00001EF2  6700 009C               1016              BEQ     SUBWDN
00001EF6  BC3C 0000               1017              CMP.B   #%00,D6
00001EFA  6700 00A6               1018              BEQ     SUBBDN              ; == 000 at this point
00001EFE                          1019              
00001EFE  6000 05E6               1020              BRA     UNKNOWN
00001F02                          1021              
00001F02  2C05                    1022  SUBEA       MOVE.L  D5,D6               ; Copy D5 into D6
00001F04  CC3C 003F               1023              AND.B   #$3F,D6             ; Isolate our EA Src bits
00001F08  BC3C 0039               1024              CMP.B   #$39,D6             ; Check for Illegal #$ mode
00001F0C  6700 05D8               1025              BEQ     UNKNOWN
00001F10  CC3C 0038               1026              AND.B   #$38,D6             ; Isolate our EA Src Mode bits
00001F14  BC3C 0008               1027              CMP.B   #$08,D6             ; Check for Illegal mode An
00001F18  6700 05CC               1028              BEQ     UNKNOWN
00001F1C  BC3C 0000               1029              CMP.B   #$00,D6             ; Check for Illegal mode Dn 
00001F20  6700 05C4               1030              BEQ     UNKNOWN
00001F24                          1031              
00001F24  2C05                    1032              MOVE.L  D5,D6               ; Copy D5 into D6
00001F26  EC8E                    1033              LSR.L   #6,D6               ; Shift the size bits to the far right
00001F28  0206 0007               1034              ANDI.B  #$7,D6              ; Isolate the size bits    
00001F2C                          1035                   
00001F2C  BC3C 0006               1036              CMP.B   #%0110,D6           ; See if D6 is size "%100" through "%110"..
00001F30  6700 0016               1037              BEQ     SUBLEA              ; If it is, our OpCode is in the format of..
00001F34  BC3C 0005               1038              CMP.B   #%101,D6            ; .. Dn ~ <EA> --> <EA>
00001F38  6700 0020               1039              BEQ     SUBWEA
00001F3C  BC3C 0004               1040              CMP.B   #%100,D6
00001F40  6700 002A               1041              BEQ     SUBBEA
00001F44                          1042              
00001F44  6000 05A0               1043              BRA     UNKNOWN
00001F48                          1044  
00001F48  22FC 5355422E           1045  SUBLEA      MOVE.L  #'SUB.',(A1)+
00001F4E  5841                    1046              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001F50  12FC 004C               1047              MOVE.B  #'L',(A1)+
00001F54  5241                    1048              ADDQ    #1,D1               ; We added 1 byte into D1
00001F56  6000 0202               1049              BRA     ANDEA
00001F5A                          1050              
00001F5A  22FC 5355422E           1051  SUBWEA      MOVE.L  #'SUB.',(A1)+
00001F60  5841                    1052              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001F62  12FC 0057               1053              MOVE.B  #'W',(A1)+
00001F66  5241                    1054              ADDQ    #1,D1               ; We added 1 byte into D1
00001F68  6000 01F0               1055              BRA     ANDEA
00001F6C                          1056  
00001F6C  22FC 5355422E           1057  SUBBEA      MOVE.L  #'SUB.',(A1)+
00001F72  5841                    1058              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001F74  12FC 0042               1059              MOVE.B  #'B',(A1)+
00001F78  5241                    1060              ADDQ    #1,D1               ; We added 1 byte into D1
00001F7A  6000 01DE               1061              BRA     ANDEA
00001F7E                          1062  
00001F7E  22FC 5355422E           1063  SUBLDN      MOVE.L  #'SUB.',(A1)+
00001F84  5841                    1064              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001F86  12FC 004C               1065              MOVE.B  #'L',(A1)+
00001F8A  5241                    1066              ADDQ    #1,D1               ; We added 1 byte into D1
00001F8C  6000 0238               1067              BRA ANDDN
00001F90                          1068              
00001F90  22FC 5355422E           1069  SUBWDN      MOVE.L  #'SUB.',(A1)+
00001F96  5841                    1070              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001F98  12FC 0057               1071              MOVE.B  #'W',(A1)+
00001F9C  5241                    1072              ADDQ    #1,D1               ; We added 1 byte into D1
00001F9E  6000 0226               1073              BRA ANDDN
00001FA2                          1074  
00001FA2  22FC 5355422E           1075  SUBBDN      MOVE.L  #'SUB.',(A1)+
00001FA8  5841                    1076              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001FAA  12FC 0042               1077              MOVE.B  #'B',(A1)+
00001FAE  5241                    1078              ADDQ    #1,D1               ; We added 1 byte into D1
00001FB0  6000 0214               1079              BRA ANDDN  
00001FB4                          1080  
00001FB4                          1081  ;  Here we assume that these left-most nybble has been confirmed: 1011  
00001FB4                          1082  CMP        
00001FB4  2C05                    1083              MOVE.L  D5,D6               ; Push D5 into D6
00001FB6  EC9E                    1084              ROR.L   #6,D6               ; Rotate 6 bits to the right
00001FB8  E38E                    1085              LSL.L   #1,D6               ; Add 0 to right most bit
00001FBA  0206 000F               1086              ANDI.B  #$0F,D6             ; Isolate right-most nybble
00001FBE                          1087              
00001FBE  BC3C 0000               1088              CMP.B   #$00,D6             ; If it matches CMP.B's size bit + 0 added to right
00001FC2  6700 0016               1089              BEQ     CMPB                ; First 4 left-most bits plus size of CMP confirmed
00001FC6                          1090  
00001FC6  BC3C 0002               1091              CMP.B   #$02,D6             ; If it matches CMP.W's size bit + 0 added to right
00001FCA  6700 0026               1092              BEQ     CMPW                ; First 4 left-most bits plus size of CMP confirmed 
00001FCE                          1093  
00001FCE  BC3C 0004               1094              CMP.B   #$04,D6             ; If it matches CMP.B's size bit + 0 added to right
00001FD2  6700 0036               1095              BEQ     CMPL                ; First 4 left-most bits plus size of CMP confirmed 
00001FD6                          1096   
00001FD6  6000 050E               1097              BRA     UNKNOWN             ; else unknown 
00001FDA                          1098  
00001FDA                          1099  ;  Here we assume that confirming these bits, 1011 --- 000 --- ---, is enough to identify CMP.B 
00001FDA  32FC 434D               1100  CMPB        MOVE.W  #'CM',(A1)+
00001FDE  12FC 0050               1101              MOVE.B  #'P',(A1)+
00001FE2  12FC 002E               1102              MOVE.B  #'.',(A1)+
00001FE6  12FC 0042               1103              MOVE.B  #'B',(A1)+
00001FEA  5A41                    1104              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
00001FEC  7001                    1105              MOVE.L  #1,D0               ; Put 1 into D0 to indicate it's a bytesize
00001FEE  6000 0032               1106              BRA     CMPOP
00001FF2                          1107  
00001FF2                          1108  ;  Here we assume that confirming these bits, 1011 --- 001 --- ---, is enough to identify CMP.W   
00001FF2  32FC 434D               1109  CMPW        MOVE.W  #'CM',(A1)+
00001FF6  12FC 0050               1110              MOVE.B  #'P',(A1)+
00001FFA  12FC 002E               1111              MOVE.B  #'.',(A1)+
00001FFE  12FC 0057               1112              MOVE.B  #'W',(A1)+
00002002  5A41                    1113              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
00002004  7002                    1114              MOVE.L  #2,D0               ; Put 2 into D0 to indicate it's a wordsize
00002006  6000 001A               1115              BRA     CMPOP
0000200A                          1116              
0000200A                          1117  ;  Here we assume that confirming these bits, 1011 --- 010 --- ---, is enough to identify CMP.L
0000200A  32FC 434D               1118  CMPL        MOVE.W  #'CM',(A1)+
0000200E  12FC 0050               1119              MOVE.B  #'P',(A1)+
00002012  12FC 002E               1120              MOVE.B  #'.',(A1)+
00002016  12FC 004C               1121              MOVE.B  #'L',(A1)+
0000201A  5A41                    1122              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
0000201C  7003                    1123              MOVE.L  #3,D0               ; Put 3 into D0 to indicate it's a longsize
0000201E  6000 0002               1124              BRA     CMPOP
00002022                          1125              
00002022  12FC 0020               1126  CMPOP       MOVE.B  #' ',(A1)+
00002026  32FC 2020               1127              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
0000202A  32FC 2020               1128              MOVE.W  #'  ',(A1)+
0000202E  5A41                    1129              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces
00002030                          1130              
00002030  2C05                    1131              MOVE.L  D5,D6               ; Push D5 into D6
00002032  0286 0000003F           1132              ANDI.L  #$003F,D6           ; Isolate the Src EA bits 
00002038  4EB9 0000250A           1133              JSR EAGETSRCEA              ; Find and print the code stored in D6
0000203E                          1134              
0000203E  12FC 002C               1135              MOVE.B  #',',(A1)+
00002042  5241                    1136              ADDQ    #1,D1
00002044                          1137              
00002044  2C05                    1138              MOVE.L  D5,D6               ; Copy D5 into D6
00002046  E09E                    1139              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00002048  E29E                    1140              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
0000204A  0286 00000007           1141              ANDI.L  #$0007,D6           ; Isolate the Dn Destination bits
00002050  4EF9 00002586           1142              JMP EADN
00002056                          1143              
00002056  4E75                    1144              RTS          
00002058                          1145          
00002058                          1146  ; This label determines if the code is either MULS or AND, by looking at it's size bits     
00002058  2C05                    1147  MULSAND     MOVE.L  D5,D6               ; Copy D5 into D6
0000205A  CC3C 0038               1148              AND.B   #$38,D6             ; Check if the Src is of mode An
0000205E  BC3C 0008               1149              CMP.B   #$08,D6
00002062  6700 0482               1150              BEQ     UNKNOWN             ; An is Invalid, branch to Unknown  
00002066  2C05                    1151              MOVE.L  D5,D6               ; Copy D5 into D6 
00002068  EC8E                    1152              LSR.L   #6,D6               ; Shift the size bits to the far right
0000206A  0206 0007               1153              ANDI.B  #$7,D6              ; Isolate the size bits
0000206E  BC3C 0007               1154              CMP.B   #7,D6               ; See if the size is '111'..
00002072  6704                    1155              BEQ.S   MULS                ; ..If so, it's a MULS opcode
00002074  6000 003E               1156              BRA     AND                 ; Otherwise, it's an AND code
00002078                          1157          
00002078                          1158  MULS                                   ; One test for illegal Src EA Mode
00002078                          1159              *----------------
00002078  22FC 4D554C53           1160              MOVE.L  #'MULS',(A1)+
0000207E  5841                    1161              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00002080                          1162              
00002080  22FC 20202020           1163              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
00002086  32FC 2020               1164              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
0000208A  5C41                    1165              ADDQ    #6,D1               ; We added 4 bytes, aka 4 spaces
0000208C                          1166              
0000208C  7002                    1167              MOVE.L  #2,D0               ; Put 2 into D0 to indicate it's a wordsize
0000208E  2C05                    1168              MOVE.L  D5,D6               ; Copy D5 into D6
00002090                          1169              ;DC.L    0,0,0,0             ; Fault Bandaid
00002090  0286 0000003F           1170              ANDI.L  #$003F,D6           ; Isolate the Src EA bits
00002096  4EB9 0000250A           1171              JSR EAGETSRCEA
0000209C                          1172              
0000209C  12FC 002C               1173              MOVE.B  #',',(A1)+
000020A0  5241                    1174              ADDQ    #1,D1
000020A2                          1175              
000020A2  2C05                    1176              MOVE.L  D5,D6               ; Copy D5 into D6
000020A4  EF5E                    1177              ROL.W   #7,D6               ; Rotate 9 bits to the right (Dn Dst bits)
000020A6  0286 00000007           1178              ANDI.L  #$0007,D6           ; Isolate the Dn Destination bits
000020AC  4EF9 00002586           1179              JMP EADN
000020B2                          1180              
000020B2  4E75                    1181              RTS
000020B4                          1182              
000020B4                          1183  ; At this point, we know D6 is the size of our opcode
000020B4  CC3C 0004               1184  AND         AND.B   #$04,D6
000020B8  BC3C 0004               1185              CMP.B   #%0100,D6           ; See if D6 is size "%100" through "%110"..
000020BC  6700 0026               1186              BEQ     ANDEACH             ; .. Dn ~ <EA> --> <EA>
000020C0                          1187              
000020C0  2C05                    1188              MOVE.L  D5,D6               ; Copy D5 into D6
000020C2  EC8E                    1189              LSR.L   #6,D6               ; Shift the size bits to the far right
000020C4  0206 0007               1190              ANDI.B  #$7,D6              ; Isolate the size bits 
000020C8                          1191              
000020C8  BC3C 0002               1192              CMP.B   #%10,D6             ; See if D6 is size "%000" through "%010"..
000020CC  6700 00C2               1193              BEQ     ANDLDN              ; If it is, our OpCode is in the format of..
000020D0  BC3C 0001               1194              CMP.B   #%01,D6             ; .. <EA> ~ Dn --> Dn
000020D4  6700 00CC               1195              BEQ     ANDWDN
000020D8  BC3C 0000               1196              CMP.B   #%00,D6
000020DC  6700 00D6               1197              BEQ     ANDBDN              ; == 000 at this point
000020E0                          1198              
000020E0  6000 0404               1199              BRA     UNKNOWN
000020E4                          1200  
000020E4  2C05                    1201  ANDEACH     MOVE.L  D5,D6               ; Copy D5 into D6
000020E6  CC3C 003F               1202              AND.B   #$3F,D6             ; Isolate our EA Src bits
000020EA  BC3C 0039               1203              CMP.B   #$39,D6             ; Check for Illegal #$ mode
000020EE  6700 03F6               1204              BEQ     UNKNOWN
000020F2  CC3C 0038               1205              AND.B   #$38,D6             ; Isolate our EA Src Mode bits
000020F6  BC3C 0008               1206              CMP.B   #$08,D6             ; Check for Illegal mode An
000020FA  6700 03EA               1207              BEQ     UNKNOWN
000020FE  BC3C 0000               1208              CMP.B   #$00,D6             ; Check for Illegal mode Dn 
00002102  6700 03E2               1209              BEQ     UNKNOWN
00002106                          1210              
00002106  2C05                    1211              MOVE.L  D5,D6               ; Copy D5 into D6
00002108  EC8E                    1212              LSR.L   #6,D6               ; Shift the size bits to the far right
0000210A  0206 0007               1213              ANDI.B  #$7,D6              ; Isolate the size bits    
0000210E                          1214                   
0000210E  BC3C 0006               1215              CMP.B   #%0110,D6           ; See if D6 is size "%100" through "%110"..
00002112  6700 0016               1216              BEQ     ANDLEA              ; If it is, our OpCode is in the format of..
00002116  BC3C 0005               1217              CMP.B   #%101,D6            ; .. Dn ~ <EA> --> <EA>
0000211A  6700 001E               1218              BEQ     ANDWEA
0000211E  BC3C 0004               1219              CMP.B   #%100,D6
00002122  6700 0026               1220              BEQ     ANDBEA
00002126                          1221              
00002126  6000 03BE               1222              BRA     UNKNOWN
0000212A                          1223  
0000212A                          1224              
0000212A  22FC 414E442E           1225  ANDLEA      MOVE.L  #'AND.',(A1)+
00002130  12FC 004C               1226              MOVE.B  #'L',(A1)+
00002134  5A41                    1227              ADDQ    #5,D1               ; We added 5 byte into D1
00002136  6000 0022               1228              BRA     ANDEA
0000213A                          1229              
0000213A  22FC 414E442E           1230  ANDWEA      MOVE.L  #'AND.',(A1)+
00002140  12FC 0057               1231              MOVE.B  #'W',(A1)+
00002144  5A41                    1232              ADDQ    #5,D1               ; We added 5 byte into D1
00002146  6000 0012               1233              BRA     ANDEA
0000214A                          1234  
0000214A  22FC 414E442E           1235  ANDBEA      MOVE.L  #'AND.',(A1)+
00002150  12FC 0042               1236              MOVE.B  #'B',(A1)+
00002154  5A41                    1237              ADDQ    #5,D1               ; We added 5 byte into D1
00002156  6000 0002               1238              BRA     ANDEA
0000215A                          1239  
0000215A  12FC 0020               1240  ANDEA       MOVE.B  #' ',(A1)+          ; Add a spacer into our IOStringLoc
0000215E  32FC 2020               1241              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
00002162  32FC 2020               1242              MOVE.W  #'  ',(A1)+          ; Add a spacer into our IOStringLoc
00002166  5A41                    1243              ADDQ    #5,D1               ; We added 4 bytes, aka 4 spaces
00002168                          1244              
00002168  2C05                    1245              MOVE.L  D5,D6
0000216A  E08E                    1246              LSR.L   #8,D6               ; Shift our OpCode a total of 9 bits to the right
0000216C  E28E                    1247              LSR.L   #1,D6               ; 
0000216E  0286 00000007           1248              ANDI.L  #$07,D6             ; Isolate our data register
00002174                          1249              
00002174  4EB9 00002586           1250              JSR EADN
0000217A                          1251              
0000217A  12FC 002C               1252              MOVE.B  #',',(A1)+
0000217E  5241                    1253              ADDQ    #1,D1
00002180                          1254              
00002180  2C05                    1255              MOVE.L  D5,D6               ; Copy our OpCode again
00002182  0286 0000003F           1256              ANDI.L  #$3F,D6             ; Isolate our EA bits
00002188                          1257              
00002188  4EB9 0000250A           1258              JSR EAGETSRCEA  
0000218E                          1259              
0000218E  4E75                    1260              RTS
00002190                          1261              
00002190  22FC 414E442E           1262  ANDLDN      MOVE.L  #'AND.',(A1)+
00002196  5841                    1263              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00002198  12FC 004C               1264              MOVE.B  #'L',(A1)+
0000219C  5241                    1265              ADDQ    #1,D1               ; We added 1 byte into D1
0000219E  6000 0026               1266              BRA ANDDN
000021A2                          1267              
000021A2  22FC 414E442E           1268  ANDWDN      MOVE.L  #'AND.',(A1)+
000021A8  5841                    1269              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000021AA  12FC 0057               1270              MOVE.B  #'W',(A1)+
000021AE  5241                    1271              ADDQ    #1,D1               ; We added 1 byte into D1
000021B0  6000 0014               1272              BRA ANDDN
000021B4                          1273  
000021B4  22FC 414E442E           1274  ANDBDN      MOVE.L  #'AND.',(A1)+
000021BA  5841                    1275              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000021BC  12FC 0042               1276              MOVE.B  #'B',(A1)+
000021C0  5241                    1277              ADDQ    #1,D1               ; We added 1 byte into D1
000021C2  6000 0002               1278              BRA ANDDN  
000021C6                          1279  
000021C6                          1280  ANDDN
000021C6  12FC 0009               1281              MOVE.B  #$09,(A1)+          ; Add a spacer into our IOStringLoc
000021CA  5241                    1282              ADDQ    #1,D1               ; We added 4 bytes, aka 4 spaces
000021CC                          1283              
000021CC  2C05                    1284              MOVE.L  D5,D6               ; Copy our OpCode again
000021CE  0286 0000003F           1285              ANDI.L  #$3F,D6             ; Isolate our EA bits
000021D4                          1286              
000021D4  4EB9 0000250A           1287              JSR EAGETSRCEA              
000021DA                          1288              
000021DA  12FC 002C               1289              MOVE.B  #',',(A1)+
000021DE  5241                    1290              ADDQ    #1,D1
000021E0                          1291              
000021E0  2C05                    1292              MOVE.L  D5,D6
000021E2  E08E                    1293              LSR.L   #8,D6               ; Shift our OpCode a total of 9 bits to the right
000021E4  E28E                    1294              LSR.L   #1,D6               ; 
000021E6  0286 00000007           1295              ANDI.L  #$07,D6             ; Isolate our data register
000021EC                          1296              
000021EC  4EB9 00002586           1297              JSR EADN
000021F2                          1298              
000021F2  4E75                    1299              RTS
000021F4                          1300  
000021F4                          1301  ; This label determines if the code is either ADD or ADDA           
000021F4  2C05                    1302  ADDADDA     MOVE.L  D5,D6               ; Copy D5 into D6
000021F6  EC8E                    1303              LSR.L   #6,D6               ; Shift the size bits to the far right
000021F8  0206 0004               1304              ANDI.B  #$4,D6              ; Isolate the size bits
000021FC                          1305              
000021FC  BC3C 0004               1306              CMP.B   #%0100,D6           ; See if D6 is size "%100" through "%110"..
00002200  6700 006C               1307              BEQ     ADDEA              ; .. Dn ~ <EA> --> <EA>
00002204                          1308              
00002204  2C05                    1309              MOVE.L  D5,D6               ; Copy D5 into D6
00002206  EC8E                    1310              LSR.L   #6,D6               ; Shift the size bits to the far right
00002208  0206 0007               1311              ANDI.B  #$7,D6              ; Isolate the size bits
0000220C                          1312  
0000220C                          1313              
0000220C  BC3C 0002               1314              CMP.B   #%10,D6             ; See if D6 is size "%000" through "%010"..
00002210  6700 0026               1315              BEQ     ADDLDN              ; If it is, our OpCode is in the format of..
00002214  BC3C 0001               1316              CMP.B   #%01,D6             ; .. <EA> ~ Dn --> Dn
00002218  6700 0030               1317              BEQ     ADDWDN
0000221C  BC3C 0000               1318              CMP.B   #%00,D6
00002220  6700 003A               1319              BEQ     ADDBDN              ; == 000 at this point
00002224                          1320              
00002224  BC3C 0003               1321              CMP.B   #%011,D6            ; ADDA Word Operation <EA> -> An 
00002228  6700 00C2               1322              BEQ     ADDAW
0000222C  BC3C 0007               1323              CMP.B   #%111,D6            ; ADDA Word Operation <EA> -> An  
00002230  6700 00CE               1324              BEQ     ADDAL
00002234  6000 02B0               1325              BRA     UNKNOWN
00002238                          1326              
00002238  22FC 4144442E           1327  ADDLDN      MOVE.L  #'ADD.',(A1)+
0000223E  5841                    1328              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00002240  12FC 004C               1329              MOVE.B  #'L',(A1)+
00002244  5241                    1330              ADDQ    #1,D1               ; We added 1 byte into D1
00002246  6000 FF7E               1331              BRA ANDDN
0000224A                          1332              
0000224A  22FC 4144442E           1333  ADDWDN      MOVE.L  #'ADD.',(A1)+
00002250  5841                    1334              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00002252  12FC 0057               1335              MOVE.B  #'W',(A1)+
00002256  5241                    1336              ADDQ    #1,D1               ; We added 1 byte into D1
00002258  6000 FF6C               1337              BRA ANDDN
0000225C                          1338  
0000225C  22FC 4144442E           1339  ADDBDN      MOVE.L  #'ADD.',(A1)+
00002262  5841                    1340              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00002264  12FC 0042               1341              MOVE.B  #'B',(A1)+
00002268  5241                    1342              ADDQ    #1,D1               ; We added 1 byte into D1
0000226A  6000 FF5A               1343              BRA ANDDN  
0000226E                          1344  
0000226E  2C05                    1345  ADDEA       MOVE.L  D5,D6               ; Copy D5 into D6
00002270  CC3C 003F               1346              AND.B   #$3F,D6             ; Isolate our EA Src bits
00002274  BC3C 0039               1347              CMP.B   #$39,D6             ; Check for Illegal #$ mode
00002278  6700 026C               1348              BEQ     UNKNOWN
0000227C  CC3C 0038               1349              AND.B   #$38,D6             ; Isolate our EA Src Mode bits
00002280  BC3C 0008               1350              CMP.B   #$08,D6             ; Check for Illegal mode An
00002284  6700 0260               1351              BEQ     UNKNOWN
00002288  BC3C 0000               1352              CMP.B   #$00,D6             ; Check for Illegal mode Dn 
0000228C  6700 0258               1353              BEQ     UNKNOWN
00002290                          1354              
00002290  2C05                    1355              MOVE.L  D5,D6               ; Copy D5 into D6
00002292  EC8E                    1356              LSR.L   #6,D6               ; Shift the size bits to the far right
00002294  0206 0007               1357              ANDI.B  #$7,D6              ; Isolate the size bits    
00002298                          1358                   
00002298  BC3C 0006               1359              CMP.B   #%0110,D6           ; See if D6 is size "%100" through "%110"..
0000229C  6700 0016               1360              BEQ     ADDLEA              ; If it is, our OpCode is in the format of..
000022A0  BC3C 0005               1361              CMP.B   #%101,D6            ; .. Dn ~ <EA> --> <EA>
000022A4  6700 0020               1362              BEQ     ADDWEA
000022A8  BC3C 0004               1363              CMP.B   #%100,D6
000022AC  6700 002A               1364              BEQ     ADDBEA
000022B0                          1365              
000022B0  6000 0234               1366              BRA     UNKNOWN
000022B4                          1367  
000022B4                          1368              
000022B4  22FC 4144442E           1369  ADDLEA      MOVE.L  #'ADD.',(A1)+
000022BA  5841                    1370              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000022BC  12FC 004C               1371              MOVE.B  #'L',(A1)+
000022C0  5241                    1372              ADDQ    #1,D1               ; We added 1 byte into D1
000022C2  6000 FE96               1373              BRA     ANDEA
000022C6                          1374              
000022C6  22FC 4144442E           1375  ADDWEA      MOVE.L  #'ADD.',(A1)+
000022CC  5841                    1376              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000022CE  12FC 0057               1377              MOVE.B  #'W',(A1)+
000022D2  5241                    1378              ADDQ    #1,D1               ; We added 1 byte into D1
000022D4  6000 FE84               1379              BRA     ANDEA
000022D8                          1380  
000022D8  22FC 4144442E           1381  ADDBEA      MOVE.L  #'ADD.',(A1)+
000022DE  5841                    1382              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000022E0  12FC 0042               1383              MOVE.B  #'B',(A1)+
000022E4  5241                    1384              ADDQ    #1,D1               ; We added 1 byte into D1
000022E6  7001                    1385              MOVE.L  #1,D0               ; Move 1 into D0 to indicate bytesize
000022E8  6000 FE70               1386              BRA     ANDEA
000022EC                          1387              
000022EC  22FC 41444441           1388  ADDAW       MOVE.L  #'ADDA',(A1)+
000022F2  5841                    1389              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000022F4  32FC 2E57               1390              MOVE.W  #'.W',(A1)+
000022F8  5441                    1391              ADDQ    #2,D1               ; We added 1 byte into D1
000022FA  7002                    1392              MOVE.L  #2,D0               ; Move 2 into D0 to indicate wordsize
000022FC  6000 0016               1393              BRA     ADDAN
00002300                          1394              
00002300  22FC 41444441           1395  ADDAL       MOVE.L  #'ADDA',(A1)+
00002306  5841                    1396              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00002308  32FC 2E4C               1397              MOVE.W  #'.L',(A1)+
0000230C  5441                    1398              ADDQ    #2,D1               ; We added 1 byte into D1
0000230E  7003                    1399              MOVE.L  #3,D0               ; Move 3 into D0 to indicate longsize
00002310  6000 0002               1400              BRA     ADDAN
00002314                          1401         
00002314                          1402  ADDAN
00002314  22FC 20202020           1403              MOVE.L  #'    ',(A1)+          ; Add a spacer into our IOStringLoc
0000231A                          1404              
0000231A  5841                    1405              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
0000231C                          1406              
0000231C  2C05                    1407              MOVE.L  D5,D6               ; Copy our OpCode again
0000231E  0286 0000003F           1408              ANDI.L  #$3F,D6             ; Isolate our EA bits
00002324                          1409              
00002324  4EB9 0000250A           1410              JSR EAGETSRCEA              
0000232A                          1411              
0000232A  12FC 002C               1412              MOVE.B  #',',(A1)+
0000232E  5241                    1413              ADDQ    #1,D1
00002330                          1414              
00002330  2C05                    1415              MOVE.L  D5,D6
00002332  E08E                    1416              LSR.L   #8,D6               ; Shift our OpCode a total of 9 bits to the right
00002334  E28E                    1417              LSR.L   #1,D6               ; 
00002336  0286 00000007           1418              ANDI.L  #$07,D6             ; Isolate our data register
0000233C                          1419              
0000233C  4EB9 00002594           1420              JSR EAAN
00002342                          1421              
00002342  4E75                    1422              RTS
00002344                          1423  ; This label determines if the code is either ASd (ASR) or LSd (LSL) or ROd (ROL) 
00002344                          1424  ASLSRO
00002344  2C05                    1425              MOVE.L  D5,D6               ; Copy our OpCode
00002346  EC4E                    1426              LSR.W   #6,D6               ; Shift our size bits into place
00002348  0206 0003               1427              ANDI.B  #$03,D6             ; Isolate our size bits
0000234C  BC3C 0003               1428              CMP.B   #%11,D6             ; If our size is '11'..
00002350  6700 00E2               1429              BEQ     AASLSRO             ; ..this is an address ASLSRO
00002354                          1430              
00002354  2C05                    1431              MOVE.L  D5,D6               ; Copy our OpCode
00002356  E64E                    1432              LSR.W   #3,D6               ; Shift our identification bits over
00002358  0206 0003               1433              ANDI.B  #03,D6              ;  and isolate them
0000235C                          1434              
0000235C  BC3C 0000               1435              CMP.B   #%00,D6             ; If '00', this is a ASd op
00002360  6700 0016               1436              BEQ     ASD
00002364  BC3C 0001               1437              CMP.B   #%01,D6             ; If '01', this is a LSd op
00002368  6700 0018               1438              BEQ     LSD
0000236C  BC3C 0003               1439              CMP.B   #%11,D6             ; If '11', this is a ROd op
00002370  6700 001A               1440              BEQ     ROD
00002374                          1441              
00002374  6000 0170               1442              BRA     UNKNOWN             ; This catches for ROX, non-required op
00002378                          1443  
00002378  32FC 4153               1444  ASD         MOVE.W  #'AS',(A1)+
0000237C  5441                    1445              ADDQ    #2,D1
0000237E  6000 0016               1446              BRA     ASLSRODR
00002382                          1447              
00002382  32FC 4C53               1448  LSD         MOVE.W  #'LS',(A1)+
00002386  5441                    1449              ADDQ    #2,D1
00002388  6000 000C               1450              BRA     ASLSRODR
0000238C                          1451              
0000238C  32FC 524F               1452  ROD         MOVE.W  #'RO',(A1)+
00002390  5441                    1453              ADDQ    #2,D1
00002392  6000 0002               1454              BRA     ASLSRODR
00002396                          1455              
00002396                          1456  ; This section checks our ASd/LSd/ROd direction, and defaults to Right 
00002396  2C05                    1457  ASLSRODR    MOVE.L  D5,D6               ; Copy our OpCode
00002398  E09E                    1458              ROR.L   #8,D6               ; Shift our direction bit into place
0000239A  0806 0000               1459              BTST    #$00,D6             ; Check our right-most bit 
0000239E  6600 0010               1460              BNE     ASLSRODL            ; If it's '1', our direction is left
000023A2                          1461              
000023A2  12FC 0052               1462              MOVE.B  #'R',(A1)+          ; Otherwise it's right
000023A6  12FC 002E               1463              MOVE.B  #'.',(A1)+
000023AA  5441                    1464              ADDQ    #2,D1
000023AC                          1465              
000023AC  6000 000C               1466              BRA ASLSROSIZE
000023B0                          1467              
000023B0                          1468  ; This section is our ASd/LSd/ROd left direction
000023B0  12FC 004C               1469  ASLSRODL    MOVE.B  #'L',(A1)+          ; L for Left
000023B4  12FC 002E               1470              MOVE.B  #'.',(A1)+
000023B8  5441                    1471              ADDQ    #2,D1
000023BA                          1472              ; Carry into our Size determiner
000023BA                          1473  ; Determines what size our ASd/LSd/ROd is
000023BA                          1474  ;  Our previous operations on D6 leave our size bits
000023BA                          1475  ;  just our of range, so we shift them in
000023BA                          1476  ASLSROSIZE  
000023BA  E59E                    1477              ROL.L   #2,D6               ; Shift our size bits in
000023BC  0206 0003               1478              ANDI.B  #$03,D6             ; Isolate our size bits
000023C0  BC3C 0000               1479              CMP.B   #%00,D6             ; If our size is '00'..
000023C4  6700 0012               1480              BEQ     ASLSROB             ; ..Then it's a byte op
000023C8  BC3C 0001               1481              CMP.B   #%01,D6             ; If our size is '01'..
000023CC  6700 0012               1482              BEQ     ASLSROW             ; ..Then it's a word op
000023D0                          1483              ; Otherwise it's a long op, because we accounted for '11' earlier
000023D0                          1484              
000023D0  12FC 004C               1485              MOVE.B  #'L',(A1)+          ; Add L for Long
000023D4  6000 000E               1486              BRA     ASLSROIR            ; Complete the rest of the ASLSRO Op
000023D8                          1487              
000023D8  12FC 0042               1488  ASLSROB     MOVE.B  #'B',(A1)+          ; Add B for Byte
000023DC  6000 0006               1489              BRA     ASLSROIR            ; Complete the rest of the ASLSRO Op
000023E0                          1490              
000023E0  12FC 0057               1491  ASLSROW     MOVE.B  #'W',(A1)+          ; Add W for Word
000023E4                          1492              ; Carry through to complete the rest of the ASLSRO Op  
000023E4                          1493       
000023E4                          1494  ; This section determines if our ASLSRO is an Immediate or Dn shfit, and defaults to Immediate
000023E4  12FC 0020               1495  ASLSROIR    MOVE.B  #' ',(A1)+
000023E8  32FC 2020               1496              MOVE.W  #'  ',(A1)+
000023EC  32FC 2020               1497              MOVE.W  #'  ',(A1)+
000023F0  5C41                    1498              ADDQ    #6,D1               ; We've added 5 new characters (Size char, plus spaces)
000023F2                          1499              
000023F2                          1500              ;MOVE.L  D5,D6
000023F2  E39E                    1501              ROL.L   #1,D6               ; Get our Immediate / Register bit out front
000023F4  0806 0000               1502              BTST.L  #$00,D6
000023F8  6600 000C               1503              BNE     ASLSROIRDN          ; If it's '1', we have a Dn ASLSRO
000023FC                          1504              ; Otherwise, assume immediate ASLSRO
000023FC  12FC 0023               1505              MOVE.B  #'#',(A1)+
00002400  5241                    1506              ADDQ    #1,D1
00002402  6000 0008               1507              BRA     ASLSROOP            ; Branch to our ASLSRO Op finish
00002406                          1508  ; An ASLSRO of Dn Register type   
00002406  12FC 0044               1509  ASLSROIRDN  MOVE.B  #'D',(A1)+
0000240A  5241                    1510              ADDQ    #1,D1
0000240C                          1511              ; Continue through to our ASLSRO Op finish
0000240C                          1512  ; Finishes the ASLSRO Op
0000240C                          1513  ASLSROOP
0000240C  2C05                    1514              MOVE.L  D5,D6               ; Copy our OpCode into D6
0000240E  E09E                    1515              ROR.L   #8,D6               ; Shift our Count/Reg bits into place
00002410  E29E                    1516              ROR.L   #1,D6               ;
00002412  0206 0007               1517              ANDI.B  #$07,D6             ; Isolate the Count/Reg bits
00002416                          1518              
00002416  0606 0030               1519              ADDI.B  #48,D6 
0000241A  12C6                    1520              MOVE.B  D6,(A1)+            ; Push our number to the IOStringLoc
0000241C  5241                    1521              ADDQ    #1,D1
0000241E                          1522              
0000241E  12FC 002C               1523              MOVE.B  #',',(A1)+
00002422  5241                    1524              ADDQ    #1,D1
00002424                          1525              
00002424  2C05                    1526              MOVE.L  D5,D6               ; Isolate our Dn affected num bits
00002426  0286 00000007           1527              ANDI.L  #$07,D6             ;
0000242C  4EB9 00002586           1528              JSR     EADN
00002432                          1529              
00002432  4E75                    1530              RTS
00002434                          1531  ; Start of the Effective Address version of ASLSRO
00002434  2C05                    1532  AASLSRO     MOVE.L  D5,D6               ; Copy our OpCode into D6
00002436  CCBC 0000003F           1533              AND.L   #$3F,D6             ; Isolate the EA Srcs bits
0000243C  BC3C 0039               1534              CMP.B   #$39,D6             ; Check for illegal #$ mode
00002440  6700 00A4               1535              BEQ     UNKNOWN
00002444  CCBC 00000038           1536              AND.L   #$38,D6             ; Isolate the EA src mode bits
0000244A  BC3C 0008               1537              CMP.B   #$08,D6             ; Check for illegal An Mode
0000244E  6700 0096               1538              BEQ     UNKNOWN
00002452  BC3C 0000               1539              CMP.B   #$00,D6             ; Check for illegal Dn mode
00002456  6700 008E               1540              BEQ     UNKNOWN
0000245A                          1541              
0000245A                          1542  
0000245A  2C05                    1543              MOVE.L  D5,D6               ; Copy our OpCode into D6
0000245C  EF5E                    1544              ROL.W   #7,D6               ; Shift our determination bits to the far right
0000245E  0206 0007               1545              ANDI.B  #$07,D6             ; Isolate the determination bits   
00002462                          1546              
00002462  BC3C 0001               1547              CMP.B   #$01,D6             ; If our determination is '001'..
00002466  6700 0020               1548              BEQ     ALSD                ; It's a Logical Shift
0000246A  BC3C 0003               1549              CMP.B   #$03,D6             ; If it's '011'
0000246E  6700 0022               1550              BEQ     AROD                ; It's a Rotation 
00002472  BC3C 0000               1551              CMP.B   #$00,D6             ; If it's '000'
00002476  6700 0006               1552              BEQ     AASD                ; It's an Arithmetic Shift
0000247A                          1553              
0000247A  6000 006A               1554              BRA     UNKNOWN              ; Otherwise it's data
0000247E                          1555  
0000247E  32FC 4153               1556  AASD        MOVE.W  #'AS',(A1)+
00002482  5441                    1557              ADDQ    #2,D1
00002484  6000 0016               1558              BRA     AASLSRODR
00002488                          1559              
00002488  32FC 4C53               1560  ALSD        MOVE.W  #'LS',(A1)+
0000248C  5441                    1561              ADDQ    #2,D1
0000248E  6000 000C               1562              BRA     AASLSRODR
00002492                          1563              
00002492  32FC 524F               1564  AROD        MOVE.W  #'RO',(A1)+
00002496  5441                    1565              ADDQ    #2,D1
00002498  6000 0002               1566              BRA     AASLSRODR
0000249C                          1567              
0000249C                          1568  ; This section checks our ASd/LSd/ROd direction, and defaults to Right 
0000249C  2C05                    1569  AASLSRODR   MOVE.L  D5,D6              ; Copy our OpCode
0000249E  E09E                    1570              ROR.L   #8,D6               ; Shift our direction bit into place
000024A0  0806 0000               1571              BTST    #$00,D6             ; Check our right-most bit 
000024A4  6600 000C               1572              BNE     AASLSRODL           ; If it's '1', our direction is left
000024A8                          1573              
000024A8  12FC 0052               1574              MOVE.B  #'R',(A1)+          ; Otherwise it's right
000024AC  5241                    1575              ADDQ    #1,D1
000024AE                          1576              
000024AE  6000 0008               1577              BRA AASLSROOP
000024B2                          1578              
000024B2                          1579  ; This section is our ASd/LSd/ROd left direction
000024B2  12FC 004C               1580  AASLSRODL   MOVE.B  #'L',(A1)+          ; L for Left
000024B6  5241                    1581              ADDQ    #1,D1
000024B8                          1582              ; Carry into finishing AASLSRO op
000024B8                          1583  
000024B8                          1584  ; This section finishes off our Effective Address ASLSRO Op
000024B8  2C05                    1585  AASLSROOP   MOVE.L  D5,D6               ; Copy our OpCode
000024BA  0286 0000003F           1586              ANDI.L  #$3F,D6             ; Isolate our EA bits
000024C0                          1587              
000024C0  12FC 002E               1588              MOVE.B  #'.',(A1)+
000024C4  12FC 0057               1589              MOVE.B  #'W',(A1)+
000024C8  12FC 0020               1590              MOVE.B  #' ',(A1)+
000024CC  12FC 0020               1591              MOVE.B  #' ',(A1)+
000024D0  12FC 0020               1592              MOVE.B  #' ',(A1)+
000024D4  12FC 0020               1593              MOVE.B  #' ',(A1)+
000024D8  12FC 0020               1594              MOVE.B  #' ',(A1)+
000024DC  5E41                    1595              ADDQ    #7,D1
000024DE                          1596              
000024DE  4EB9 0000250A           1597              JSR EAGETSRCEA
000024E4                          1598              
000024E4  4E75                    1599              RTS
000024E6                          1600  UNKNOWN
000024E6  22FC 44415441           1601              MOVE.L  #'DATA',(A1)+
000024EC  5841                    1602              ADDQ    #4,D1           ; We added 4 new characters to our IOStringLoc 
000024EE                          1603              
000024EE  22FC 20202020           1604              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
000024F4  32FC 2020               1605              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
000024F8  5C41                    1606              ADDQ    #6,D1               ; We added 6 bytes, aka 6 spaces
000024FA                          1607              
000024FA  12FC 0024               1608              MOVE.B  #'$',(A1)+
000024FE  5241                    1609              ADDQ    #1,D1
00002500                          1610              
00002500  2C05                    1611              MOVE.L  D5,D6
00002502  4EB9 00002664           1612              JSR     EAHEXtoASCII
00002508                          1613              
00002508  4E75                    1614              RTS
0000250A                          1615  
0000250A                          1616  
0000250A                          1617  
0000250A                          1618  
0000250A                          1619  
0000250A                          1620  
0000250A                          1621  
0000250A                          1622  
0000250A                          1623  
0000250A                          1624  
0000250A                          1625  
0000250A                          1626  
0000250A                          1627  
0000250A                          1628  
0000250A                          1629  
0000250A                          1630  
0000250A                          1631  -------------------- end include --------------------
0000250A                          1632      INCLUDE "EA.X68"        ; Handles EA types
0000250A                          1633  
0000250A                          1634  
0000250A                          1635  ; It is assumed that D6 contains the bits for the EA, algined to the far right. D5 contains
0000250A                          1636  ;  the original full op-code being reffered to. We assume that A2 contains the address 
0000250A                          1637  ;  pointing to the start of our EA address (if applicable), and we assume that A1 contains
0000250A                          1638  ;  the address pointing to our IOStringLoc. D1 contains the current length to be printed from A1
0000250A                          1639  
0000250A                          1640  ; For this method, D6 is in the format of: <3 bits Src Mode><3 bits Src Reg> 
0000250A                          1641  EAGETSRCEA  
0000250A  E69E                    1642      ROR.L   #3,D6       ; Rotate our bits 3 to the right
0000250C  1E06                    1643      MOVE.B  D6,D7       ; Store the mode of the EA in D7
0000250E  E79E                    1644      ROL.L   #3,D6       ; Rotate our 3 bits back
00002510  0286 00000007           1645      ANDI.L  #$0007,D6   ; Isolate the 3 rightmost bits as 'Reg'
00002516  BE3C 0000               1646      CMP.B   #0,D7       ; See if the mode == '000'
0000251A  6700 006A               1647      BEQ     EADN
0000251E                          1648  
0000251E  BE3C 0001               1649      CMP.B   #1,D7       ; See if the mode == '001'
00002522  6700 0070               1650      BEQ     EAAN        ; Address Register Direct
00002526                          1651      
00002526  BE3C 0002               1652      CMP.B   #2,D7       ; See if the mode == '010'
0000252A  6700 0076               1653      BEQ     EAANI       ; Address Register Indirect
0000252E                          1654      
0000252E  BE3C 0003               1655      CMP.B   #3,D7       ; See if the mode == '011'
00002532  6700 0084               1656      BEQ     EAAPOST     ; Address Register Indirect with Post increment
00002536                          1657      
00002536  BE3C 0004               1658      CMP.B   #4,D7       ; See if the mode == '100'
0000253A  6700 0096               1659      BEQ     EAAPRE      ; Address Register Indirect with Pre increment
0000253E                          1660      
0000253E  BE3C 0007               1661      CMP.B   #7,D7       ; See if the mode == '111' 
00002542  6700 010A               1662      BEQ     EA111       ; Determine if (Immediate Data, Aboslute Word or Long Address)
00002546                          1663  
00002546  6000 0360               1664      BRA     EAUNKN
0000254A                          1665  
0000254A                          1666  ; For this method, D6 is in the format of: <3 bits Dst Reg><3 bits Dst Mode> 
0000254A                          1667  EAGETDSTEA  
0000254A  1E06                    1668      MOVE.B  D6,D7       ; Store the right-most byte into D7
0000254C  CE3C 0007               1669      AND.B   #$07,D7     ; Isolate 3 rightmost bits as 'Mode'
00002550  E68E                    1670      LSR.L   #3,D6       ; Shift D6 to the right 3 bits (D6 Byte = 'Reg')
00002552  BE3C 0000               1671      CMP.B   #0,D7       ; See if the mode == '000'
00002556  6700 002E               1672      BEQ     EADN
0000255A                          1673  
0000255A  BE3C 0001               1674      CMP.B   #1,D7       ; See if the mode == '001'
0000255E  6700 0034               1675      BEQ     EAAN        ; Address Register Direct
00002562                          1676      
00002562  BE3C 0002               1677      CMP.B   #2,D7       ; See if the mode == '010'
00002566  6700 003A               1678      BEQ     EAANI       ; Address Register Indirect
0000256A                          1679      
0000256A  BE3C 0003               1680      CMP.B   #3,D7       ; See if the mode == '011'
0000256E  6700 0048               1681      BEQ     EAAPOST     ; Address Register Indirect with Post increment
00002572                          1682      
00002572  BE3C 0004               1683      CMP.B   #4,D7       ; See if the mode == '100'
00002576  6700 005A               1684      BEQ     EAAPRE      ; Address Register Indirect with Pre increment
0000257A                          1685      
0000257A  BE3C 0007               1686      CMP.B   #7,D7       ; See if the mode == '111' 
0000257E  6700 00CE               1687      BEQ     EA111       ; Determine if (Immediate Data, Aboslute Word or Long Address)
00002582                          1688  
00002582  6000 0324               1689      BRA     EAUNKN
00002586                          1690           
00002586                          1691  ;If the EA is a Dn EA    
00002586                          1692  ;This method assume D6 contains the Reg for Dn  
00002586                          1693  EADN
00002586  12FC 0044               1694      MOVE.B  #'D',(A1)+
0000258A  0606 0030               1695      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
0000258E  12C6                    1696      MOVE.B  D6,(A1)+
00002590  5441                    1697      ADDQ    #2,D1
00002592  4E75                    1698      RTS
00002594                          1699  ;If the EA is a An EA    
00002594                          1700  ;This method assume D6 contains the Reg for An  
00002594                          1701  EAAN
00002594  12FC 0041               1702      MOVE.B  #'A',(A1)+
00002598  0606 0030               1703      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
0000259C  12C6                    1704      MOVE.B  D6,(A1)+
0000259E  5441                    1705      ADDQ    #2,D1
000025A0  4E75                    1706      RTS
000025A2                          1707  
000025A2                          1708  ;If the EA is a (An) EA    
000025A2                          1709  ;This method assume D6 contains the Reg for (An)  
000025A2                          1710  EAANI
000025A2  12FC 0028               1711      MOVE.B  #'(',(A1)+
000025A6  12FC 0041               1712      MOVE.B  #'A',(A1)+
000025AA  0606 0030               1713      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
000025AE  12C6                    1714      MOVE.B  D6,(A1)+
000025B0  12FC 0029               1715      MOVE.B  #')',(A1)+
000025B4  5841                    1716      ADDQ    #4,D1
000025B6  4E75                    1717      RTS
000025B8                          1718  ;If the EA is a (An)+ EA    
000025B8                          1719  ;This method assume D6 contains the Reg for (An)+  
000025B8                          1720  EAAPOST
000025B8  12FC 0028               1721      MOVE.B  #'(',(A1)+
000025BC  12FC 0041               1722      MOVE.B  #'A',(A1)+
000025C0  0606 0030               1723      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
000025C4  12C6                    1724      MOVE.B  D6,(A1)+
000025C6  12FC 0029               1725      MOVE.B  #')',(A1)+
000025CA  12FC 002B               1726      MOVE.B  #'+',(A1)+
000025CE  5A41                    1727      ADDQ    #5,D1
000025D0  4E75                    1728      RTS
000025D2                          1729  ;If the EA is a -(An) EA    
000025D2                          1730  ;This method assume D6 contains the Reg for -(An) 
000025D2                          1731  EAAPRE
000025D2  12FC 002D               1732      MOVE.B  #'-',(A1)+
000025D6  12FC 0028               1733      MOVE.B  #'(',(A1)+
000025DA  12FC 0041               1734      MOVE.B  #'A',(A1)+
000025DE  0606 0030               1735      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
000025E2  12C6                    1736      MOVE.B  D6,(A1)+
000025E4  12FC 0029               1737      MOVE.B  #')',(A1)+
000025E8  5A41                    1738      ADDQ    #5,D1
000025EA  4E75                    1739      RTS 
000025EC                          1740  ;If the EA is a #<data> EA    
000025EC                          1741  ;This method assume D6 contains the Reg for #<data>  
000025EC                          1742  EAID
000025EC  32FC 2324               1743      MOVE.W  #'#$',(A1)+
000025F0  5441                    1744      ADDQ    #2,D1
000025F2  B03C 0002               1745      CMP.B   #2,D0
000025F6  6E00 000E               1746      BGT     EAIDL
000025FA  3C1A                    1747      MOVE.W  (A2)+,D6
000025FC  4244                    1748      CLR     D4
000025FE  4EB9 00002664           1749      JSR     EAHEXtoASCII
00002604  4E75                    1750      RTS
00002606                          1751      
00002606                          1752  ;If the EA is a #<data> EA    
00002606                          1753  ;This method assume D6 contains the Reg for #<data> of size Long
00002606                          1754  EAIDL
00002606  2C1A                    1755      MOVE.L  (A2)+,D6
00002608  4244                    1756      CLR     D4
0000260A  4846                    1757      SWAP    D6
0000260C  4EB9 00002664           1758      JSR     EAHEXtoASCII
00002612  4846                    1759      SWAP    D6
00002614  4244                    1760      CLR     D4
00002616  4EB9 00002664           1761      JSR     EAHEXtoASCII
0000261C  4E75                    1762      RTS
0000261E                          1763  
0000261E                          1764  ;If the EA is a (xxx).W EA    
0000261E                          1765  ;This method assume D6 contains the Reg for (xxx).W  
0000261E                          1766  EAAWA
0000261E  12FC 0024               1767      MOVE.B  #'$',(A1)+
00002622  5241                    1768      ADDQ    #1,D1
00002624  3C1A                    1769      MOVE.W  (A2)+,D6   ; Push our next Word value into D6
00002626                          1770      ; Push the ASCII equivlent characters of D6-- only the
00002626                          1771      ;   first Word's worth (our entire Word we just acquired)
00002626  4244                    1772      CLR     D4
00002628  4EB9 00002664           1773      JSR     EAHEXtoASCII
0000262E                          1774      
0000262E  4E75                    1775      RTS
00002630                          1776  ;If the EA is a (xxx).L EA    
00002630                          1777  ;This method assume D6 contains the Reg for (xxx).L  
00002630                          1778  EAALA
00002630  12FC 0024               1779      MOVE.B  #'$',(A1)+
00002634  5241                    1780      ADDQ    #1,D1
00002636  2C1A                    1781      MOVE.L  (A2)+,D6   ; Push our next Long value into D6
00002638                          1782      ; Push the ASCII equivlent characters of D6-- only the
00002638                          1783      ;   first Word's worth of our Long
00002638  4244                    1784      CLR     D4         ; Clear our counter
0000263A  4846                    1785      SWAP    D6         ; Flip the high-order Word with the Low-order
0000263C  4EB9 00002664           1786      JSR     EAHEXtoASCII
00002642  4846                    1787      SWAP    D6         ; Flip the high-order Word with the Low-order
00002644                          1788      ; Print the second half of the Long, too
00002644  4244                    1789      CLR     D4
00002646  4EB9 00002664           1790      JSR     EAHEXtoASCII
0000264C                          1791      
0000264C  4E75                    1792      RTS
0000264E                          1793  ;If the EA Mode = 111, Determine EA    
0000264E                          1794  ;This method assume D6 contains the Reg for EA  
0000264E                          1795  EA111
0000264E  BC3C 0000               1796      CMP.B #0,D6
00002652  67CA                    1797      BEQ     EAAWA       ; Absolute Word Address 
00002654  BC3C 0001               1798      CMP.B #1,D6
00002658  67D6                    1799      BEQ     EAALA       ; Absolute Long Address 
0000265A  BC3C 0004               1800      CMP.B #4,D6
0000265E  678C                    1801      BEQ     EAID        ; Immediate Data 
00002660                          1802      *-----------------------------------------------let fall through? it shouldn't RTS right?
00002660  6000 0246               1803      BRA     EAUNKN
00002664                          1804      
00002664                          1805  ; Uses D6 as a storage, D3 as a go-between, and D4 as a counter..
00002664                          1806  ;  This operates on the low-order word of D6, and pushes exactly 4 
00002664                          1807  ;  characters into IOStringLoc, converted from HEX of D6's nybble,
00002664                          1808  ;  to ASCII in IOStringLoc
00002664  5244                    1809  EAHEXtoASCII    ADDQ    #1,D4
00002666  E95E                    1810                  ROL.W   #4,D6              Get the left-most nyblle to the front..
00002668  1606                    1811                  MOVE.B  D6,D3              .. Put the front-most byte into D3    
0000266A  C63C 000F               1812                  AND.B   #$0F,D3            Distill D3 down to the original left-most nybble
0000266E  B63C 0009               1813                  CMP.B   #9,D3              See if our number is greater than 9..
00002672  6F00 0004               1814                  BLE     EADIGIT            If it is 9 or less, it's a digit..
00002676  5E03                    1815                  ADD.B   #7,D3              Otherwise it is a digit, and needs an additional 7
00002678  0603 0030               1816  EADIGIT         ADD.B   #48,D3             We now have the nybble's ASCII code
0000267C  12C3                    1817                  MOVE.B  D3,(A1)+           Move the ASCII code into the output string at A1
0000267E  B83C 0004               1818                  CMP.B   #4,D4              See if we've read all the characters
00002682  66E0                    1819                  BNE.S   EAHEXtoASCII       Continue if we haven't
00002684                          1820                  
00002684  5841                    1821                  ADDQ    #4,D1
00002686  4E75                    1822                  RTS
00002688                          1823      
00002688                          1824  
00002688                          1825  ; MOVEM's (A7)+,A0-A6,D0-D7 format
00002688                          1826  ; Gets the follow-up WORD in order to process it
00002688                          1827  EAMOVEMPOSTI ; Initilize variables for An and MOVEM
00002688  3A1A                    1828      MOVE.W  (A2)+,D5
0000268A  2C05                    1829      MOVE.L  D5,D6
0000268C  EE9E                    1830      ROR.L   #7,D6                   ; Rotate our A bits to the front
0000268E  4240                    1831      CLR     D0
00002690  4247                    1832      CLR     D7
00002692  2E3C 000000FF           1833      MOVE.L  #$FF,D7                 ; Initlize our D7 to -1 
00002698                          1834  EAMOVEMPOSTIAN
00002698  4EB9 00002762           1835      JSR     EAMOVEMPOSTILOOPSTART   ; Find our starting An
0000269E  BE7C 0008               1836      CMP     #8,D7
000026A2  6C00 0052               1837      BGE     EAMOVEMPOSTIANEND       ; If A8, branch to AnEnd
000026A6  4EB9 0000278C           1838      JSR     EAMOVEMSLASH            ; Add a slash, if we need to
000026AC                          1839      
000026AC  12FC 0041               1840      MOVE.B  #'A',(A1)+
000026B0  0647 0030               1841      ADD.W   #48,D7                  ; Convert D7 to ASCII equivlent
000026B4  12C7                    1842      MOVE.B  D7,(A1)+
000026B6  5441                    1843      ADDQ    #2,D1                   ; Add our number into IOStringLoc
000026B8  0447 002F               1844      SUB     #47,D7                  ; Equilize D7
000026BC                          1845      
000026BC                          1846      ; Check immediately next number to see if there is an ending
000026BC  103C 0001               1847      MOVE.B  #1,D0                   ; Set our slash equal to TRUE
000026C0  BE7C 0008               1848      CMP     #8,D7
000026C4  6C00 0030               1849      BGE     EAMOVEMPOSTIANEND       ; If A8, branch to AnEnd
000026C8  E29E                    1850      ROR.L   #1,D6                   ; See if our next bit is set
000026CA  0806 0000               1851      BTST    #$00,D6                 ; If it isn't set, we have no '-An'..
000026CE  67C8                    1852      BEQ     EAMOVEMPOSTIAN          ; .. Look for our next /An
000026D0                          1853      
000026D0  4EB9 00002776           1854      JSR     EAMOVEMPOSTILOOPEND
000026D6  BE7C 0008               1855      CMP     #8,D7
000026DA  6C00 001A               1856      BGE     EAMOVEMPOSTIANEND       ; If A8, branch to AnEnd
000026DE  12FC 002D               1857      MOVE.B  #'-',(A1)+
000026E2  12FC 0041               1858      MOVE.B  #'A',(A1)+
000026E6  0647 0030               1859      ADD.W    #48,D7                  ; Convert D7 to ASCII equivlent
000026EA  12C7                    1860      MOVE.B  D7,(A1)+
000026EC  5641                    1861      ADDQ    #3,D1                   ; Add our number into IOStringLoc
000026EE  0447 0030               1862      SUB     #48,D7                  ; Equilize D7
000026F2                          1863      
000026F2  5247                    1864      ADDQ    #1,D7                   ; Account for our extra rotation in LoopEnd
000026F4  60A2                    1865      BRA     EAMOVEMPOSTIAN
000026F6                          1866      
000026F6                          1867  EAMOVEMPOSTIANEND ; Initilize variables for Dn
000026F6  2C05                    1868      MOVE.L  D5,D6
000026F8  4247                    1869      CLR     D7
000026FA  2E3C 000000FF           1870      MOVE.L  #$FF,D7                 ; Initlize our D7 to -1 
00002700  E39E                    1871      ROL.L   #1,D6                   ; Initlize our mask to -1
00002702                          1872  EAMOVEMPOSTIDN
00002702  4EB9 00002762           1873      JSR     EAMOVEMPOSTILOOPSTART   ; Find our starting Dn
00002708  BE7C 0008               1874      CMP     #8,D7
0000270C  6C00 0052               1875      BGE     EAMOVEMPOSTIEND         ; If D8, branch to End
00002710  4EB9 0000278C           1876      JSR     EAMOVEMSLASH            ; Add a slash, if we need to
00002716                          1877      
00002716  12FC 0044               1878      MOVE.B  #'D',(A1)+
0000271A  0647 0030               1879      ADD.W   #48,D7                  ; Convert D7 to ASCII equivlent
0000271E  12C7                    1880      MOVE.B  D7,(A1)+
00002720  5441                    1881      ADDQ    #2,D1                   ; Add our number into IOStringLoc
00002722  0447 002F               1882      SUB     #47,D7                  ; Equilize D7
00002726                          1883      
00002726                          1884      ; Check immediately next number to see if there is an ending
00002726  103C 0001               1885      MOVE.B  #1,D0                   ; Set our slash equal to TRUE
0000272A  BE7C 0008               1886      CMP     #8,D7
0000272E  6C00 0030               1887      BGE     EAMOVEMPOSTIEND         ; If D8, branch to End
00002732  E29E                    1888      ROR.L   #1,D6                   ; See if our next bit is set
00002734  0806 0000               1889      BTST    #$00,D6                 ; If it isn't set, we have no '-Dn'..
00002738  67C8                    1890      BEQ     EAMOVEMPOSTIDN          ; .. Look for our next /Dn
0000273A                          1891      
0000273A  4EB9 00002776           1892      JSR     EAMOVEMPOSTILOOPEND
00002740  BE7C 0008               1893      CMP     #8,D7
00002744  6C00 001A               1894      BGE     EAMOVEMPOSTIEND         ; If D8, branch to End
00002748  12FC 002D               1895      MOVE.B  #'-',(A1)+
0000274C  12FC 0044               1896      MOVE.B  #'D',(A1)+
00002750  0647 0030               1897      ADD.W    #48,D7                  ; Convert D7 to ASCII equivlent
00002754  12C7                    1898      MOVE.B  D7,(A1)+
00002756  5641                    1899      ADDQ    #3,D1                   ; Add our number into IOStringLoc
00002758  0447 0030               1900      SUB     #48,D7                  ; Equilize D7
0000275C                          1901      
0000275C  5247                    1902      ADDQ    #1,D7                   ; Account for our extra rotation in LoopEnd
0000275E  60A2                    1903      BRA     EAMOVEMPOSTIDN
00002760                          1904  
00002760                          1905  EAMOVEMPOSTIEND
00002760  4E75                    1906      RTS
00002762                          1907      
00002762                          1908  EAMOVEMPOSTILOOPSTART
00002762  5207                    1909      ADDQ.B  #1,D7       ; Itterate D7
00002764  E29E                    1910      ROR.L   #1,D6       ; Rotate one bit to the right  
00002766  BE3C 0008               1911      CMP.B   #8,D7       ; Check if we've hit A8
0000276A  6C00 0030               1912      BGE     EAMOVEMSLASHEND      ; If we have, break the loop
0000276E  0806 0000               1913      BTST    #$00,D6     ; Check the far right bit
00002772  67EE                    1914      BEQ     EAMOVEMPOSTILOOPSTART       ; If it is 0, continue checking 
00002774  4E75                    1915      RTS
00002776                          1916      
00002776                          1917  EAMOVEMPOSTILOOPEND
00002776  5207                    1918      ADDQ.B  #1,D7       ; Itterate D7
00002778  E29E                    1919      ROR.L   #1,D6       ; Rotate one bit to the right  
0000277A  BE3C 0009               1920      CMP.B   #9,D7       ; Check if we've hit A8
0000277E  6C00 001C               1921      BGE     EAMOVEMSLASHEND      ; If we have, break the loop
00002782  0806 0000               1922      BTST    #$00,D6     ; Check the far right bit
00002786  66EE                    1923      BNE     EAMOVEMPOSTILOOPEND       ; If it isn't 0, continue checking 
00002788  5347                    1924      SUBQ    #1,D7
0000278A  4E75                    1925      RTS
0000278C                          1926      
0000278C                          1927  EAMOVEMSLASH
0000278C  B07C 0001               1928      CMP     #1,D0       ; If D0 != 1
00002790  6600 000A               1929      BNE     EAMOVEMSLASHEND  ; RTS
00002794  4240                    1930      CLR     D0          ; Reset our slash
00002796  12FC 002F               1931      MOVE.B  #'/',(A1)+  ; Otherwise Add a slash
0000279A  5241                    1932      ADDQ    #1,D1  
0000279C                          1933  EAMOVEMSLASHEND     
0000279C  4E75                    1934      RTS
0000279E                          1935      
0000279E                          1936  ; MOVEM's A0-A6,D0-D7,-(An) format
0000279E                          1937  ; Gets the follow-up WORD in order to process it
0000279E                          1938  EAMOVEMPRED ; Initilize variables for An and MOVEM
0000279E  48E7 0400               1939      MOVEM.L D5,-(SP)                ; Save our original OpCode for later
000027A2  3A1A                    1940      MOVE.W  (A2)+,D5
000027A4  2C05                    1941      MOVE.L  D5,D6
000027A6  E09E                    1942      ROR.L   #8,D6                   ; Rotate our A bits to the front
000027A8  4240                    1943      CLR     D0
000027AA  4247                    1944      CLR     D7
000027AC  2E3C 000000FF           1945      MOVE.L  #$FF,D7                 ; Initlize our D7 to -1 
000027B2                          1946  EAMOVEMPREDAN
000027B2  4EB9 0000287E           1947      JSR     EAMOVEMPREDLOOPSTART    ; Find our starting An
000027B8  BE7C 0008               1948      CMP     #8,D7
000027BC  6C00 0050               1949      BGE     EAMOVEMPREDANEND        ; If A8, branch to AnEnd
000027C0  4EB8 278C               1950      JSR     EAMOVEMSLASH            ; Add a slash, if we need to
000027C4                          1951      
000027C4  12FC 0041               1952      MOVE.B  #'A',(A1)+
000027C8  0647 0030               1953      ADD.W   #48,D7                  ; Convert D7 to ASCII equivlent
000027CC  12C7                    1954      MOVE.B  D7,(A1)+
000027CE  5441                    1955      ADDQ    #2,D1                   ; Add our number into IOStringLoc
000027D0  0447 002F               1956      SUB     #47,D7                  ; Equilize D7
000027D4                          1957      
000027D4                          1958      ; Check immediately next number to see if there is an ending
000027D4  103C 0001               1959      MOVE.B  #1,D0                   ; Set our slash equal to TRUE
000027D8  BE7C 0008               1960      CMP     #8,D7
000027DC  6C00 0030               1961      BGE     EAMOVEMPREDANEND        ; If A8, branch to AnEnd
000027E0  E39E                    1962      ROL.L   #1,D6                   ; See if our next bit is set
000027E2  0806 0000               1963      BTST    #$00,D6                 ; If it isn't set, we have no '-An'..
000027E6  67CA                    1964      BEQ     EAMOVEMPREDAN           ; .. Look for our next /An
000027E8                          1965      
000027E8  4EB9 00002892           1966      JSR     EAMOVEMPREDLOOPEND
000027EE  BE7C 0008               1967      CMP     #8,D7
000027F2  6C00 001A               1968      BGE     EAMOVEMPREDANEND        ; If A8, branch to AnEnd
000027F6  12FC 002D               1969      MOVE.B  #'-',(A1)+
000027FA  12FC 0041               1970      MOVE.B  #'A',(A1)+
000027FE  0647 0030               1971      ADD.W    #48,D7                 ; Convert D7 to ASCII equivlent
00002802  12C7                    1972      MOVE.B  D7,(A1)+
00002804  5641                    1973      ADDQ    #3,D1                   ; Add our number into IOStringLoc
00002806  0447 0030               1974      SUB     #48,D7                  ; Equilize D7
0000280A                          1975      
0000280A  5247                    1976      ADDQ    #1,D7                   ; Account for our extra rotation in LoopEnd
0000280C  60A4                    1977      BRA     EAMOVEMPREDAN
0000280E                          1978      
0000280E                          1979  EAMOVEMPREDANEND ; Initilize variables for Dn
0000280E  2C05                    1980      MOVE.L  D5,D6
00002810  4247                    1981      CLR     D7
00002812  2E3C 000000FF           1982      MOVE.L  #$FF,D7                 ; Initlize our D7 to -1 
00002818  E19E                    1983      ROL.L   #8,D6                   ; Initlize our mask to -1
0000281A  E19E                    1984      ROL.L   #8,D6                   ;
0000281C                          1985  EAMOVEMPREDDN
0000281C  4EB9 0000287E           1986      JSR     EAMOVEMPREDLOOPSTART   ; Find our starting Dn
00002822  BE7C 0008               1987      CMP     #8,D7
00002826  6C00 0050               1988      BGE     EAMOVEMPREDEND          ; If D8, branch to End
0000282A  4EB8 278C               1989      JSR     EAMOVEMSLASH            ; Add a slash, if we need to
0000282E                          1990      
0000282E  12FC 0044               1991      MOVE.B  #'D',(A1)+
00002832  0647 0030               1992      ADD.W   #48,D7                  ; Convert D7 to ASCII equivlent
00002836  12C7                    1993      MOVE.B  D7,(A1)+
00002838  5441                    1994      ADDQ    #2,D1                   ; Add our number into IOStringLoc
0000283A  0447 002F               1995      SUB     #47,D7                  ; Equilize D7
0000283E                          1996      
0000283E                          1997      ; Check immediately next number to see if there is an ending
0000283E  103C 0001               1998      MOVE.B  #1,D0                   ; Set our slash equal to TRUE
00002842  BE7C 0008               1999      CMP     #8,D7
00002846  6C00 0030               2000      BGE     EAMOVEMPREDEND          ; If D8, branch to End
0000284A  E39E                    2001      ROL.L   #1,D6                   ; See if our next bit is set
0000284C  0806 0000               2002      BTST    #$00,D6                 ; If it isn't set, we have no '-Dn'..
00002850  67CA                    2003      BEQ     EAMOVEMPREDDN           ; .. Look for our next /Dn
00002852                          2004      
00002852  4EB9 00002892           2005      JSR     EAMOVEMPREDLOOPEND
00002858  BE7C 0008               2006      CMP     #8,D7
0000285C  6C00 001A               2007      BGE     EAMOVEMPREDEND          ; If D8, branch to End
00002860  12FC 002D               2008      MOVE.B  #'-',(A1)+
00002864  12FC 0044               2009      MOVE.B  #'D',(A1)+
00002868  0647 0030               2010      ADD.W   #48,D7                  ; Convert D7 to ASCII equivlent
0000286C  12C7                    2011      MOVE.B  D7,(A1)+
0000286E  5641                    2012      ADDQ    #3,D1                   ; Add our number into IOStringLoc
00002870  0447 0030               2013      SUB     #48,D7                  ; Equilize D7
00002874                          2014      
00002874  5247                    2015      ADDQ    #1,D7                   ; Account for our extra rotation in LoopEnd
00002876  60A4                    2016      BRA     EAMOVEMPREDDN
00002878                          2017  
00002878                          2018  EAMOVEMPREDEND
00002878  4CDF 0020               2019      MOVEM.L (SP)+,D5
0000287C  4E75                    2020      RTS
0000287E                          2021      
0000287E                          2022  EAMOVEMPREDLOOPSTART
0000287E  5207                    2023      ADDQ.B  #1,D7       ; Itterate D7
00002880  E39E                    2024      ROL.L   #1,D6       ; Rotate one bit to the right  
00002882  BE3C 0008               2025      CMP.B   #8,D7       ; Check if we've hit A8
00002886  6C00 FF14               2026      BGE     EAMOVEMSLASHEND      ; If we have, break the loop
0000288A  0806 0000               2027      BTST    #$00,D6     ; Check the far right bit
0000288E  67EE                    2028      BEQ     EAMOVEMPREDLOOPSTART       ; If it is 0, continue checking 
00002890  4E75                    2029      RTS
00002892                          2030      
00002892                          2031  EAMOVEMPREDLOOPEND
00002892  5207                    2032      ADDQ.B  #1,D7       ; Itterate D7
00002894  E39E                    2033      ROL.L   #1,D6       ; Rotate one bit to the right  
00002896  BE3C 0009               2034      CMP.B   #9,D7       ; Check if we've hit A8
0000289A  6C00 FF00               2035      BGE     EAMOVEMSLASHEND      ; If we have, break the loop
0000289E  0806 0000               2036      BTST    #$00,D6     ; Check the far right bit
000028A2  66EE                    2037      BNE     EAMOVEMPREDLOOPEND       ; If it isn't 0, continue checking 
000028A4  5347                    2038      SUBQ    #1,D7
000028A6  4E75                    2039      RTS
000028A8                          2040      
000028A8                          2041  ; If the EA is unknown
000028A8                          2042  EAUNKN
000028A8  12FC 003C               2043      MOVE.B  #'<',(A1)+  ; We did this byte-by-byte in case A1 is at an odd register
000028AC  12FC 0045               2044      MOVE.B  #'E',(A1)+
000028B0  12FC 0041               2045      MOVE.B  #'A',(A1)+
000028B4  12FC 003E               2046      MOVE.B  #'>',(A1)+
000028B8  5841                    2047      ADDQ    #4,D1
000028BA  4E75                    2048      RTS
000028BC                          2049  
000028BC                          2050  
000028BC                          2051  
000028BC                          2052  
000028BC                          2053  
000028BC                          2054  
000028BC                          2055  
000028BC                          2056  
000028BC                          2057  
000028BC                          2058  
000028BC                          2059  -------------------- end include --------------------
000028BC                          2060      
000028BC  FFFF FFFF               2061      SIMHALT             ; halt simulator
000028C0                          2062  
000028C0                          2063  * Put variables and constants here
000028C0                          2064  
000028C0                          2065      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AASD                247E
AASLSRO             2434
AASLSRODL           24B2
AASLSRODR           249C
AASLSROOP           24B8
ADDADDA             21F4
ADDAL               2300
ADDAN               2314
ADDAW               22EC
ADDBDN              225C
ADDBEA              22D8
ADDEA               226E
ADDI                183A
ADDI8               184E
ADDIB               189E
ADDIL               1922
ADDIW               18E2
ADDLDN              2238
ADDLEA              22B4
ADDWDN              224A
ADDWEA              22C6
ALSD                2488
AND                 20B4
ANDBDN              21B4
ANDBEA              214A
ANDDN               21C6
ANDEA               215A
ANDEACH             20E4
ANDLDN              2190
ANDLEA              212A
ANDWDN              21A2
ANDWEA              213A
AROD                2492
ASD                 2378
ASLSRO              2344
ASLSROB             23D8
ASLSRODL            23B0
ASLSRODR            2396
ASLSROIR            23E4
ASLSROIRDN          2406
ASLSROOP            240C
ASLSROSIZE          23BA
ASLSROW             23E0
BAD_EVEN            10DE
BAD_LENGTH          10A0
BCC                 1D1E
BCC16               1DC4
BCC16NEG            1DDC
BCC32               1DEC
BCC32NEG            1E0E
BCC8NEG             1DB4
BCCOP               1D42
BCCSIZE             1D6C
BGTOP               1D50
BLEOP               1D5E
CHECK31             1058
CLR                 1A8A
CLRB                1ADA
CLRL                1B06
CLROP               1B1C
CLRW                1AF0
CMP                 1FB4
CMPB                1FDA
CMPL                200A
CMPOP               2022
CMPW                1FF2
CNRJML              1A26
CONTINUE            177F
COUNTER             17BE
CR                  D
DIVU                1E7C
EA111               264E
EAALA               2630
EAAN                2594
EAANI               25A2
EAAPOST             25B8
EAAPRE              25D2
EAAWA               261E
EADIGIT             2678
EADN                2586
EAGETDSTEA          254A
EAGETSRCEA          250A
EAHEXTOASCII        2664
EAID                25EC
EAIDL               2606
EAMOVEMPOSTI        2688
EAMOVEMPOSTIAN      2698
EAMOVEMPOSTIANEND   26F6
EAMOVEMPOSTIDN      2702
EAMOVEMPOSTIEND     2760
EAMOVEMPOSTILOOPEND  2776
EAMOVEMPOSTILOOPSTART  2762
EAMOVEMPRED         279E
EAMOVEMPREDAN       27B2
EAMOVEMPREDANEND    280E
EAMOVEMPREDDN       281C
EAMOVEMPREDEND      2878
EAMOVEMPREDLOOPEND  2892
EAMOVEMPREDLOOPSTART  287E
EAMOVEMSLASH        278C
EAMOVEMSLASHEND     279C
EAUNKN              28A8
ENDINGADDRESS       17BA
ENDLOOP             1124
ENTERCHECK          1064
ENTERPROMPT         16F3
FAIL_INPUT          16AD
HEXEND              164F
HEXSTART            1632
INTRO2              1461
INTROMSG            1264
IOASCIITOHEX        10F4
IOASCIITOHEX2       114E
IODIGIT             1216
IODONE              124E
IOHEXTOASCII        1202
IOINTRO             100C
IOLOOP              102A
IOORTAG             1106
IOORTAG2            1160
IOSTRINGLOC         100
JSR                 1B6E
LEA                 1C9A
LENGTH_CHECK        1088
LF                  A
LSD                 2382
MOVE                1970
MOVEB               19C2
MOVEL               19E6
MOVEM               1BDA
MOVEML              1C44
MOVEMOP             1C4A
MOVEMPOSTI          1C7E
MOVEMPRED           1C62
MOVEMW              1C3A
MOVEOP              19F8
MOVEQ               1E2A
MOVEW               19D4
MULS                2078
MULSAND             2058
NOP                 1B3A
OPGETCODE           17C2
OUTPUTOPCODE        1192
OUTRO               167B
ROD                 238C
RTS                 1B54
SPACER              17B2
SPC                 166B
START               1000
STARTADDRESS        17B6
STARTGTEND          1735
STARTLESSTHNEND     10B2
SUB                 1ECE
SUBBDN              1FA2
SUBBEA              1F6C
SUBEA               1F02
SUBLDN              1F7E
SUBLEA              1F48
SUBWDN              1F90
SUBWEA              1F5A
TEST_ODD            10C4
UNKEA               1671
UNKNOWN             24E6
