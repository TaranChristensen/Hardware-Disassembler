00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 3/9/2016 11:31:27 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Master
00000000                             3  * Written by : Circles
00000000                             4  * Date       : ##/##/16
00000000                             5  * Description: Project Master File
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11      INCLUDE "IO.X68"        ; Handles our input and output, as well as which address to refer to
00001000  47F9 00001404             12                  LEA     COUNTER,A3         initialize the COUNTER variable
00001006  26BC 00000000             13                  MOVE.L  #0,(A3)            clear the variable
0000100C                            14                  
0000100C                            15  
0000100C  5293                      16  IOINTRO         ADD.L   #$00000001,(A3)    COUNTER++
0000100E  43F9 00001238             17                  LEA     IntroMsg,A1        Display the intro
00001014  103C 000E                 18                  MOVE.B  #14, D0
00001018  4E4F                      19                  TRAP    #15
0000101A                            20  
0000101A  43F9 00001255             21  IOLOOP          LEA     HexStart,A1        Display the prompt and loop it
00001020  103C 000E                 22                  MOVE.B  #14,D0          
00001024  4E4F                      23                  TRAP    #15   
00001026  5493                      24                  ADD.L   #$00000002,(A3)    COUNTER++ COUNTER++
00001028                            25  
00001028                            26  
00001028  43F9 00000100             27                  LEA     IOStringLoc,A1     Store the string of our user input at StartAddress,A1 
0000102E  103C 0002                 28                  MOVE.B  #2,D0              uses Trap #15, Task 2
00001032  4E4F                      29                  TRAP    #15              
00001034                            30          
00001034  B2BC 00000001             31                  CMP.L   #1,D1              Compares D1 to the number 1 (eg. String length of 1)
0000103A  6700 01E6                 32                  BEQ     IODONE             Branch to DONE if they are equal
0000103E                            33          
0000103E  4284                      34                  CLR.L   D4                 Ensure our counter (D4) is 0 
00001040                            35  
00001040  4EB9 0000107C             36                  JSR     LENGTH_CHECK 
00001046  4282                      37                  CLR.L   D2  
00001048  BA3C 0001                 38                  CMP.B   #1,D5              if 1 then it passed the tests         
0000104C                            39                  
0000104C  6700 009A                 40                  BEQ     IOASCIItoHEX
00001050  60C8                      41                  BRA     IOLOOP
00001052                            42                  
00001052  0C93 0000001D             43  CHECK31         CMP.L   #$0000001D,(A3)    compare the counter to 29
00001058  6E00 0004                 44                  BGT     ENTERCHECK         counter is at at least 30
0000105C  4E75                      45                  RTS                        counter is still low
0000105E                            46  
0000105E  4280                      47  ENTERCHECK      CLR.L   D0
00001060  43F9 0000136E             48                  LEA     ENTERPROMPT,A1     display the enter prompt
00001066  103C 000E                 49                  MOVE.B  #14,D0
0000106A  4E4F                      50                  TRAP    #15
0000106C                            51                            
0000106C  103C 0002                 52                  MOVE.B  #2,D0              wait for the user to hit enter
00001070  4E4F                      53                  TRAP    #15
00001072                            54                  
00001072  26BC 00000000             55                  MOVE.L  #0,(A3)            clear the counter
00001078  5293                      56                  ADD.L   #$00000001,(A3)    COUNTER++
0000107A                            57               
0000107A  4E75                      58                  RTS
0000107C                            59                  
0000107C                            60  CLEARMEMORY     ***************************** a function to clear all data and address registers *****************************
0000107C                            61                  
0000107C  4285                      62  LENGTH_CHECK    CLR.L   D5                 store the result of the test
0000107E  7C00                      63                  MOVEQ   #$0,D6             make D6 0
00001080  B206                      64                  CMP.B   D6,D1              see if null
00001082  6700 0010                 65                  BEQ     BAD_LENGTH         if null then branch to bad input
00001086  0C41 0008                 66                  CMPI    #$8,D1             see if it is more than 8 characters long
0000108A  6E00 0008                 67                  BGT     BAD_LENGTH         if more than 8 branch to bad input
0000108E  1A3C 0001                 68                  MOVE.B  #$1,D5             passed the length checks so move 1
00001092  4E75                      69                  RTS                        go back
00001094                            70                  
00001094  7A00                      71  BAD_LENGTH      MOVEQ   #$0,D5             did not pass the test
00001096  43F9 00001328             72                  LEA     FAIL_INPUT,A1      load bad input message
0000109C  103C 000E                 73                  MOVE.B  #14,D0          
000010A0  4E4F                      74                  TRAP    #15 
000010A2  5293                      75                  ADD.L   #$00000001,(A3)    COUNTER++
000010A4  4E75                      76                  RTS                        go back
000010A6                            77                  
000010A6  43F9 000013B2             78  STARTLESSTHNEND LEA     STARTGTEND,A1      load the error 
000010AC  103C 000E                 79                  MOVE.B  #14,D0
000010B0  4E4F                      80                  TRAP    #15
000010B2  5293                      81                  ADD.L   #$00000001,(A3)    COUNTER++
000010B4  6000 FF64                 82                  BRA     IOLOOP             go back to the start
000010B8                            83  
000010B8                            84  
000010B8  4286                      85  TEST_ODD        CLR.L   D6           
000010BA  4285                      86                  CLR.L   D5
000010BC  7A02                      87                  MOVE.L  #$00000002,D5      divide by 2 to see remainder
000010BE  2C02                      88                  MOVE.L  D2,D6              create a copy of the input in D7
000010C0  8CC5                      89                  DIVU    D5,D6              divide the hex number by 2
000010C2  4846                      90                  SWAP    D6                 put the remainder on the far right
000010C4  BC3C 0001                 91                  CMP.B   #1,D6              see if the remainder is one
000010C8  6700 0008                 92                  BEQ     BAD_EVEN           branch to even
000010CC  4286                      93                  CLR.L   D6
000010CE  4285                      94                  CLR.L   D5
000010D0  4E75                      95                  RTS
000010D2                            96                  
000010D2                            97                  
000010D2  4285                      98  BAD_EVEN        CLR.L   D5
000010D4  4286                      99                  CLR.L   D6
000010D6  43F9 00001328            100                  LEA     FAIL_INPUT,A1      load bad input message  
000010DC  103C 000E                101                  MOVE.B  #14,D0          
000010E0  4E4F                     102                  TRAP    #15 
000010E2  5293                     103                  ADD.L   #$00000001,(A3)    COUNTER++
000010E4  6000 FF34                104                  BRA     IOLOOP             go back to the beginning
000010E8                           105                  
000010E8                           106  
000010E8  5244                     107  IOASCIItoHEX    ADDQ    #1,D4
000010EA  E98A                     108                  LSL.L   #4,D2              Scoot D2 a nybble
000010EC  1619                     109                  MOVE.B  (A1)+,D3           Move a Byte from A1's address to D3
000010EE  0403 0030                110                  SUB.B   #48,D3             Sub 48 to turn ASCII 0 into binary 0
000010F2  B63C 0009                111                  CMP.B   #9,D3              If our number is greater than 9..
000010F6  6F02                     112                  BLE.S   IOORTAG            .. it must be a character; A-F: 
000010F8  5F03                     113                  SUB.B   #7,D3              Sub 7 to turn A into 10
000010FA  8403                     114  IOORTAG         OR.B    D3,D2              Store our nybble into D2
000010FC  B204                     115                  CMP.B   D4,D1              See if we've read all the characters
000010FE  66E8                     116                  BNE.S   IOASCIItoHEX       Continue if we haven't
00001100                           117              
00001100                           118              
00001100  23FC 00000000 000013FC   119                  MOVE.L  #0,StartAddress
0000110A  23C2 000013FC            120                  MOVE.L  D2,StartAddress    Store our StartAddress
00001110                           121                  
00001110  4EB8 10B8                122                  JSR     TEST_ODD           test if the address is odd
00001114                           123                  
00001114  4281                     124                  CLR.L   D1
00001116  4282                     125                  CLR.L   D2
00001118                           126  
00001118                           127  
00001118  43F9 000012AB            128  ENDLOOP         LEA     HexEnd,A1          load the ending address prompt
0000111E  103C 000E                129                  MOVE.B  #14,D0
00001122  4E4F                     130                  TRAP    #15  
00001124  5493                     131                  ADD.L   #$00000002,(A3)
00001126                           132                  
00001126  43F9 00000100            133                  LEA     IOStringLoc,A1     Store the string of our user input at StartAddress,A1 
0000112C  103C 0002                134                  MOVE.B  #2,D0              uses Trap #15, Task 2
00001130  4E4F                     135                  TRAP    #15              
00001132                           136          
00001132  B2BC 00000001            137                  CMP.L   #1,D1              Compares D1 to the number 1 (eg. String length of 1)
00001138  6700 00E8                138                  BEQ     IODONE             Branch to DONE if they are equal
0000113C                           139          
0000113C  4284                     140                  CLR.L   D4                 Ensure our counter (D4) is 0 
0000113E                           141  
0000113E  4EB8 107C                142                  JSR     LENGTH_CHECK       check to make sure the length is ok
00001142  BA3C 0001                143                  CMP.B   #1,D5              if 1 then it passed the tests         
00001146                           144  
00001146  6700 0004                145                  BEQ     IOASCIItoHEX2      convert to hex
0000114A  60CC                     146                  BRA     ENDLOOP
0000114C                           147                  
0000114C  5244                     148  IOASCIItoHEX2   ADDQ    #1,D4
0000114E  E98A                     149                  LSL.L   #4,D2              Scoot D2 a nybble
00001150  1619                     150                  MOVE.B  (A1)+,D3           Move a Byte from A1's address to D3
00001152  0403 0030                151                  SUB.B   #48,D3             Sub 48 to turn ASCII 0 into binary 0
00001156  B63C 0009                152                  CMP.B   #9,D3              If our number is greater than 9..
0000115A  6F02                     153                  BLE.S   IOORTAG2           .. it must be a character; A-F: 
0000115C  5F03                     154                  SUB.B   #7,D3              Sub 7 to turn A into 10
0000115E  8403                     155  IOORTAG2        OR.B    D3,D2              Store our nybble into D2
00001160  B204                     156                  CMP.B   D4,D1              See if we've read all the characters
00001162  66E8                     157                  BNE.S   IOASCIItoHEX2      Continue if we haven't
00001164                           158              
00001164                           159    
00001164  23FC 00000000 00001400   160                  MOVE.L  #0,EndingAddress
0000116E  23C2 00001400            161                  MOVE.L  D2,EndingAddress   Store our EndingAddress
00001174                           162                  
00001174  4EB8 10B8                163                  JSR     TEST_ODD           tezt if the ending address is odd
00001178                           164                  
00001178  2479 000013FC            165                  MOVE.L  StartAddress,A2    Push our start address into A2
0000117E                           166                  
0000117E  B5F9 00001400            167                  CMP.L   EndingAddress,A2   compare the ending address with the startingaddress
00001184  6E00 FF20                168                  BGT     STARTLESSTHNEND    branch if the starting is greater than the ending
00001188                           169                  
00001188  4281                     170                  CLR.L   D1
0000118A                           171                  
0000118A  2479 000013FC            172                  MOVE.L  StartAddress,A2    Push our start address into A2 
00001190                           173                  
00001190                           174  
00001190  23FC 00000000 00000100   175  OUTPUTOPCODE    MOVE.L  #0,IOStringLoc     ********** Testing purposes ********** 
0000119A  4281                     176                  CLR.L   D1
0000119C                           177          
0000119C                           178  
0000119C  43F9 00000100            179                  LEA     IOStringLoc,A1     Load our IOStringLoc into A1 for string contruction purposes
000011A2                           180          
000011A2                           181                  ; Here we could loop all of the addresses of A2 until End, or something.
000011A2  2C0A                     182                  MOVE.L  A2,D6
000011A4  4244                     183                  CLR     D4
000011A6  4846                     184                  SWAP    D6
000011A8  4EB9 00001F80            185                  JSR     EAHEXtoASCII
000011AE  4244                     186                  CLR     D4
000011B0  4846                     187                  SWAP    D6
000011B2  4EB9 00001F80            188                  JSR     EAHEXtoASCII
000011B8  22FC 20202020            189                  MOVE.L  #'    ',(A1)+      Add a spacer into our IOStringLoc
000011BE  32FC 2020                190                  MOVE.W  #'  ',(A1)+      Add a spacer into our IOStringLoc
000011C2  5C41                     191                  ADDQ    #6,D1              We added 4 bytes, aka 4 spaces
000011C4                           192          
000011C4  4EB9 00001408            193                  JSR OPGETCODE              Get the OpCode pointed at by A2, it's string stored in IOStringLoc
000011CA                           194                  
000011CA  43F9 00000100            195                  LEA     IOStringLoc,A1     Now that we've populated the string, load it's beginning
000011D0  103C 0001                196                  MOVE.B  #1,D0              Trap task 1 prints a string at A1 with #D1 bytes.
000011D4  4E4F                     197                  TRAP    #15
000011D6                           198          
000011D6                           199                  ;LEA     UnkEA,A1          TEMPORARY Print "<EA>,<EA>"
000011D6                           200                  ;MOVE.B  #13,D0              
000011D6                           201                  ;TRAP    #15                 
000011D6                           202          
000011D6  43F9 0000130E            203                  LEA     SPC,A1             Puts the space before the opCode
000011DC  103C 000D                204                  MOVE.B  #13,D0
000011E0  4E4F                     205                  TRAP    #15
000011E2                           206                  
000011E2  5293                     207                  ADD.L   #$00000001,(A3)    COUNTER++
000011E4  4EB8 1052                208                  JSR     CHECK31
000011E8                           209                  
000011E8  B5F9 00001400            210                  CMP.L   EndingAddress,A2   compare the current address with the ending address
000011EE  6DA0                     211                  BLT     OUTPUTOPCODE       if the current is less than the ending keep looping
000011F0                           212                  
000011F0                           213  
000011F0                           214  
000011F0                           215  
000011F0                           216                  ; The following outputs the input, converting what we've saved in HEX to ASCII
000011F0                           217                  ; We won't need this in the final version, but the below code should be handy
000011F0                           218                  ;  for print out EA values
000011F0  2439 000013FC            219                  MOVE.L  StartAddress,D2    Ensure our address is actually at D2
000011F6  7208                     220                  MOVEQ   #8,D1              There are 8 characters in the hex of our address
000011F8  4284                     221                  CLR.L   D4                 Ensure our counter (D4) is 0
000011FA  43F9 00000100            222                  LEA     IOStringLoc,A1     Load our IO String location, to store our output at  
00001200                           223  
00001200                           224          
00001200  5244                     225  IOHEXtoASCII    ADDQ    #1,D4
00001202  E99A                     226                  ROL.L   #4,D2              Get the left-most nyblle to the front..
00001204  1602                     227                  MOVE.B  D2,D3              .. Put the front-most byte into D3    
00001206  C63C 000F                228                  AND.B   #$0F,D3            Distill D3 down to the original left-most nybble
0000120A  B63C 0009                229                  CMP.B   #9,D3              See if our number is greater than 9..
0000120E  6F00 0004                230                  BLE     IODIGIT            If it is 9 or less, it's a digit..
00001212  5E03                     231                  ADD.B   #7,D3              Otherwise it is a digit, and needs an additional 7
00001214  0603 0030                232  IODIGIT         ADD.B   #48,D3             We now how the nybble's ASCII code
00001218  12C3                     233                  MOVE.B  D3,(A1)+           Move the ASCII code into the output string at A1
0000121A  B204                     234                  CMP.B   D4,D1              See if we've read all the characters
0000121C  66E2                     235                  BNE.S   IOHEXtoASCII       Continue if we haven't
0000121E                           236          
0000121E                           237  
0000121E  6000 FDFA                238                  BRA     IOLOOP
00001222                           239          
00001222                           240        
00001222  43F9 0000131E            241  IODONE          LEA     OUTRO,A1           Display the ending message 
00001228  103C 000E                242                  MOVE.B  #14,D0
0000122C  4E4F                     243                  TRAP    #15
0000122E  103C 0009                244                  MOVE.B  #9,D0
00001232  4E4F                     245                  TRAP    #15                Halt Simulator
00001234                           246          
00001234  FFFF FFFF                247                  SIMHALT
00001238                           248          
00001238  =0000000D                249  CR              EQU     $0D         
00001238  =0000000A                250  LF              EQU     $0A 
00001238  =00000100                251  IOStringLoc     EQU     $0100              This is where we will store the string of the user input, and other strings
00001238                           252  
00001238                           253  
00001238= 54 65 61 6D 20 43 ...    254  IntroMsg        DC.B    'Team Circles Disassembler ',CR,LF,0     Intro
00001255= 45 6E 74 65 72 20 ...    255  HexStart        DC.B    'Enter a starting address in hex of length 8 or less and even, or',CR,LF,'type in 0 to quit: ',0 Prompt for the user
000012AB= 45 6E 74 65 72 20 ...    256  HexEnd          DC.B    'Enter an ending address in hex of length 8 or less and even, or',CR,LF,'type in 0 to quit: ',0 Prompt for the user
00001300= 59 6F 75 20 74 79 ...    257  RES             DC.B    'You typed in ',0                        Response to the user
0000130E= 20 20 20 20 20 00        258  SPC             DC.B    '     ',0                                tab
00001314= 3C 45 41 3E 2C 3C ...    259  UnkEA           DC.B    '<EA>,<EA>',0                            Interim message for unkown EAs.
0000131E= 47 6F 6F 64 62 79 ...    260  OUTRO           DC.B    'Goodbye !',0                            Outro message
00001328= 49 20 61 6D 20 73 ...    261  FAIL_INPUT      DC.B    'I am sorry, but you typed an address that did not meet the criteria',CR,LF,0 
0000136E= 54 68 65 20 73 63 ...    262  ENTERPROMPT     DC.B    'The screen limit has been reached, please press enter to continue',CR,LF,0
000013B2= 54 68 65 20 65 6E ...    263  STARTGTEND      DC.B    'The ending address was less than the starting address, please try again',CR,LF,0
000013FC                           264  
000013FC                           265  
000013FC                           266  StartAddress    DS.L    1
00001400                           267  EndingAddress   DS.L    1
00001404                           268  COUNTER         DS.L    1 keep track of the lines on the screen
00001408                           269  
00001408                           270  
00001408                           271  
00001408                           272  
00001408                           273  
00001408                           274  
00001408                           275  
00001408                           276  
00001408                           277  
00001408                           278  
00001408                           279  
00001408                           280  
00001408                           281  
00001408                           282  
00001408                           283  
00001408                           284  -------------------- end include --------------------
00001408                           285      INCLUDE "OpCode.X68"    ; Handles determining OpCodes
00001408                           286  
00001408                           287  
00001408                           288  ; Here we assume that A2 contains the address pointing to our OpCode, and
00001408                           289  ;  we assume that A1 contains the address pointing to our IOStringLoc
00001408  3A1A                     290  OPGETCODE   MOVE.W  (A2)+,D5    ; Push our OpCode into D5
0000140A  2C05                     291              MOVE.L  D5,D6       ; Also store the OpCode in D6
0000140C  E09E                     292              ROR.L   #8,D6       ; Rotate our OpCode to right-most nybble
0000140E  E89E                     293              ROR.L   #4,D6       ; 
00001410  0206 000F                294              ANDI.B  #$0F,D6     ; Isolate our opcode nybble
00001414  BC3C 0000                295              CMP.B   #$00,D6
00001418  6700 0066                296              BEQ     ADDI        ; ADDI 
0000141C  BC3C 0001                297              CMP.B   #$01,D6     
00001420  6700 010A                298              BEQ     MOVEB       ; MOVE.B
00001424  BC3C 0003                299              CMP.B   #$03,D6     
00001428  6700 0112                300              BEQ     MOVEW       ; MOVE.W
0000142C  BC3C 0002                301              CMP.B   #$02,D6
00001430  6700 011A                302              BEQ     MOVEL       ; MOVE.L
00001434  BC3C 0004                303              CMP.B   #$04,D6
00001438  6700 0150                304              BEQ     CNRJML      ; CLR or NOP or RTS or JSR or MOVEM or LEA
0000143C  BC3C 0006                305              CMP.B   #$06,D6
00001440  6700 0338                306              BEQ     Bcc         ; Bcc (BCC, BGT, BLE) 
00001444  BC3C 0007                307              CMP.B   #$07,D6
00001448  6700 043C                308              BEQ     MOVEQ       ; MOVEQ 
0000144C  BC3C 0008                309              CMP.B   #$08,D6
00001450  6700 0486                310              BEQ     DIVU        ; DIVU
00001454  BC3C 0009                311              CMP.B   #$09,D6
00001458  6700 04BA                312              BEQ     SUB         ; SUB
0000145C  BC3C 000B                313              CMP.B   #$0B,D6
00001460  6700 055A                314              BEQ     CMP         ; CMP 
00001464  BC3C 000C                315              CMP.B   #$0C,D6
00001468  6700 05F0                316              BEQ     MULSAND     ; MULS or AND opcodes
0000146C  BC3C 000D                317              CMP.B   #$0D,D6
00001470  6700 0734                318              BEQ     ADDADDA     ; ADD or ADDA
00001474  BC3C 000E                319              CMP.B   #$0E,D6 
00001478  6700 0838                320              BEQ     ASLSRO      ; ASd (ASR) or LSd (LSL) or ROd (ROL)
0000147C  6000 09A4                321              BRA     UNKNOWN  
00001480                           322              
00001480                           323  ;  Here we assume the first left-most 4 bits have been confirmed: 0000
00001480  2C05                     324  ADDI        MOVE.L  D5,D6               ; Push D5 into D6
00001482  E09E                     325              ROR.L   #8,D6               ; Rotate left-most middle nybble to the right-most nybble
00001484  0206 000F                326              ANDI.B  #$0F,D6             ; Isolate opcode nybble
00001488  BC3C 0006                327              CMP.B   #$06,D6             ; If it matches ADDI's left-most middle nybble, branch
0000148C  6700 0006                328              BEQ     ADDI8               ; First 8 left-most bits of ADDI confirmed 
00001490  6000 0990                329              BRA     UNKNOWN             ; else unknown                       
00001494                           330  
00001494                           331  ;  Here we assume the first left-most 8 bits have been confirmed: 0000 0110            
00001494                           332  ADDI8                                  ; Two consecutive tests for illegal Src Modes
00001494  2C05                     333              MOVE.L  D5,D6              ; Push D5 into D6 
00001496  0286 0000003F            334              ANDI.L  #$003F,D6          ; Isolate the Src EA bits
0000149C  BCBC 0000003C            335              CMP.L   #$003C, D6         ; Compare with illegal mode #<data>
000014A2  6700 097E                336              BEQ     UNKNOWN
000014A6                           337              
000014A6  E69E                     338              ROR.L   #3,D6              ; Roll 3 bits right
000014A8  0286 00000007            339              ANDI.L  #$0007,D6          ; Isolate the 3 Src Mode bits
000014AE  BCBC 00000001            340              CMP.L   #$0001, D6         ; Compare with illegal mode An
000014B4  6700 096C                341              BEQ     UNKNOWN
000014B8                           342              
000014B8                           343                                  
000014B8  2C05                     344              MOVE.L  D5,D6              ; Push D5 into D6 
000014BA  EC8E                     345              LSR.L   #6,D6              ; Shift six bits to the right
000014BC  0286 00000003            346              ANDI.L  #$0003,D6          ; Isolate the size bits
000014C2                           347                         
000014C2  BCBC 00000000            348              CMP.L   #$0000,D6          ; See if the size is '00'..
000014C8  6700 001A                349              BEQ     ADDIB              ; ..If so, it's ANDI.B
000014CC  BCBC 00000001            350              CMP.L   #$0001,D6          ; See if the size is '01'..
000014D2  6700 0020                351              BEQ     ADDIW              ; ..If so, it's ANDI.W
000014D6  BCBC 00000002            352              CMP.L   #$0002,D6          ; See if the size is '10'..
000014DC  6700 0026                353              BEQ     ADDIL              ; ..If so, it's ANDI.L
000014E0                           354              
000014E0  6000 0940                355              BRA     UNKNOWN            ; If it isn't any, then it's Unknown
000014E4                           356              
000014E4                           357  ADDIB       
000014E4  22FC 41444449            358              MOVE.L  #'ADDI',(A1)+
000014EA  32FC 2E42                359              MOVE.W  #'.B',(A1)+
000014EE  5C41                     360              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc
000014F0  6000 0022                361              BRA     ADDIOP
000014F4                           362              
000014F4                           363  ADDIW       
000014F4  22FC 41444449            364              MOVE.L  #'ADDI',(A1)+
000014FA  32FC 2E57                365              MOVE.W  #'.W',(A1)+
000014FE  5C41                     366              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
00001500  6000 0012                367              BRA     ADDIOP
00001504                           368              
00001504                           369  ADDIL      
00001504  22FC 41444449            370              MOVE.L  #'ADDI',(A1)+
0000150A  32FC 2E4C                371              MOVE.W  #'.L',(A1)+
0000150E  5C41                     372              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
00001510  6000 0002                373              BRA     ADDIOP
00001514                           374  
00001514  22FC 20202020            375  ADDIOP      MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
0000151A  5841                     376              ADDQ    #4,D1              ; We added 4 bytes, aka 4 spaces
0000151C                           377              
0000151C  2C05                     378              MOVE.L  D5,D6              ; Push D5 into D6
0000151E  0286 0000003F            379              ANDI.L  #$003F,D6          ; Isolate the Src EA bits 
00001524  4EB9 00001E46            380              JSR EAGETSRCEA             ; Find and print the code stored in D6 
0000152A  4E75                     381              RTS
0000152C                           382                
0000152C  22FC 4D4F5645            383  MOVEB       MOVE.L  #'MOVE',(A1)+
00001532  32FC 2E42                384              MOVE.W  #'.B',(A1)+
00001536  5C41                     385              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
00001538                           386              
00001538  6000 0022                387              BRA MOVEOP
0000153C                           388              
0000153C  22FC 4D4F5645            389  MOVEW       MOVE.L  #'MOVE',(A1)+
00001542  32FC 2E57                390              MOVE.W  #'.W',(A1)+
00001546  5C41                     391              ADDQ    #6,D1               ; We added 6 new characters to our IOStringLoc 
00001548                           392              
00001548  6000 0012                393              BRA MOVEOP
0000154C                           394              
0000154C  22FC 4D4F5645            395  MOVEL       MOVE.L  #'MOVE',(A1)+
00001552  32FC 2E4C                396              MOVE.W  #'.L',(A1)+
00001556  5C41                     397              ADDQ    #6,D1               ; We added 6 new characters to our IOStringLoc 
00001558                           398              
00001558  6000 0002                399              BRA MOVEOP
0000155C                           400              
0000155C  22FC 20202020            401  MOVEOP      MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
00001562  5841                     402              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
00001564                           403              
00001564  2C05                     404              MOVE.L  D5,D6               ; Push D5 into D6
00001566  0286 0000003F            405              ANDI.L  #$003F,D6           ; Isolate the Src EA bits 
0000156C  4EB9 00001E46            406              JSR EAGETSRCEA              ; Find and print the code stored in D6
00001572                           407              
00001572  12FC 002C                408              MOVE.B  #',',(A1)+
00001576  5241                     409              ADDQ    #1,D1
00001578                           410              
00001578  2C05                     411              MOVE.L  D5,D6               ; Push D5 into D6
0000157A  EC8E                     412              LSR.L   #6,D6               ; Shift six bits to the right
0000157C  0286 0000003F            413              ANDI.L  #$003F,D6           ; Isolate the Dst EA bits
00001582  4EB9 00001E86            414              JSR EAGETDSTEA
00001588  4E75                     415              RTS
0000158A                           416              
0000158A                           417  ; This label determines if the code is either CLR or NOP or RTS or JSR or MOVEM or LEA
0000158A                           418  ; Here we assume that the first left-most four bits equal 0100            
0000158A                           419  CNRJML      
0000158A  2C05                     420              MOVE.L  D5,D6              ; Push D5 into D6 (Copy OPcode over isolated nybble)
0000158C                           421              
0000158C                           422              *NOP & RTS's machine code is uniquely hardcoded, check first
0000158C  BCBC 00004E71            423              CMP.L   #$4E71,D6          ; See if the OPcode matches NOP's hardcode
00001592  6700 00CA                424              BEQ     NOP
00001596  BCBC 00004E75            425              CMP.L   #$4E75,D6          ; See if the OPcode matches RTS's hardcode
0000159C  6700 00DA                426              BEQ     RTS
000015A0                           427                                         ; CLR's middle most left nybble is unique (0010)
000015A0  E09E                     428              ROR.L   #8,D6              ; Rotate our OpCode to right-most nybble
000015A2  0206 000F                429              ANDI.B  #$0F,D6            ; Isolate our opcode nybble
000015A6  BC3C 0002                430              CMP.B   #$02,D6            ; See if matches nybble
000015AA  6700 0026                431              BEQ     CLR               
000015AE                           432              
000015AE  2C05                     433              MOVE.L  D5,D6              ; Push D5 into D6
000015B0  E08E                     434              LSR.L   #8,D6              ; Shift 8 bits to the right
000015B2                           435              
000015B2  0806 0000                436              BTST    #$00,D6            ; See if our right-most bit is set
000015B6  6600 0180                437              BNE     LEA                ; If our bit is set, branch to LEA     
000015BA                           438              
000015BA  E28E                     439              LSR.L   #1,D6              ; Shift another bit
000015BC  0806 0000                440              BTST    #$00,D6            ; See if our right-most bit is set
000015C0  6600 00D0                441              BNE     JSR                ; If this one is set, branch to JSR
000015C4                           442                 
000015C4                           443                                         ; MOVEM's middle most left nybble is unique (1-00)
000015C4  E49E                     444              ROR.L   #2,D6              ; first bit must be 0, rotate 1 bit 
000015C6  0806 0000                445              BTST    #0,D6               ; Compare again for 00 match
000015CA  6600 00F0                446              BNE     MOVEM                           
000015CE                           447                                         
000015CE  6000 0852                448              BRA     UNKNOWN            ; If it doesnt any match, then it's Unknown
000015D2                           449  
000015D2                           450  
000015D2                           451  ;  Here we assume the first left-most 8 bits have been confirmed: 0100 0010
000015D2                           452  CLR         
000015D2  2C05                     453              MOVE.L  D5,D6              ; Push D5 into D6
000015D4  EC8E                     454              LSR.L   #6,D6              ; Shift six bits to the right
000015D6  0286 00000003            455              ANDI.L  #$0003,D6          ; Isolate the two size bits
000015DC                           456                         
000015DC  BCBC 00000000            457              CMP.L   #$0000,D6          ; See if the size is '00'..
000015E2  6700 001A                458              BEQ     CLRB               ; ..If so, it's CLR.B
000015E6  BCBC 00000001            459              CMP.L   #$0001,D6          ; See if the size is '01'..
000015EC  6700 0026                460              BEQ     CLRW               ; ..If so, it's CLR.W
000015F0  BCBC 00000002            461              CMP.L   #$0002,D6          ; See if the size is '10'..
000015F6  6700 0032                462              BEQ     CLRL               ; ..If so, it's CLR.L
000015FA                           463              
000015FA  6000 0826                464              BRA     UNKNOWN            ; If it isn't any, then it's Unknown
000015FE                           465              
000015FE  32FC 434C                466  CLRB        MOVE.W  #'CL',(A1)+
00001602  12FC 0052                467              MOVE.B  #'R',(A1)+
00001606  12FC 002E                468              MOVE.B  #'.',(A1)+
0000160A  12FC 0042                469              MOVE.B  #'B',(A1)+
0000160E  5A41                     470              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
00001610  6000 002E                471              BRA     CLROP
00001614                           472              
00001614  32FC 434C                473  CLRW        MOVE.W  #'CL',(A1)+
00001618  12FC 0052                474              MOVE.B  #'R',(A1)+
0000161C  12FC 002E                475              MOVE.B  #'.',(A1)+
00001620  12FC 0057                476              MOVE.B  #'W',(A1)+
00001624  5A41                     477              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
00001626  6000 0018                478              BRA     CLROP
0000162A                           479  
0000162A  32FC 434C                480  CLRL        MOVE.W  #'CL',(A1)+
0000162E  12FC 0052                481              MOVE.B  #'R',(A1)+
00001632  12FC 002E                482              MOVE.B  #'.',(A1)+
00001636  12FC 004C                483              MOVE.B  #'L',(A1)+
0000163A  5A41                     484              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
0000163C  6000 0002                485              BRA     CLROP
00001640                           486              
00001640  12FC 0020                487  CLROP       MOVE.B  #' ',(A1)+
00001644  32FC 2020                488              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
00001648  32FC 2020                489              MOVE.W  #'  ',(A1)+
0000164C  5A41                     490              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces
0000164E                           491              
0000164E  2C05                     492              MOVE.L  D5,D6              ; Push D5 into D6
00001650  0286 0000003F            493              ANDI.L  #$003F,D6          ; Isolate the Src EA bits 
00001656  4EB9 00001E46            494              JSR EAGETSRCEA             ; Find and print the code stored in D6
0000165C                           495  
0000165C  4E75                     496              RTS
0000165E                           497              
0000165E                           498  ;  Here we assume that all 16 bits have been confirmed 
0000165E                           499  NOP
0000165E  32FC 4E4F                500              MOVE.W  #'NO',(A1)+
00001662  12FC 0050                501              MOVE.B  #'P',(A1)+
00001666  5641                     502              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
00001668                           503              
00001668  12FC 0020                504              MOVE.B  #' ',(A1)+       ; Add a spacer into our IOStringLoc
0000166C  32FC 2020                505              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
00001670  32FC 2020                506              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
00001674  5A41                     507              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces        
00001676  4E75                     508              RTS
00001678                           509  
00001678                           510  ;  Here we assume that all 16 bits have been confirmed            
00001678                           511  RTS         
00001678  32FC 5254                512              MOVE.W  #'RT',(A1)+
0000167C  12FC 0053                513              MOVE.B  #'S',(A1)+
00001680  5641                     514              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
00001682                           515              
00001682  12FC 0020                516              MOVE.B  #' ',(A1)+       ; Add a spacer into our IOStringLoc
00001686  32FC 2020                517              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
0000168A  32FC 2020                518              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
0000168E  5A41                     519              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces        
00001690  4E75                     520              RTS
00001692                           521              
00001692                           522  
00001692                           523  ;  Here we assume the first left-most 10 bits have been confirmed: 0100 1110 10 
00001692                           524  JSR         
00001692  32FC 4A53                525              MOVE.W  #'JS',(A1)+
00001696  12FC 0052                526              MOVE.B  #'R',(A1)+
0000169A  5641                     527              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
0000169C                           528              
0000169C  12FC 0020                529              MOVE.B  #' ',(A1)+
000016A0  32FC 2020                530              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
000016A4  22FC 20202020            531              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
000016AA  5E41                     532              ADDQ    #7,D1              ; We added 4 bytes, aka 4 spaces
000016AC  2C05                     533              MOVE.L  D5,D6              ; Push D5 into D6
000016AE                           534              
000016AE  0286 0000003F            535              ANDI.L  #$003F,D6          ; Isolate the Src EA bits 
000016B4  4EB9 00001E46            536              JSR EAGETSRCEA             ; Find and print the code stored in D6 
000016BA  4E75                     537              RTS
000016BC                           538              
000016BC                           539  
000016BC                           540  ;  Here we assume that these left-most bits have been confirmed, where - have not been confirmed: 0100 --00
000016BC                           541  MOVEM       
000016BC  22FC 4D4F5645            542              MOVE.L  #'MOVE',(A1)+
000016C2  32FC 4D2E                543              MOVE.W  #'M.',(A1)+
000016C6  5C41                     544              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
000016C8                           545              
000016C8  2C05                     546              MOVE.L  D5,D6              ; Copy our OpCode
000016CA  EC8E                     547              LSR.L   #6,D6              ; Shift it 6 bits to the right
000016CC  0806 0000                548              BTST    #$00,D6            ; If our size bit is 0..
000016D0  6700 0006                549              BEQ     MOVEMW             ; .. Its a MOVEM of size W
000016D4  6000 000C                550              BRA     MOVEML             ; .. Otherwise it's of size L
000016D8                           551  
000016D8  12FC 0057                552  MOVEMW      MOVE.B  #'W',(A1)+
000016DC  5241                     553              ADDQ    #1,D1              ; We've added another character into IOStringLoc
000016DE  6000 0008                554              BRA     MOVEMOP            ; MovemOp label, to skip MovemL label
000016E2                           555              
000016E2  12FC 004C                556  MOVEML      MOVE.B  #'L',(A1)+
000016E6  5241                     557              ADDQ    #1,D1              ; We've added another character into IOStringLoc
000016E8                           558              
000016E8  12FC 0020                559  MOVEMOP     MOVE.B  #' ',(A1)+         ; Add a spacer into our IOStringLoc
000016EC  32FC 2020                560              MOVE.W  #'  ',(A1)+        ;
000016F0  5641                     561              ADDQ    #3,D1              ; We added 4 bytes, aka 4 spaces 
000016F2                           562              
000016F2  E88E                     563              LSR.L   #4,D6              ; Shift our OpCode 4 bits to the left of Size (going to the right)
000016F4  0806 0000                564              BTST    #$00,D6            ; Check our Direction bit
000016F8  6700 0006                565              BEQ     MOVEMPRED          ; If it's 0, our direction is Pre Decrement (eg. Move TO the stack)
000016FC  6000 001E                566              BRA     MOVEMPOSTI         ; Otherwise, it's Post Increment (eg. Move FROM the stack)
00001700                           567              
00001700                           568  MOVEMPRED   ; This part is where we get the gross A0-A6/D0-D7 part
00001700  4EB9 0000208E            569              JSR     EAMOVEMPRED  
00001706                           570              
00001706  12FC 002C                571              MOVE.B  #',',(A1)+
0000170A  5241                     572              ADDQ    #1,D1
0000170C                           573              
0000170C  2C05                     574              MOVE.L  D5,D6              ; Copy our OpCode to D6
0000170E  0286 0000003F            575              ANDI.L  #$3F,D6            ; Isolate our EA src bits
00001714                           576              
00001714  4EB9 00001E46            577              JSR EAGETSRCEA  
0000171A                           578            
0000171A  4E75                     579              RTS
0000171C                           580  
0000171C  2C05                     581  MOVEMPOSTI  MOVE.L  D5,D6              ; Copy our OpCode to D6
0000171E  0286 0000003F            582              ANDI.L  #$3F,D6            ; Isolate our EA src bits
00001724                           583              
00001724  4EB9 00001E46            584              JSR EAGETSRCEA  
0000172A                           585              
0000172A  12FC 002C                586              MOVE.B  #',',(A1)+
0000172E  5241                     587              ADDQ    #1,D1
00001730                           588              
00001730                           589              ; This part is where we get the gross A0-A6/D0-D7 part
00001730  4EB9 00001FA4            590              JSR     EAMOVEMPOSTI
00001736                           591              
00001736  4E75                     592              RTS
00001738                           593              
00001738                           594  
00001738                           595  ;  Here we assume that these left-most bits have been confirmed, where - have not been confirmed: 0100 ---1            
00001738                           596  LEA
00001738  32FC 4C45                597              MOVE.W  #'LE',(A1)+
0000173C  12FC 0041                598              MOVE.B  #'A',(A1)+
00001740  5641                     599              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
00001742                           600               
00001742  12FC 0020                601              MOVE.B  #' ',(A1)+          ; Added an extra space here, due to only 3 character OpCode
00001746  22FC 20202020            602              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
0000174C  32FC 2020                603              MOVE.W  #'  ',(A1)+ 
00001750  5E41                     604              ADDQ    #7,D1               ; We added 4 bytes, aka 4 spaces
00001752                           605              
00001752  2C05                     606              MOVE.L  D5,D6               ; Copy D5 into D6
00001754  0286 0000003F            607              ANDI.L  #$003F,D6           ; Isolate the Src EA bits
0000175A  4EB9 00001E46            608              JSR EAGETSRCEA
00001760                           609              
00001760  12FC 002C                610              MOVE.B  #',',(A1)+
00001764  5241                     611              ADDQ    #1,D1
00001766                           612              
00001766  2C05                     613              MOVE.L  D5,D6               ; Copy D5 into D6
00001768  E09E                     614              ROR.L   #8,D6               ; Rotate 9 bits to the right (An Dst bits)
0000176A  E29E                     615              ROR.L   #1,D6               ; 
0000176C  0286 00000003            616              ANDI.L  #$0003,D6           ; Isolate the An Destination bits
00001772  4EF9 00001ED0            617              JMP EAAN
00001778  4E75                     618              RTS      
0000177A                           619              
0000177A  2C05                     620  Bcc         MOVE.L  D5,D6               ; Copy our OpCode into D6
0000177C  E15E                     621              ROL.W   #8,D6               ; Rotate our condition bit into place
0000177E  0206 000F                622              ANDI.B  #$0F,D6             ; Isolate the right-most nybble (condition)
00001782                           623              
00001782  BC3C 0004                624              CMP.B   #%0100,D6           ; See if our Condition is '0100'
00001786  6700 0016                625              BEQ     BCCOP               ; If it is, we have a BCC operation
0000178A  BC3C 000E                626              CMP.B   #%1110,D6           ; See if our Condition is '1110'
0000178E  6700 001C                627              BEQ     BGTOP               ; If it is, we have a BGT operation
00001792  BC3C 000F                628              CMP.B   #%1111,D6           ; See if our Condition is '1111'
00001796  6700 0022                629              BEQ     BLEOP               ; If it is, we have a BLE operation
0000179A                           630              
0000179A  6000 0686                631              BRA     UNKNOWN             ; Otherwise we don't know what kind of operation we have
0000179E                           632              
0000179E  32FC 4243                633  BCCOP       MOVE.W  #'BC',(A1)+
000017A2  12FC 0043                634              MOVE.B  #'C',(A1)+
000017A6  5641                     635              ADDQ    #3,D1               ; We've added three characters into our IOStringLoc
000017A8  6000 001E                636              BRA     BccSIZE             ; Branch to find our Bcc Op's Size
000017AC                           637              
000017AC  32FC 4247                638  BGTOP       MOVE.W  #'BG',(A1)+
000017B0  12FC 0054                639              MOVE.B  #'T',(A1)+
000017B4  5641                     640              ADDQ    #3,D1               ; We've added three characters into our IOStringLoc
000017B6  6000 0010                641              BRA     BccSIZE             ; Branch to find our Bcc Op's Size
000017BA                           642              
000017BA  32FC 424C                643  BLEOP       MOVE.W  #'BL',(A1)+
000017BE  12FC 0045                644              MOVE.B  #'E',(A1)+
000017C2  5641                     645              ADDQ    #3,D1               ; We've added three characters into our IOStringLoc
000017C4  6000 0002                646              BRA     BccSIZE             ; Branch to find our Bcc Op's Size
000017C8                           647  
000017C8                           648  BccSIZE     ; Find Displacement value
000017C8                           649              ; Branch to proper displacement value label
000017C8                           650              ; Store the value of A2 into D7
000017C8                           651              ; Get our total displacement into D6
000017C8                           652              ; Print the new address as D7 +/- D6
000017C8                           653              
000017C8  12FC 0020                654              MOVE.B  #' ',(A1)+       ; Add a spacer into our IOStringLoc
000017CC  32FC 2020                655              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
000017D0  32FC 2020                656              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
000017D4  32FC 2020                657              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
000017D8  5E41                     658              ADDQ    #7,D1              ; We added 4 bytes, aka 4 spaces   
000017DA                           659              
000017DA  12FC 0024                660              MOVE.B  #'$',(A1)+
000017DE  5241                     661              ADDQ    #1,D1
000017E0                           662              
000017E0  2C05                     663              MOVE.L  D5,D6
000017E2  0286 000000FF            664              ANDI.L  #$FF,D6             ; Isolate our Size bits
000017E8  BC3C 0000                665              CMP.B   #$00,D6             ; If it's equal to $00..
000017EC  6700 0032                666              BEQ     Bcc16               ; .. It has a 16 bit displacement
000017F0  0286 000000FF            667              ANDI.L  #$FF,D6             ; If it's equal to $FF..
000017F6  6700 0050                668              BEQ     Bcc32               ; .. It has a 32 bit displacement
000017FA                           669              ; Otherwise, it's an 8 bit displacement
000017FA                           670              
000017FA  2E0A                     671              MOVE.L  A2,D7               ; Get our initial address
000017FC  4A06                     672              TST.B   D6                  ; Is D6 negative?
000017FE  6B00 0010                673              BMI     Bcc8NEG             ; Branch to Negative
00001802                           674              
00001802  DE46                     675              ADD.W   D6,D7               ; Otherwise, Add what we have to D7
00001804                           676              
00001804  2C07                     677              MOVE.L  D7,D6               ; Push our expected address into D6 to print
00001806  4244                     678              CLR     D4                  ; Clear counter
00001808  4EB9 00001F80            679              JSR     EAHEXtoASCII        ; Print
0000180E                           680              
0000180E  4E75                     681              RTS 
00001810                           682              
00001810  4406                     683  Bcc8NEG     NEG.B   D6 
00001812  9E46                     684              SUB.W   D6,D7
00001814                           685              
00001814  2C07                     686              MOVE.L  D7,D6               ; Push our expected address into D6 to print
00001816  4244                     687              CLR     D4                  ; Clear counter
00001818  4EB9 00001F80            688              JSR     EAHEXtoASCII        ; Print
0000181E                           689              
0000181E  4E75                     690              RTS  
00001820                           691           
00001820  2E0A                     692  Bcc16       MOVE.L  A2,D7               ; Get our initial address
00001822  3C1A                     693              MOVE.W  (A2)+,D6
00001824  4A46                     694              TST.W   D6                  ; Is D6 negative?
00001826  6B00 0010                695              BMI     Bcc16NEG             ; Branch to Negative
0000182A                           696              
0000182A  DE86                     697              ADD.L   D6,D7               ; Otherwise, Add what we have to D7
0000182C                           698              
0000182C  2C07                     699              MOVE.L  D7,D6               ; Push our expected address into D6 to print
0000182E  4244                     700              CLR     D4                  ; Clear counter
00001830  4EB9 00001F80            701              JSR     EAHEXtoASCII        ; Print
00001836                           702              
00001836  4E75                     703              RTS 
00001838  4446                     704  Bcc16NEG    NEG.W   D6 
0000183A  9E86                     705              SUB.L   D6,D7
0000183C                           706              
0000183C  2C07                     707              MOVE.L  D7,D6               ; Push our expected address into D6 to print
0000183E  4244                     708              CLR     D4                  ; Clear counter
00001840  4EB9 00001F80            709              JSR     EAHEXtoASCII        ; Print
00001846                           710              
00001846  4E75                     711              RTS  
00001848                           712  
00001848                           713  
00001848  2E0A                     714  Bcc32       MOVE.L  A2,D7               ; Get our initial address
0000184A  2C1A                     715              MOVE.L  (A2)+,D6
0000184C  4A86                     716              TST.L   D6                  ; Is D6 negative?
0000184E  6BE8                     717              BMI     Bcc16NEG            ; Branch to Negative
00001850                           718              
00001850  DE86                     719              ADD.L   D6,D7               ; Otherwise, Add what we have to D7
00001852                           720              
00001852  2C07                     721              MOVE.L  D7,D6               ; Push our expected address into D6 to print
00001854  4244                     722              CLR     D4                  ; Clear counter
00001856  4846                     723              SWAP    D6
00001858  4EB9 00001F80            724              JSR     EAHEXtoASCII        ; Print
0000185E  4244                     725              CLR     D4                  ; Clear counter
00001860  4846                     726              SWAP    D6
00001862  4EB9 00001F80            727              JSR     EAHEXtoASCII        ; Print
00001868                           728              
00001868  4E75                     729              RTS 
0000186A                           730  
0000186A  4486                     731  Bcc32NEG    NEG.L   D6 
0000186C  9E86                     732              SUB.L   D6,D7
0000186E                           733              
0000186E  2C07                     734              MOVE.L  D7,D6               ; Push our expected address into D6 to print
00001870  4244                     735              CLR     D4                  ; Clear counter
00001872  4846                     736              SWAP    D6
00001874  4EB9 00001F80            737              JSR     EAHEXtoASCII        ; Print
0000187A  4244                     738              CLR     D4                  ; Clear counter
0000187C  4846                     739              SWAP    D6
0000187E  4EB9 00001F80            740              JSR     EAHEXtoASCII        ; Print
00001884                           741      
00001884  4E75                     742              RTS           
00001886                           743  MOVEQ
00001886  22FC 4D4F5645            744              MOVE.L  #'MOVE',(A1)+
0000188C  12FC 0051                745              MOVE.B  #'Q',(A1)+
00001890  5A41                     746              ADDQ    #5,D1               ; We added 4 new characters to our IOStringLoc
00001892                           747              
00001892  12FC 0020                748              MOVE.B  #' ',(A1)+
00001896  32FC 2020                749              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
0000189A  32FC 2020                750              MOVE.W  #'  ',(A1)+
0000189E  5841                     751              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
000018A0                           752              
000018A0  2C05                     753              MOVE.L  D5,D6               ; Copy D5 into D6
000018A2  0286 000000FF            754              ANDI.L  #$00FF,D6           ; Isolate the Src EA bits
000018A8                           755              
000018A8  12FC 0023                756              MOVE.B  #'#',(A1)+
000018AC  12FC 0024                757              MOVE.B  #'$',(A1)+
000018B0  5241                     758              ADDQ    #1,D1               ; We added 4 bytes, aka 4 spaces
000018B2  183C 0002                759              MOVE.B  #2,D4               ; "Start" at 2 characters
000018B6  E19E                     760              ROL.L   #$8,D6
000018B8  4EB9 00001F80            761              JSR     EAHEXtoASCII
000018BE                           762              
000018BE  12FC 002C                763              MOVE.B  #',',(A1)+
000018C2  5241                     764              ADDQ    #1,D1
000018C4                           765              
000018C4  2C05                     766              MOVE.L  D5,D6               ; Copy D5 into D6
000018C6  E09E                     767              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
000018C8  E29E                     768              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
000018CA  0286 00000007            769              ANDI.L  #$0007,D6           ; Isolate the Dn Destination bits
000018D0  4EF9 00001EC2            770              JMP EADN
000018D6                           771              
000018D6  4E75                     772              RTS 
000018D8                           773              
000018D8                           774  DIVU 
000018D8  22FC 44495655            775              MOVE.L  #'DIVU',(A1)+
000018DE  5841                     776              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000018E0                           777              
000018E0  22FC 20202020            778              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
000018E6  32FC 2020                779              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
000018EA  5C41                     780              ADDQ    #6,D1               ; We added 4 bytes, aka 4 spaces
000018EC                           781              
000018EC  2C05                     782              MOVE.L  D5,D6               ; Copy D5 into D6
000018EE  0286 0000003F            783              ANDI.L  #$003F,D6           ; Isolate the Src EA bits
000018F4  4EB9 00001E46            784              JSR EAGETSRCEA
000018FA                           785              
000018FA  12FC 002C                786              MOVE.B  #',',(A1)+
000018FE  5241                     787              ADDQ    #1,D1
00001900                           788              
00001900  2C05                     789              MOVE.L  D5,D6               ; Copy D5 into D6
00001902  E09E                     790              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00001904  E29E                     791              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00001906  0286 00000007            792              ANDI.L  #$0007,D6           ; Isolate the Dn Destination bits
0000190C  4EF9 00001EC2            793              JMP EADN
00001912                           794              
00001912  4E75                     795              RTS
00001914                           796  
00001914                           797              
00001914  2C05                     798  SUB         MOVE.L  D5,D6               ; Copy D5 into D6
00001916  EC8E                     799              LSR.L   #6,D6               ; Shift the size bits to the far right
00001918  0206 0007                800              ANDI.B  #$7,D6              ; Isolate the size bits    
0000191C                           801                   
0000191C  BC3C 0006                802              CMP.B   #%0110,D6            ; See if D6 is size "%100" through "%110"..
00001920  6700 002E                803              BEQ     SUBLEA              ; If it is, our OpCode is in the format of..
00001924  BC3C 0005                804              CMP.B   #%101,D6            ; .. Dn ~ <EA> --> <EA>
00001928  6700 0038                805              BEQ     SUBWEA
0000192C  BC3C 0004                806              CMP.B   #%100,D6
00001930  6700 0042                807              BEQ     SUBBEA
00001934                           808              
00001934  BC3C 0002                809              CMP.B   #%10,D6             ; See if D6 is size "%000" through "%010"..
00001938  6700 004C                810              BEQ     SUBLDN              ; If it is, our OpCode is in the format of..
0000193C  BC3C 0001                811              CMP.B   #%01,D6             ; .. <EA> ~ Dn --> Dn
00001940  6700 0056                812              BEQ     SUBWDN
00001944  BC3C 0000                813              CMP.B   #%00,D6
00001948  6700 0060                814              BEQ     SUBBDN              ; == 000 at this point
0000194C                           815              
0000194C  6000 04D4                816              BRA     UNKNOWN
00001950                           817              
00001950  22FC 5355422E            818  SUBLEA      MOVE.L  #'SUB.',(A1)+
00001956  5841                     819              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001958  12FC 004C                820              MOVE.B  #'L',(A1)+
0000195C  5241                     821              ADDQ    #1,D1               ; We added 1 byte into D1
0000195E  6000 01AC                822              BRA     ANDEA
00001962                           823              
00001962  22FC 5355422E            824  SUBWEA      MOVE.L  #'SUB.',(A1)+
00001968  5841                     825              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
0000196A  12FC 0057                826              MOVE.B  #'W',(A1)+
0000196E  5241                     827              ADDQ    #1,D1               ; We added 1 byte into D1
00001970  6000 019A                828              BRA     ANDEA
00001974                           829  
00001974  22FC 5355422E            830  SUBBEA      MOVE.L  #'SUB.',(A1)+
0000197A  5841                     831              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
0000197C  12FC 0042                832              MOVE.B  #'B',(A1)+
00001980  5241                     833              ADDQ    #1,D1               ; We added 1 byte into D1
00001982  6000 0188                834              BRA     ANDEA
00001986                           835  
00001986  22FC 5355422E            836  SUBLDN      MOVE.L  #'SUB.',(A1)+
0000198C  5841                     837              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
0000198E  12FC 004C                838              MOVE.B  #'L',(A1)+
00001992  5241                     839              ADDQ    #1,D1               ; We added 1 byte into D1
00001994  6000 01E2                840              BRA ANDDN
00001998                           841              
00001998  22FC 5355422E            842  SUBWDN      MOVE.L  #'SUB.',(A1)+
0000199E  5841                     843              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000019A0  12FC 0057                844              MOVE.B  #'W',(A1)+
000019A4  5241                     845              ADDQ    #1,D1               ; We added 1 byte into D1
000019A6  6000 01D0                846              BRA ANDDN
000019AA                           847  
000019AA  22FC 5355422E            848  SUBBDN      MOVE.L  #'SUB.',(A1)+
000019B0  5841                     849              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000019B2  12FC 0042                850              MOVE.B  #'B',(A1)+
000019B6  5241                     851              ADDQ    #1,D1               ; We added 1 byte into D1
000019B8  6000 01BE                852              BRA ANDDN  
000019BC                           853  
000019BC                           854  ;  Here we assume that these left-most nybble has been confirmed: 1011  
000019BC                           855  CMP        
000019BC  2C05                     856              MOVE.L  D5,D6               ; Push D5 into D6
000019BE  EC9E                     857              ROR.L   #6,D6               ; Rotate 6 bits to the right
000019C0  E38E                     858              LSL.L   #1,D6               ; Add 0 to right most bit
000019C2  0206 000F                859              ANDI.B  #$0F,D6             ; Isolate right-most nybble
000019C6                           860              
000019C6  BC3C 0000                861              CMP.B   #$00,D6             ; If it matches CMP.B's size bit + 0 added to right
000019CA  6700 0016                862              BEQ     CMPB                ; First 4 left-most bits plus size of CMP confirmed
000019CE                           863  
000019CE  BC3C 0002                864              CMP.B   #$02,D6             ; If it matches CMP.W's size bit + 0 added to right
000019D2  6700 0024                865              BEQ     CMPW                ; First 4 left-most bits plus size of CMP confirmed 
000019D6                           866  
000019D6  BC3C 0004                867              CMP.B   #$04,D6             ; If it matches CMP.B's size bit + 0 added to right
000019DA  6700 0032                868              BEQ     CMPL                ; First 4 left-most bits plus size of CMP confirmed 
000019DE                           869   
000019DE  6000 0442                870              BRA     UNKNOWN             ; else unknown 
000019E2                           871  
000019E2                           872  ;  Here we assume that confirming these bits, 1011 --- 000 --- ---, is enough to identify CMP.B 
000019E2  32FC 434D                873  CMPB        MOVE.W  #'CM',(A1)+
000019E6  12FC 0050                874              MOVE.B  #'P',(A1)+
000019EA  12FC 002E                875              MOVE.B  #'.',(A1)+
000019EE  12FC 0042                876              MOVE.B  #'B',(A1)+
000019F2  5A41                     877              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
000019F4  6000 002E                878              BRA     CMPOP
000019F8                           879  
000019F8                           880  ;  Here we assume that confirming these bits, 1011 --- 001 --- ---, is enough to identify CMP.W   
000019F8  32FC 434D                881  CMPW        MOVE.W  #'CM',(A1)+
000019FC  12FC 0050                882              MOVE.B  #'P',(A1)+
00001A00  12FC 002E                883              MOVE.B  #'.',(A1)+
00001A04  12FC 0057                884              MOVE.B  #'W',(A1)+
00001A08  5A41                     885              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
00001A0A  6000 0018                886              BRA     CMPOP
00001A0E                           887              
00001A0E                           888  ;  Here we assume that confirming these bits, 1011 --- 010 --- ---, is enough to identify CMP.L
00001A0E  32FC 434D                889  CMPL        MOVE.W  #'CM',(A1)+
00001A12  12FC 0050                890              MOVE.B  #'P',(A1)+
00001A16  12FC 002E                891              MOVE.B  #'.',(A1)+
00001A1A  12FC 004C                892              MOVE.B  #'L',(A1)+
00001A1E  5A41                     893              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
00001A20  6000 0002                894              BRA     CMPOP
00001A24                           895              
00001A24  12FC 0020                896  CMPOP       MOVE.B  #' ',(A1)+
00001A28  32FC 2020                897              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
00001A2C  32FC 2020                898              MOVE.W  #'  ',(A1)+
00001A30  5A41                     899              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces
00001A32                           900              
00001A32  2C05                     901              MOVE.L  D5,D6               ; Push D5 into D6
00001A34  0286 0000003F            902              ANDI.L  #$003F,D6           ; Isolate the Src EA bits 
00001A3A  4EB9 00001E46            903              JSR EAGETSRCEA              ; Find and print the code stored in D6
00001A40                           904              
00001A40  12FC 002C                905              MOVE.B  #',',(A1)+
00001A44  5241                     906              ADDQ    #1,D1
00001A46                           907              
00001A46  2C05                     908              MOVE.L  D5,D6               ; Copy D5 into D6
00001A48  E09E                     909              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00001A4A  E29E                     910              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00001A4C  0286 00000003            911              ANDI.L  #$0003,D6           ; Isolate the Dn Destination bits
00001A52  4EF9 00001EC2            912              JMP EADN
00001A58                           913              
00001A58  4E75                     914              RTS          
00001A5A                           915          
00001A5A                           916  ; This label determines if the code is either MULS or AND, by looking at it's size bits     
00001A5A  2C05                     917  MULSAND     MOVE.L  D5,D6               ; Copy D5 into D6
00001A5C  EC8E                     918              LSR.L   #6,D6               ; Shift the size bits to the far right
00001A5E  0206 0007                919              ANDI.B  #$7,D6              ; Isolate the size bits
00001A62  BC3C 0007                920              CMP.B   #7,D6               ; See if the size is '111'..
00001A66  6704                     921              BEQ.S   MULS                ; ..If so, it's a MULS opcode
00001A68  6000 003E                922              BRA     AND                 ; Otherwise, it's an AND code
00001A6C                           923          
00001A6C  22FC 4D554C53            924  MULS        MOVE.L  #'MULS',(A1)+
00001A72  5841                     925              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001A74                           926              
00001A74  22FC 20202020            927              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
00001A7A  32FC 2020                928              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
00001A7E  5C41                     929              ADDQ    #6,D1               ; We added 4 bytes, aka 4 spaces
00001A80                           930              
00001A80  2C05                     931              MOVE.L  D5,D6               ; Copy D5 into D6
00001A82  0286 0000003F            932              ANDI.L  #$003F,D6           ; Isolate the Src EA bits
00001A88  4EB9 00001E46            933              JSR EAGETSRCEA
00001A8E                           934              
00001A8E  12FC 002C                935              MOVE.B  #',',(A1)+
00001A92  5241                     936              ADDQ    #1,D1
00001A94                           937              
00001A94  2C05                     938              MOVE.L  D5,D6               ; Copy D5 into D6
00001A96  E09E                     939              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00001A98  E29E                     940              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00001A9A  0286 00000007            941              ANDI.L  #$0007,D6           ; Isolate the Dn Destination bits
00001AA0  4EF9 00001EC2            942              JMP EADN
00001AA6                           943              
00001AA6  4E75                     944              RTS
00001AA8                           945              
00001AA8                           946  ; At this point, we know D6 is the size of our opcode
00001AA8  BC3C 0006                947  AND         CMP.B   #%0110,D6            ; See if D6 is size "%100" through "%110"..
00001AAC  6700 002E                948              BEQ     ANDLEA              ; If it is, our OpCode is in the format of..
00001AB0  BC3C 0005                949              CMP.B   #%101,D6            ; .. Dn ~ <EA> --> <EA>
00001AB4  6700 0036                950              BEQ     ANDWEA
00001AB8  BC3C 0004                951              CMP.B   #%100,D6
00001ABC  6700 003E                952              BEQ     ANDBEA
00001AC0                           953              
00001AC0  BC3C 0002                954              CMP.B   #%10,D6             ; See if D6 is size "%000" through "%010"..
00001AC4  6700 007C                955              BEQ     ANDLDN              ; If it is, our OpCode is in the format of..
00001AC8  BC3C 0001                956              CMP.B   #%01,D6             ; .. <EA> ~ Dn --> Dn
00001ACC  6700 0086                957              BEQ     ANDWDN
00001AD0  BC3C 0000                958              CMP.B   #%00,D6
00001AD4  6700 0090                959              BEQ     ANDBDN              ; == 000 at this point
00001AD8                           960              
00001AD8  6000 0348                961              BRA     UNKNOWN
00001ADC                           962              
00001ADC  22FC 414E442E            963  ANDLEA      MOVE.L  #'AND.',(A1)+
00001AE2  12FC 004C                964              MOVE.B  #'L',(A1)+
00001AE6  5A41                     965              ADDQ    #5,D1               ; We added 5 byte into D1
00001AE8  6000 0022                966              BRA     ANDEA
00001AEC                           967              
00001AEC  22FC 414E442E            968  ANDWEA      MOVE.L  #'AND.',(A1)+
00001AF2  12FC 0057                969              MOVE.B  #'W',(A1)+
00001AF6  5A41                     970              ADDQ    #5,D1               ; We added 5 byte into D1
00001AF8  6000 0012                971              BRA     ANDEA
00001AFC                           972  
00001AFC  22FC 414E442E            973  ANDBEA      MOVE.L  #'AND.',(A1)+
00001B02  12FC 0042                974              MOVE.B  #'B',(A1)+
00001B06  5A41                     975              ADDQ    #5,D1               ; We added 5 byte into D1
00001B08  6000 0002                976              BRA     ANDEA
00001B0C                           977  
00001B0C  12FC 0020                978  ANDEA       MOVE.B  #' ',(A1)+          ; Add a spacer into our IOStringLoc
00001B10  32FC 2020                979              MOVE.W  #'  ',(A1)+          ; Add a spacer into our IOStringLoc
00001B14  12FC 0020                980              MOVE.B  #' ',(A1)+          ; Add a spacer into our IOStringLoc
00001B18  5241                     981              ADDQ    #1,D1               ; We added 4 bytes, aka 4 spaces
00001B1A                           982              
00001B1A  2C05                     983              MOVE.L  D5,D6
00001B1C  E08E                     984              LSR.L   #8,D6               ; Shift our OpCode a total of 9 bits to the right
00001B1E  E28E                     985              LSR.L   #1,D6               ; 
00001B20  0286 00000007            986              ANDI.L  #$07,D6             ; Isolate our data register
00001B26                           987              
00001B26  4EB9 00001EC2            988              JSR EADN
00001B2C                           989              
00001B2C  12FC 002C                990              MOVE.B  #',',(A1)+
00001B30  5241                     991              ADDQ    #1,D1
00001B32                           992              
00001B32  2C05                     993              MOVE.L  D5,D6               ; Copy our OpCode again
00001B34  0286 0000003F            994              ANDI.L  #$3F,D6             ; Isolate our EA bits
00001B3A                           995              
00001B3A  4EB9 00001E46            996              JSR EAGETSRCEA  
00001B40                           997              
00001B40  4E75                     998              RTS
00001B42                           999              
00001B42  22FC 414E442E           1000  ANDLDN      MOVE.L  #'AND.',(A1)+
00001B48  5841                    1001              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001B4A  12FC 004C               1002              MOVE.B  #'L',(A1)+
00001B4E  5241                    1003              ADDQ    #1,D1               ; We added 1 byte into D1
00001B50  6000 0026               1004              BRA ANDDN
00001B54                          1005              
00001B54  22FC 414E442E           1006  ANDWDN      MOVE.L  #'AND.',(A1)+
00001B5A  5841                    1007              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001B5C  12FC 0057               1008              MOVE.B  #'W',(A1)+
00001B60  5241                    1009              ADDQ    #1,D1               ; We added 1 byte into D1
00001B62  6000 0014               1010              BRA ANDDN
00001B66                          1011  
00001B66  22FC 414E442E           1012  ANDBDN      MOVE.L  #'AND.',(A1)+
00001B6C  5841                    1013              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001B6E  12FC 0042               1014              MOVE.B  #'B',(A1)+
00001B72  5241                    1015              ADDQ    #1,D1               ; We added 1 byte into D1
00001B74  6000 0002               1016              BRA ANDDN  
00001B78                          1017  
00001B78                          1018  ANDDN
00001B78  12FC 0009               1019              MOVE.B  #$09,(A1)+          ; Add a spacer into our IOStringLoc
00001B7C  5241                    1020              ADDQ    #1,D1               ; We added 4 bytes, aka 4 spaces
00001B7E                          1021              
00001B7E  2C05                    1022              MOVE.L  D5,D6               ; Copy our OpCode again
00001B80  0286 0000003F           1023              ANDI.L  #$3F,D6             ; Isolate our EA bits
00001B86                          1024              
00001B86  4EB9 00001E46           1025              JSR EAGETSRCEA              
00001B8C                          1026              
00001B8C  12FC 002C               1027              MOVE.B  #',',(A1)+
00001B90  5241                    1028              ADDQ    #1,D1
00001B92                          1029              
00001B92  2C05                    1030              MOVE.L  D5,D6
00001B94  E08E                    1031              LSR.L   #8,D6               ; Shift our OpCode a total of 9 bits to the right
00001B96  E28E                    1032              LSR.L   #1,D6               ; 
00001B98  0286 00000007           1033              ANDI.L  #$07,D6             ; Isolate our data register
00001B9E                          1034              
00001B9E  4EB9 00001EC2           1035              JSR EADN
00001BA4                          1036              
00001BA4  4E75                    1037              RTS
00001BA6                          1038  
00001BA6                          1039  ; This label determines if the code is either ADD or ADDA           
00001BA6  2C05                    1040  ADDADDA     MOVE.L  D5,D6               ; Copy D5 into D6
00001BA8  EC8E                    1041              LSR.L   #6,D6               ; Shift the size bits to the far right
00001BAA  0206 0007               1042              ANDI.B  #$7,D6              ; Isolate the size bits
00001BAE                          1043              
00001BAE  BC3C 0006               1044              CMP.B   #%0110,D6           ; See if D6 is size "%100" through "%110"..
00001BB2  6700 0074               1045              BEQ     ADDLEA              ; If it is, our OpCode is in the format of..
00001BB6  BC3C 0005               1046              CMP.B   #%101,D6            ; .. Dn ~ <EA> --> <EA>
00001BBA  6700 007E               1047              BEQ     ADDWEA
00001BBE  BC3C 0004               1048              CMP.B   #%100,D6
00001BC2  6700 0088               1049              BEQ     ADDBEA
00001BC6                          1050              
00001BC6  BC3C 0002               1051              CMP.B   #%10,D6             ; See if D6 is size "%000" through "%010"..
00001BCA  6700 0026               1052              BEQ     ADDLDN              ; If it is, our OpCode is in the format of..
00001BCE  BC3C 0001               1053              CMP.B   #%01,D6             ; .. <EA> ~ Dn --> Dn
00001BD2  6700 0030               1054              BEQ     ADDWDN
00001BD6  BC3C 0000               1055              CMP.B   #%00,D6
00001BDA  6700 003A               1056              BEQ     ADDBDN              ; == 000 at this point
00001BDE                          1057              
00001BDE  BC3C 0003               1058              CMP.B   #%011,D6            ; ADDA Word Operation <EA> -> An 
00001BE2  6700 007A               1059              BEQ     ADDAW
00001BE6  BC3C 0007               1060              CMP.B   #%111,D6            ; ADDA Word Operation <EA> -> An  
00001BEA  6700 0084               1061              BEQ     ADDAL
00001BEE  6000 0232               1062              BRA     UNKNOWN
00001BF2                          1063              
00001BF2  22FC 4144442E           1064  ADDLDN      MOVE.L  #'ADD.',(A1)+
00001BF8  5841                    1065              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001BFA  12FC 004C               1066              MOVE.B  #'L',(A1)+
00001BFE  5241                    1067              ADDQ    #1,D1               ; We added 1 byte into D1
00001C00  6000 FF76               1068              BRA ANDDN
00001C04                          1069              
00001C04  22FC 4144442E           1070  ADDWDN      MOVE.L  #'ADD.',(A1)+
00001C0A  5841                    1071              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001C0C  12FC 0057               1072              MOVE.B  #'W',(A1)+
00001C10  5241                    1073              ADDQ    #1,D1               ; We added 1 byte into D1
00001C12  6000 FF64               1074              BRA ANDDN
00001C16                          1075  
00001C16  22FC 4144442E           1076  ADDBDN      MOVE.L  #'ADD.',(A1)+
00001C1C  5841                    1077              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001C1E  12FC 0042               1078              MOVE.B  #'B',(A1)+
00001C22  5241                    1079              ADDQ    #1,D1               ; We added 1 byte into D1
00001C24  6000 FF52               1080              BRA ANDDN  
00001C28                          1081              
00001C28  22FC 4144442E           1082  ADDLEA      MOVE.L  #'ADD.',(A1)+
00001C2E  5841                    1083              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001C30  12FC 004C               1084              MOVE.B  #'L',(A1)+
00001C34  5241                    1085              ADDQ    #1,D1               ; We added 1 byte into D1
00001C36  6000 FED4               1086              BRA     ANDEA
00001C3A                          1087              
00001C3A  22FC 4144442E           1088  ADDWEA      MOVE.L  #'ADD.',(A1)+
00001C40  5841                    1089              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001C42  12FC 0057               1090              MOVE.B  #'W',(A1)+
00001C46  5241                    1091              ADDQ    #1,D1               ; We added 1 byte into D1
00001C48  6000 FEC2               1092              BRA     ANDEA
00001C4C                          1093  
00001C4C  22FC 4144442E           1094  ADDBEA      MOVE.L  #'ADD.',(A1)+
00001C52  5841                    1095              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001C54  12FC 0042               1096              MOVE.B  #'B',(A1)+
00001C58  5241                    1097              ADDQ    #1,D1               ; We added 1 byte into D1
00001C5A  6000 FEB0               1098              BRA     ANDEA
00001C5E                          1099              
00001C5E  22FC 41444441           1100  ADDAW       MOVE.L  #'ADDA',(A1)+
00001C64  5841                    1101              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001C66  32FC 2E57               1102              MOVE.W  #'.W',(A1)+
00001C6A  5441                    1103              ADDQ    #2,D1               ; We added 1 byte into D1
00001C6C  6000 0014               1104              BRA     ADDAN
00001C70                          1105              
00001C70  22FC 41444441           1106  ADDAL       MOVE.L  #'ADDA',(A1)+
00001C76  5841                    1107              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001C78  32FC 2E4C               1108              MOVE.W  #'.L',(A1)+
00001C7C  5441                    1109              ADDQ    #2,D1               ; We added 1 byte into D1
00001C7E  6000 0002               1110              BRA     ADDAN
00001C82                          1111         
00001C82                          1112  ADDAN
00001C82  22FC 20202020           1113              MOVE.L  #'    ',(A1)+          ; Add a spacer into our IOStringLoc
00001C88                          1114              
00001C88  5841                    1115              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
00001C8A                          1116              
00001C8A  2C05                    1117              MOVE.L  D5,D6               ; Copy our OpCode again
00001C8C  0286 0000003F           1118              ANDI.L  #$3F,D6             ; Isolate our EA bits
00001C92                          1119              
00001C92  4EB9 00001E46           1120              JSR EAGETSRCEA              
00001C98                          1121              
00001C98  12FC 002C               1122              MOVE.B  #',',(A1)+
00001C9C  5241                    1123              ADDQ    #1,D1
00001C9E                          1124              
00001C9E  2C05                    1125              MOVE.L  D5,D6
00001CA0  E08E                    1126              LSR.L   #8,D6               ; Shift our OpCode a total of 9 bits to the right
00001CA2  E28E                    1127              LSR.L   #1,D6               ; 
00001CA4  0286 00000007           1128              ANDI.L  #$07,D6             ; Isolate our data register
00001CAA                          1129              
00001CAA  4EB9 00001ED0           1130              JSR EAAN
00001CB0                          1131              
00001CB0  4E75                    1132              RTS
00001CB2                          1133  ; This label determines if the code is either ASd (ASR) or LSd (LSL) or ROd (ROL) 
00001CB2                          1134  ASLSRO
00001CB2  2C05                    1135              MOVE.L  D5,D6               ; Copy our OpCode
00001CB4  EC4E                    1136              LSR.W   #6,D6               ; Shift our size bits into place
00001CB6  0206 0003               1137              ANDI.B  #$03,D6             ; Isolate our size bits
00001CBA  BC3C 0003               1138              CMP.B   #%11,D6             ; If our size is '11'..
00001CBE  6700 00E2               1139              BEQ     AASLSRO             ; ..this is an address ASLSRO
00001CC2                          1140              
00001CC2  2C05                    1141              MOVE.L  D5,D6               ; Copy our OpCode
00001CC4  E64E                    1142              LSR.W   #3,D6               ; Shift our identification bits over
00001CC6  0206 0003               1143              ANDI.B  #03,D6              ;  and isolate them
00001CCA                          1144              
00001CCA  BC3C 0000               1145              CMP.B   #%00,D6             ; If '00', this is a ASd op
00001CCE  6700 0016               1146              BEQ     ASD
00001CD2  BC3C 0001               1147              CMP.B   #%01,D6             ; If '01', this is a LSd op
00001CD6  6700 0018               1148              BEQ     LSD
00001CDA  BC3C 0003               1149              CMP.B   #%11,D6             ; If '11', this is a ROd op
00001CDE  6700 001A               1150              BEQ     ROD
00001CE2                          1151              
00001CE2  6000 013E               1152              BRA     UNKNOWN             ; This catches for ROX, non-required op
00001CE6                          1153  
00001CE6  32FC 4153               1154  ASD         MOVE.W  #'AS',(A1)+
00001CEA  5441                    1155              ADDQ    #2,D1
00001CEC  6000 0016               1156              BRA     ASLSRODR
00001CF0                          1157              
00001CF0  32FC 4C53               1158  LSD         MOVE.W  #'LS',(A1)+
00001CF4  5441                    1159              ADDQ    #2,D1
00001CF6  6000 000C               1160              BRA     ASLSRODR
00001CFA                          1161              
00001CFA  32FC 524F               1162  ROD         MOVE.W  #'RO',(A1)+
00001CFE  5441                    1163              ADDQ    #2,D1
00001D00  6000 0002               1164              BRA     ASLSRODR
00001D04                          1165              
00001D04                          1166  ; This section checks our ASd/LSd/ROd direction, and defaults to Right 
00001D04  2C05                    1167  ASLSRODR    MOVE.L  D5,D6               ; Copy our OpCode
00001D06  E09E                    1168              ROR.L   #8,D6               ; Shift our direction bit into place
00001D08  0806 0000               1169              BTST    #$00,D6             ; Check our right-most bit 
00001D0C  6600 0010               1170              BNE     ASLSRODL            ; If it's '1', our direction is left
00001D10                          1171              
00001D10  12FC 0052               1172              MOVE.B  #'R',(A1)+          ; Otherwise it's right
00001D14  12FC 002E               1173              MOVE.B  #'.',(A1)+
00001D18  5441                    1174              ADDQ    #2,D1
00001D1A                          1175              
00001D1A  6000 000C               1176              BRA ASLSROSIZE
00001D1E                          1177              
00001D1E                          1178  ; This section is our ASd/LSd/ROd left direction
00001D1E  12FC 004C               1179  ASLSRODL    MOVE.B  #'L',(A1)+          ; L for Left
00001D22  12FC 002E               1180              MOVE.B  #'.',(A1)+
00001D26  5441                    1181              ADDQ    #2,D1
00001D28                          1182              ; Carry into our Size determiner
00001D28                          1183  ; Determines what size our ASd/LSd/ROd is
00001D28                          1184  ;  Our previous operations on D6 leave our size bits
00001D28                          1185  ;  just our of range, so we shift them in
00001D28                          1186  ASLSROSIZE  
00001D28  E59E                    1187              ROL.L   #2,D6               ; Shift our size bits in
00001D2A  0206 0003               1188              ANDI.B  #$03,D6             ; Isolate our size bits
00001D2E  BC3C 0000               1189              CMP.B   #%00,D6             ; If our size is '00'..
00001D32  6700 0012               1190              BEQ     ASLSROB             ; ..Then it's a byte op
00001D36  BC3C 0001               1191              CMP.B   #%01,D6             ; If our size is '01'..
00001D3A  6700 0012               1192              BEQ     ASLSROW             ; ..Then it's a word op
00001D3E                          1193              ; Otherwise it's a long op, because we accounted for '11' earlier
00001D3E                          1194              
00001D3E  12FC 004C               1195              MOVE.B  #'L',(A1)+          ; Add L for Long
00001D42  6000 000E               1196              BRA     ASLSROIR            ; Complete the rest of the ASLSRO Op
00001D46                          1197              
00001D46  12FC 0042               1198  ASLSROB     MOVE.B  #'B',(A1)+          ; Add B for Byte
00001D4A  6000 0006               1199              BRA     ASLSROIR            ; Complete the rest of the ASLSRO Op
00001D4E                          1200              
00001D4E  12FC 0057               1201  ASLSROW     MOVE.B  #'W',(A1)+          ; Add W for Word
00001D52                          1202              ; Carry through to complete the rest of the ASLSRO Op  
00001D52                          1203       
00001D52                          1204  ; This section determines if our ASLSRO is an Immediate or Dn shfit, and defaults to Immediate
00001D52  12FC 0020               1205  ASLSROIR    MOVE.B  #' ',(A1)+
00001D56  32FC 2020               1206              MOVE.W  #'  ',(A1)+
00001D5A  32FC 2020               1207              MOVE.W  #'  ',(A1)+
00001D5E  5C41                    1208              ADDQ    #6,D1               ; We've added 5 new characters (Size char, plus spaces)
00001D60                          1209              
00001D60                          1210              ;MOVE.L  D5,D6
00001D60  E39E                    1211              ROL.L   #1,D6               ; Get our Immediate / Register bit out front
00001D62  0806 0000               1212              BTST.L  #$00,D6
00001D66  6600 000C               1213              BNE     ASLSROIRDN          ; If it's '1', we have a Dn ASLSRO
00001D6A                          1214              ; Otherwise, assume immediate ASLSRO
00001D6A  12FC 0023               1215              MOVE.B  #'#',(A1)+
00001D6E  5241                    1216              ADDQ    #1,D1
00001D70  6000 0008               1217              BRA     ASLSROOP            ; Branch to our ASLSRO Op finish
00001D74                          1218  ; An ASLSRO of Dn Register type   
00001D74  12FC 0044               1219  ASLSROIRDN  MOVE.B  #'D',(A1)+
00001D78  5241                    1220              ADDQ    #1,D1
00001D7A                          1221              ; Continue through to our ASLSRO Op finish
00001D7A                          1222  ; Finishes the ASLSRO Op
00001D7A                          1223  ASLSROOP
00001D7A  2C05                    1224              MOVE.L  D5,D6               ; Copy our OpCode into D6
00001D7C  E09E                    1225              ROR.L   #8,D6               ; Shift our Count/Reg bits into place
00001D7E  E29E                    1226              ROR.L   #1,D6               ;
00001D80  0206 0007               1227              ANDI.B  #$07,D6             ; Isolate the Count/Reg bits
00001D84                          1228              
00001D84  0606 0030               1229              ADDI.B  #48,D6 
00001D88  12C6                    1230              MOVE.B  D6,(A1)+            ; Push our number to the IOStringLoc
00001D8A  5241                    1231              ADDQ    #1,D1
00001D8C                          1232              
00001D8C  12FC 002C               1233              MOVE.B  #',',(A1)+
00001D90  5241                    1234              ADDQ    #1,D1
00001D92                          1235              
00001D92  2C05                    1236              MOVE.L  D5,D6               ; Isolate our Dn affected num bits
00001D94  0286 00000007           1237              ANDI.L  #$07,D6             ;
00001D9A  4EB9 00001EC2           1238              JSR     EADN
00001DA0                          1239              
00001DA0  4E75                    1240              RTS
00001DA2                          1241  ; Start of the Effective Address version of ASLSRO
00001DA2  2C05                    1242  AASLSRO     MOVE.L  D5,D6               ; Copy our OpCode into D6
00001DA4  EF5E                    1243              ROL.W   #7,D6               ; Shift our determination bits to the far right
00001DA6  0206 0007               1244              ANDI.B  #$07,D6             ; Isolate the determination bits   
00001DAA                          1245              
00001DAA  BC3C 0001               1246              CMP.B   #$01,D6             ; If our determination is '001'..
00001DAE  6700 0020               1247              BEQ     ALSD                ; It's a Logical Shift
00001DB2  BC3C 0003               1248              CMP.B   #$03,D6             ; If it's '011'
00001DB6  6700 0022               1249              BEQ     AROD                ; It's a Rotation 
00001DBA  BC3C 0000               1250              CMP.B   #$00,D6             ; If it's '000'
00001DBE  6700 0006               1251              BEQ     AASD                ; It's an Arithmetic Shift
00001DC2                          1252              
00001DC2  6000 005E               1253              BRA     UNKNOWN              ; Otherwise it's data
00001DC6                          1254  
00001DC6  32FC 4153               1255  AASD        MOVE.W  #'AS',(A1)+
00001DCA  5441                    1256              ADDQ    #2,D1
00001DCC  6000 0016               1257              BRA     AASLSRODR
00001DD0                          1258              
00001DD0  32FC 4C53               1259  ALSD        MOVE.W  #'LS',(A1)+
00001DD4  5441                    1260              ADDQ    #2,D1
00001DD6  6000 000C               1261              BRA     AASLSRODR
00001DDA                          1262              
00001DDA  32FC 524F               1263  AROD        MOVE.W  #'RO',(A1)+
00001DDE  5441                    1264              ADDQ    #2,D1
00001DE0  6000 0002               1265              BRA     AASLSRODR
00001DE4                          1266              
00001DE4                          1267  ; This section checks our ASd/LSd/ROd direction, and defaults to Right 
00001DE4  2C05                    1268  AASLSRODR   MOVE.L  D5,D6              ; Copy our OpCode
00001DE6  E09E                    1269              ROR.L   #8,D6               ; Shift our direction bit into place
00001DE8  0806 0000               1270              BTST    #$00,D6             ; Check our right-most bit 
00001DEC  6600 000C               1271              BNE     AASLSRODL           ; If it's '1', our direction is left
00001DF0                          1272              
00001DF0  12FC 0052               1273              MOVE.B  #'R',(A1)+          ; Otherwise it's right
00001DF4  5241                    1274              ADDQ    #1,D1
00001DF6                          1275              
00001DF6  6000 0008               1276              BRA AASLSROOP
00001DFA                          1277              
00001DFA                          1278  ; This section is our ASd/LSd/ROd left direction
00001DFA  12FC 004C               1279  AASLSRODL   MOVE.B  #'L',(A1)+          ; L for Left
00001DFE  5241                    1280              ADDQ    #1,D1
00001E00                          1281              ; Carry into finishing AASLSRO op
00001E00                          1282  
00001E00                          1283  ; This section finishes off our Effective Address ASLSRO Op
00001E00  2C05                    1284  AASLSROOP   MOVE.L  D5,D6               ; Copy our OpCode
00001E02  0286 0000003F           1285              ANDI.L  #$3F,D6             ; Isolate our EA bits
00001E08                          1286              
00001E08  12FC 0020               1287              MOVE.B  #' ',(A1)+
00001E0C  12FC 0020               1288              MOVE.B  #' ',(A1)+
00001E10  12FC 0020               1289              MOVE.B  #' ',(A1)+
00001E14  12FC 0020               1290              MOVE.B  #' ',(A1)+
00001E18  5841                    1291              ADDQ    #4,D1
00001E1A                          1292              
00001E1A  4EB9 00001E46           1293              JSR EAGETSRCEA
00001E20                          1294              
00001E20  4E75                    1295              RTS
00001E22                          1296  UNKNOWN
00001E22  22FC 44415441           1297              MOVE.L  #'DATA',(A1)+
00001E28  5841                    1298              ADDQ    #4,D1           ; We added 4 new characters to our IOStringLoc 
00001E2A                          1299              
00001E2A  22FC 20202020           1300              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
00001E30  32FC 2020               1301              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
00001E34  5C41                    1302              ADDQ    #6,D1               ; We added 6 bytes, aka 6 spaces
00001E36                          1303              
00001E36  12FC 0024               1304              MOVE.B  #'$',(A1)+
00001E3A  5241                    1305              ADDQ    #1,D1
00001E3C                          1306              
00001E3C  2C05                    1307              MOVE.L  D5,D6
00001E3E  4EB9 00001F80           1308              JSR     EAHEXtoASCII
00001E44                          1309              
00001E44  4E75                    1310              RTS
00001E46                          1311  
00001E46                          1312  
00001E46                          1313  
00001E46                          1314  
00001E46                          1315  
00001E46                          1316  
00001E46                          1317  
00001E46                          1318  
00001E46                          1319  
00001E46                          1320  
00001E46                          1321  -------------------- end include --------------------
00001E46                          1322      INCLUDE "EA.X68"        ; Handles EA types
00001E46                          1323  
00001E46                          1324  
00001E46                          1325  ; It is assumed that D6 contains the bits for the EA, algined to the far right. D5 contains
00001E46                          1326  ;  the original full op-code being reffered to. We assume that A2 contains the address 
00001E46                          1327  ;  pointing to the start of our EA address (if applicable), and we assume that A1 contains
00001E46                          1328  ;  the address pointing to our IOStringLoc. D1 contains the current length to be printed from A1
00001E46                          1329  
00001E46                          1330  ; For this method, D6 is in the format of: <3 bits Src Mode><3 bits Src Reg> 
00001E46                          1331  EAGETSRCEA  
00001E46  E69E                    1332      ROR.L   #3,D6       ; Rotate our bits 3 to the right
00001E48  1E06                    1333      MOVE.B  D6,D7       ; Store the mode of the EA in D7
00001E4A  E79E                    1334      ROL.L   #3,D6       ; Rotate our 3 bits back
00001E4C  0286 00000007           1335      ANDI.L  #$0007,D6   ; Isolate the 3 rightmost bits as 'Reg'
00001E52  BE3C 0000               1336      CMP.B   #0,D7       ; See if the mode == '000'
00001E56  6700 006A               1337      BEQ     EADN
00001E5A                          1338  
00001E5A  BE3C 0001               1339      CMP.B   #1,D7       ; See if the mode == '001'
00001E5E  6700 0070               1340      BEQ     EAAN        ; Address Register Direct
00001E62                          1341      
00001E62  BE3C 0002               1342      CMP.B   #2,D7       ; See if the mode == '010'
00001E66  6700 0076               1343      BEQ     EAANI       ; Address Register Indirect
00001E6A                          1344      
00001E6A  BE3C 0003               1345      CMP.B   #3,D7       ; See if the mode == '011'
00001E6E  6700 0084               1346      BEQ     EAAPOST     ; Address Register Indirect with Post increment
00001E72                          1347      
00001E72  BE3C 0004               1348      CMP.B   #4,D7       ; See if the mode == '100'
00001E76  6700 0096               1349      BEQ     EAAPRE      ; Address Register Indirect with Pre increment
00001E7A                          1350      
00001E7A  BE3C 0007               1351      CMP.B   #7,D7       ; See if the mode == '111' 
00001E7E  6700 00EA               1352      BEQ     EA111       ; Determine if (Immediate Data, Aboslute Word or Long Address)
00001E82                          1353  
00001E82  6000 02F4               1354      BRA     EAUNKN
00001E86                          1355  
00001E86                          1356  ; For this method, D6 is in the format of: <3 bits Dst Reg><3 bits Dst Mode> 
00001E86                          1357  EAGETDSTEA  
00001E86  1E06                    1358      MOVE.B  D6,D7       ; Store the right-most byte into D7
00001E88  CE3C 0007               1359      AND.B   #$07,D7     ; Isolate 3 rightmost bits as 'Mode'
00001E8C  E68E                    1360      LSR.L   #3,D6       ; Shift D6 to the right 3 bits (D6 Byte = 'Reg')
00001E8E  BE3C 0000               1361      CMP.B   #0,D7       ; See if the mode == '000'
00001E92  6700 002E               1362      BEQ     EADN
00001E96                          1363  
00001E96  BE3C 0001               1364      CMP.B   #1,D7       ; See if the mode == '001'
00001E9A  6700 0034               1365      BEQ     EAAN        ; Address Register Direct
00001E9E                          1366      
00001E9E  BE3C 0002               1367      CMP.B   #2,D7       ; See if the mode == '010'
00001EA2  6700 003A               1368      BEQ     EAANI       ; Address Register Indirect
00001EA6                          1369      
00001EA6  BE3C 0003               1370      CMP.B   #3,D7       ; See if the mode == '011'
00001EAA  6700 0048               1371      BEQ     EAAPOST     ; Address Register Indirect with Post increment
00001EAE                          1372      
00001EAE  BE3C 0004               1373      CMP.B   #4,D7       ; See if the mode == '100'
00001EB2  6700 005A               1374      BEQ     EAAPRE      ; Address Register Indirect with Pre increment
00001EB6                          1375      
00001EB6  BE3C 0007               1376      CMP.B   #7,D7       ; See if the mode == '111' 
00001EBA  6700 00AE               1377      BEQ     EA111       ; Determine if (Immediate Data, Aboslute Word or Long Address)
00001EBE                          1378  
00001EBE  6000 02B8               1379      BRA     EAUNKN
00001EC2                          1380           
00001EC2                          1381  ;If the EA is a Dn EA    
00001EC2                          1382  ;This method assume D6 contains the Reg for Dn  
00001EC2                          1383  EADN
00001EC2  12FC 0044               1384      MOVE.B  #'D',(A1)+
00001EC6  0606 0030               1385      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
00001ECA  12C6                    1386      MOVE.B  D6,(A1)+
00001ECC  5441                    1387      ADDQ    #2,D1
00001ECE  4E75                    1388      RTS
00001ED0                          1389  ;If the EA is a An EA    
00001ED0                          1390  ;This method assume D6 contains the Reg for An  
00001ED0                          1391  EAAN
00001ED0  12FC 0041               1392      MOVE.B  #'A',(A1)+
00001ED4  0606 0030               1393      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
00001ED8  12C6                    1394      MOVE.B  D6,(A1)+
00001EDA  5441                    1395      ADDQ    #2,D1
00001EDC  4E75                    1396      RTS
00001EDE                          1397  
00001EDE                          1398  ;If the EA is a (An) EA    
00001EDE                          1399  ;This method assume D6 contains the Reg for (An)  
00001EDE                          1400  EAANI
00001EDE  12FC 0028               1401      MOVE.B  #'(',(A1)+
00001EE2  12FC 0041               1402      MOVE.B  #'A',(A1)+
00001EE6  0606 0030               1403      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
00001EEA  12C6                    1404      MOVE.B  D6,(A1)+
00001EEC  12FC 0029               1405      MOVE.B  #')',(A1)+
00001EF0  5841                    1406      ADDQ    #4,D1
00001EF2  4E75                    1407      RTS
00001EF4                          1408  ;If the EA is a (An)+ EA    
00001EF4                          1409  ;This method assume D6 contains the Reg for (An)+  
00001EF4                          1410  EAAPOST
00001EF4  12FC 0028               1411      MOVE.B  #'(',(A1)+
00001EF8  12FC 0041               1412      MOVE.B  #'A',(A1)+
00001EFC  0606 0030               1413      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
00001F00  12C6                    1414      MOVE.B  D6,(A1)+
00001F02  12FC 0029               1415      MOVE.B  #')',(A1)+
00001F06  12FC 002B               1416      MOVE.B  #'+',(A1)+
00001F0A  5A41                    1417      ADDQ    #5,D1
00001F0C  4E75                    1418      RTS
00001F0E                          1419  ;If the EA is a -(An) EA    
00001F0E                          1420  ;This method assume D6 contains the Reg for -(An) 
00001F0E                          1421  EAAPRE
00001F0E  12FC 002D               1422      MOVE.B  #'-',(A1)+
00001F12  12FC 0028               1423      MOVE.B  #'(',(A1)+
00001F16  12FC 0041               1424      MOVE.B  #'A',(A1)+
00001F1A  0606 0030               1425      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
00001F1E  12C6                    1426      MOVE.B  D6,(A1)+
00001F20  12FC 0029               1427      MOVE.B  #')',(A1)+
00001F24  5A41                    1428      ADDQ    #5,D1
00001F26  4E75                    1429      RTS 
00001F28                          1430  ;If the EA is a #<data> EA    
00001F28                          1431  ;This method assume D6 contains the Reg for #<data>  
00001F28                          1432  EAID
00001F28  32FC 2324               1433      MOVE.W  #'#$',(A1)+
00001F2C  5441                    1434      ADDQ    #2,D1
00001F2E  3C1A                    1435      MOVE.W  (A2)+,D6
00001F30  4244                    1436      CLR     D4
00001F32  4EB9 00001F80           1437      JSR     EAHEXtoASCII
00001F38  4E75                    1438      RTS
00001F3A                          1439  ;If the EA is a (xxx).W EA    
00001F3A                          1440  ;This method assume D6 contains the Reg for (xxx).W  
00001F3A                          1441  EAAWA
00001F3A  12FC 0024               1442      MOVE.B  #'$',(A1)+
00001F3E  5241                    1443      ADDQ    #1,D1
00001F40  3C1A                    1444      MOVE.W  (A2)+,D6   ; Push our next Word value into D6
00001F42                          1445      ; Push the ASCII equivlent characters of D6-- only the
00001F42                          1446      ;   first Word's worth (our entire Word we just acquired)
00001F42  4244                    1447      CLR     D4
00001F44  4EB9 00001F80           1448      JSR     EAHEXtoASCII
00001F4A                          1449      
00001F4A  4E75                    1450      RTS
00001F4C                          1451  ;If the EA is a (xxx).L EA    
00001F4C                          1452  ;This method assume D6 contains the Reg for (xxx).L  
00001F4C                          1453  EAALA
00001F4C  12FC 0024               1454      MOVE.B  #'$',(A1)+
00001F50  5241                    1455      ADDQ    #1,D1
00001F52  2C1A                    1456      MOVE.L  (A2)+,D6   ; Push our next Long value into D6
00001F54                          1457      ; Push the ASCII equivlent characters of D6-- only the
00001F54                          1458      ;   first Word's worth of our Long
00001F54  4244                    1459      CLR     D4         ; Clear our counter
00001F56  4846                    1460      SWAP    D6         ; Flip the high-order Word with the Low-order
00001F58  4EB9 00001F80           1461      JSR     EAHEXtoASCII
00001F5E  4846                    1462      SWAP    D6         ; Flip the high-order Word with the Low-order
00001F60                          1463      ; Print the second half of the Long, too
00001F60  4244                    1464      CLR     D4
00001F62  4EB9 00001F80           1465      JSR     EAHEXtoASCII
00001F68                          1466      
00001F68  4E75                    1467      RTS
00001F6A                          1468  ;If the EA Mode = 111, Determine EA    
00001F6A                          1469  ;This method assume D6 contains the Reg for EA  
00001F6A                          1470  EA111
00001F6A  BC3C 0000               1471      CMP.B #0,D6
00001F6E  67CA                    1472      BEQ     EAAWA       ; Absolute Word Address 
00001F70  BC3C 0001               1473      CMP.B #1,D6
00001F74  67D6                    1474      BEQ     EAALA       ; Absolute Long Address 
00001F76  BC3C 0004               1475      CMP.B #4,D6
00001F7A  67AC                    1476      BEQ     EAID        ; Immediate Data 
00001F7C                          1477      *-----------------------------------------------let fall through? it shouldn't RTS right?
00001F7C  6000 01FA               1478      BRA     EAUNKN
00001F80                          1479      
00001F80                          1480  ; Uses D6 as a storage, D3 as a go-between, and D4 as a counter..
00001F80                          1481  ;  This operates on the low-order word of D6, and pushes exactly 4 
00001F80                          1482  ;  characters into IOStringLoc, converted from HEX of D6's nybble,
00001F80                          1483  ;  to ASCII in IOStringLoc
00001F80  5244                    1484  EAHEXtoASCII    ADDQ    #1,D4
00001F82  E95E                    1485                  ROL.W   #4,D6              Get the left-most nyblle to the front..
00001F84  1606                    1486                  MOVE.B  D6,D3              .. Put the front-most byte into D3    
00001F86  C63C 000F               1487                  AND.B   #$0F,D3            Distill D3 down to the original left-most nybble
00001F8A  B63C 0009               1488                  CMP.B   #9,D3              See if our number is greater than 9..
00001F8E  6F00 0004               1489                  BLE     EADIGIT            If it is 9 or less, it's a digit..
00001F92  5E03                    1490                  ADD.B   #7,D3              Otherwise it is a digit, and needs an additional 7
00001F94  0603 0030               1491  EADIGIT         ADD.B   #48,D3             We now have the nybble's ASCII code
00001F98  12C3                    1492                  MOVE.B  D3,(A1)+           Move the ASCII code into the output string at A1
00001F9A  B83C 0004               1493                  CMP.B   #4,D4              See if we've read all the characters
00001F9E  66E0                    1494                  BNE.S   EAHEXtoASCII       Continue if we haven't
00001FA0                          1495                  
00001FA0  5841                    1496                  ADDQ    #4,D1
00001FA2  4E75                    1497                  RTS
00001FA4                          1498      
00001FA4                          1499  ; MOVEM's (A7)+,A0-A6,D0-D7 format
00001FA4                          1500  ; Gets the follow-up WORD in order to process it
00001FA4                          1501  EAMOVEMPOSTI
00001FA4  3C1A                    1502      MOVE.W  (A2)+,D6    ; Get follow-up word for processing
00001FA6                          1503      
00001FA6  2E3C 000000FF           1504      MOVE.L  #$FF,D7     ; Initilize D7 to be our counter
00001FAC                          1505      
00001FAC  EE9E                    1506      ROR.L   #7,D6       ; Shift our new bits seven to the right
00001FAE                          1507  IANSL    ; Increment An Start Loop  
00001FAE  5247                    1508      ADDQ    #1,D7       ; Itterate D7
00001FB0  E29E                    1509      ROR.L   #1,D6       ; Rotate one bit to the right  
00001FB2  BE3C 0008               1510      CMP.B   #8,D7       ; Check if we've hit A8
00001FB6  6700 0056               1511      BEQ     INOA        ; If we have, break the loop
00001FBA  0806 0000               1512      BTST    #$00,D6     ; Check the far right bit
00001FBE  67EE                    1513      BEQ     IANSL       ; If it isn't 1, continue checking
00001FC0                          1514      
00001FC0  12FC 0041               1515      MOVE.B  #'A',(A1)+
00001FC4                          1516      
00001FC4  0607 0030               1517      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
00001FC8  12C7                    1518      MOVE.B  D7,(A1)+
00001FCA  5441                    1519      ADDQ    #2,D1
00001FCC                          1520      
00001FCC  0407 002F               1521      SUB.B   #47,D7      ; Balance out out D7 from ASCII conversion
00001FD0  E29E                    1522      ROR.L   #1,D6       ; Rotate one bit to the right  
00001FD2  BE3C 0008               1523      CMP.B   #8,D7       ; Check if we've hit A8
00001FD6  6700 003A               1524      BEQ     INOEA       ; If we have, break the loop
00001FDA  0806 0000               1525      BTST    #$00,D6     ; Check the far right bit
00001FDE  6700 0032               1526      BEQ     INOEA       ; If it is 0, skip past -A
00001FE2                          1527  IANEL    ; Increment An End Loop  
00001FE2  5247                    1528      ADDQ    #1,D7       ; Itterate D7
00001FE4  E29E                    1529      ROR.L   #1,D6       ; Rotate one bit to the right  
00001FE6  BE3C 0008               1530      CMP.B   #8,D7       ; Check if we've hit A8
00001FEA  6700 0008               1531      BEQ     IANELE      ; If we have, break the loop
00001FEE  0806 0000               1532      BTST    #$00,D6     ; Check the far right bit
00001FF2  66EE                    1533      BNE     IANEL       ; If it isn't 0, continue checking    
00001FF4                          1534  IANELE
00001FF4  5347                    1535      SUBQ    #1,D7
00001FF6                          1536      
00001FF6  12FC 002D               1537      MOVE.B  #'-',(A1)+
00001FFA  12FC 0041               1538      MOVE.B  #'A',(A1)+
00001FFE                          1539      
00001FFE  0607 0030               1540      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
00002002  12C7                    1541      MOVE.B  D7,(A1)+
00002004  5641                    1542      ADDQ    #3,D1
00002006  0407 0030               1543      SUB.B   #48,D7      ; SUB 48 into D7 for ASCII conversion
0000200A  6000 0006               1544      BRA     INOEA       ; Branch past the 'No An Skip Label'
0000200E                          1545  
0000200E                          1546  INOA     ; No An Skip label 
0000200E  08C7 001F               1547      BSET.L  #$1F,D7     ; Set our MSB to equal 1
00002012                          1548   
00002012                          1549  INOEA    ; No An Ending (aka Single An) Skip Label
00002012  5207                    1550      ADD.B   #1,D7       ; Add 1 for 0ing balance
00002014  0887 0008               1551      BCLR    #$08,D7     ; Incase we're iterated base FF in A
00002018  EFBE                    1552      ROL.L   D7,D6       ; Rotate our A bits back into view
0000201A  E19E                    1553      ROL.L   #8,D6       ; Rotate our D bits back into place
0000201C  E39E                    1554      ROL.L   #1,D6       ; Rotate an extra bit over, to account for the loop
0000201E  1E3C 00FF               1555      MOVE.B  #$FF,D7     ; Initilize D7
00002022                          1556  
00002022                          1557  IDNSL    ; Increment Dn Start Loop  
00002022  5247                    1558      ADDQ    #1,D7       ; Itterate D7
00002024  E29E                    1559      ROR.L   #1,D6       ; Rotate one bit to the right  
00002026  BE3C 0008               1560      CMP.B   #8,D7       ; Check if we've hit D8
0000202A  6700 0060               1561      BEQ     ENDEAMOVEMPI ; If we have, break the loop
0000202E  0806 0000               1562      BTST    #$00,D6     ; Check the far right bit
00002032  67EE                    1563      BEQ     IDNSL       ; If it isn't 1, continue checking     
00002034                          1564      
00002034                          1565      ; The issue with the below line:
00002034                          1566      ;  We need to skip / if there are no An registers, as we do in INOA
00002034                          1567      ;  We also need to skip / if there are no Dn registers, as we do here
00002034                          1568      ;  However, we need to skip / if there are no An's, but we still need to run
00002034                          1569      ;   the above code to determine the starting Dn, so we use the MSB of D7
00002034                          1570      ;   as a boolean to determine if we had an An
00002034  0807 001F               1571      BTST    #$1F,D7     ; If our MSB is equal to 1, we have no A
00002038  6600 0008               1572      BNE     INOA2       ; .. So, skip the /
0000203C  12FC 002F               1573      MOVE.B  #'/',(A1)+
00002040  5241                    1574      ADDQ    #1,D1
00002042                          1575  INOA2     ; 2nd No An Skip label 
00002042  0887 001F               1576      BCLR    #$1F,D7     ; If our MSB is set, clear it
00002046  12FC 0044               1577      MOVE.B  #'D',(A1)+
0000204A  0607 0030               1578      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
0000204E  12C7                    1579      MOVE.B  D7,(A1)+    
00002050  5441                    1580      ADDQ    #2,D1
00002052                          1581      
00002052  0407 002F               1582      SUB.B   #47,D7      ; Balance out our D7 from ASCII conversion
00002056  E29E                    1583      ROR.L   #1,D6       ; Rotate one bit to the right  
00002058  BE3C 0008               1584      CMP.B   #8,D7       ; Check if we've hit A8
0000205C  6700 002E               1585      BEQ     ENDEAMOVEMPI  ; If we have, break to the end
00002060  0806 0000               1586      BTST    #$00,D6     ; Check the far right bit
00002064  6700 0026               1587      BEQ     ENDEAMOVEMPI ; If it is 0, we have no -Dn
00002068                          1588  IDNEL    ; Increment Dn End Loop  
00002068  5247                    1589      ADDQ    #1,D7       ; Itterate D7
0000206A  E29E                    1590      ROR.L   #1,D6       ; Rotate one bit to the right  
0000206C  BE3C 0008               1591      CMP.B   #8,D7       ; Check if we've hit A8
00002070  6700 0008               1592      BEQ     INENLE      ; If we have, break the loop
00002074  0806 0000               1593      BTST    #$00,D6     ; Check the far right bit
00002078  66EE                    1594      BNE     IDNEL       ; If it isn't 0, continue checking    
0000207A                          1595  INENLE
0000207A  5347                    1596      SUBQ    #1,D7
0000207C                          1597      
0000207C  12FC 002D               1598      MOVE.B  #'-',(A1)+
00002080  12FC 0044               1599      MOVE.B  #'D',(A1)+
00002084                          1600  
00002084  0607 0030               1601      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
00002088  12C7                    1602      MOVE.B  D7,(A1)+
0000208A  5641                    1603      ADDQ    #3,D1 
0000208C                          1604      ; If no Dn, skip to the end
0000208C                          1605  ENDEAMOVEMPI
0000208C  4E75                    1606      RTS
0000208E                          1607      
0000208E                          1608  EAMOVEMPRED
0000208E  3C1A                    1609      MOVE.W  (A2)+,D6    ; Get follow-up word for processing
00002090                          1610      
00002090  2E3C 000000FF           1611      MOVE.L  #$FF,D7     ; Initilize D7 to be our counter
00002096                          1612      
00002096  E09E                    1613      ROR.L   #8,D6       ; Shift our new bits eight to the right
00002098                          1614  DANSL    ; Decrement An Start Loop  
00002098  5247                    1615      ADDQ    #1,D7       ; Itterate D7
0000209A  E39E                    1616      ROL.L   #1,D6       ; Rotate one bit to the left  
0000209C  BE3C 0008               1617      CMP.B   #8,D7       ; Check if we've hit A8
000020A0  6700 0056               1618      BEQ     DNOA        ; If we have, break the loop
000020A4  0806 0000               1619      BTST    #$00,D6     ; Check the far right bit
000020A8  67EE                    1620      BEQ     DANSL       ; If it isn't 1, continue checking
000020AA                          1621      
000020AA  12FC 0041               1622      MOVE.B  #'A',(A1)+
000020AE                          1623      
000020AE  0607 0030               1624      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
000020B2  12C7                    1625      MOVE.B  D7,(A1)+
000020B4  5441                    1626      ADDQ    #2,D1
000020B6                          1627      
000020B6  0407 002F               1628      SUB.B   #47,D7      ; Balance out out D7 from ASCII conversion
000020BA  E39E                    1629      ROL.L   #1,D6       ; Rotate one bit to the left  
000020BC  BE3C 0008               1630      CMP.B   #8,D7       ; Check if we've hit A8
000020C0  6700 003A               1631      BEQ     DNOEA       ; If we have, break the loop
000020C4  0806 0000               1632      BTST    #$00,D6     ; Check the far right bit
000020C8  6700 0032               1633      BEQ     DNOEA       ; If it is 0, skip past -A
000020CC                          1634  DANEL    ; Decrement An End Loop  
000020CC  5247                    1635      ADDQ    #1,D7       ; Itterate D7
000020CE  E39E                    1636      ROL.L   #1,D6       ; Rotate one bit to the left  
000020D0  BE3C 0008               1637      CMP.B   #8,D7       ; Check if we've hit A8
000020D4  6700 0008               1638      BEQ     DANELE      ; If we have, break the loop
000020D8  0806 0000               1639      BTST    #$00,D6     ; Check the far right bit
000020DC  66EE                    1640      BNE     DANEL       ; If it isn't 0, continue checking    
000020DE                          1641  DANELE
000020DE  5347                    1642      SUBQ    #1,D7
000020E0                          1643      
000020E0  12FC 002D               1644      MOVE.B  #'-',(A1)+
000020E4  12FC 0041               1645      MOVE.B  #'A',(A1)+
000020E8                          1646      
000020E8  0607 0030               1647      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
000020EC  12C7                    1648      MOVE.B  D7,(A1)+
000020EE  5641                    1649      ADDQ    #3,D1
000020F0  0407 0030               1650      SUB.B   #48,D7      ; SUB 48 into D7 for ASCII conversion
000020F4  6000 0006               1651      BRA     DNOEA       ; Branch past the 'No An Skip Label'
000020F8                          1652  
000020F8                          1653  DNOA     ; No An Skip label 
000020F8  08C7 001F               1654      BSET.L  #$1F,D7     ; Set our MSB to equal 1
000020FC                          1655   
000020FC                          1656  DNOEA    ; No An Ending (aka Single An) Skip Label
000020FC  5207                    1657      ADDQ.B  #1,D7       ; Add 1 for 0ing balance
000020FE  0887 0008               1658      BCLR    #$08,D7     ; Incase we're iterated base FF in A
00002102  EEBE                    1659      ROR.L   D7,D6       ; Rotate our A bits back into view
00002104  E09E                    1660      ROR.L   #8,D6       ; Rotate our D bits back into place
00002106  E29E                    1661      ROR.L   #1,D6       ; Rotate an extra bit over, to account for the loop
00002108  1E3C 00FF               1662      MOVE.B  #$FF,D7     ; Initilize D7
0000210C                          1663  
0000210C                          1664  DDNSL    ; Decrement Dn Start Loop  
0000210C  5207                    1665      ADDQ.B  #1,D7       ; Itterate D7
0000210E  E39E                    1666      ROL.L   #1,D6       ; Rotate one bit to the right  
00002110  BE3C 0008               1667      CMP.B   #8,D7       ; Check if we've hit D8
00002114  6700 0060               1668      BEQ     ENDEAMOVEMPD ; If we have, break the loop
00002118  0806 0000               1669      BTST    #$00,D6     ; Check the far right bit
0000211C  67EE                    1670      BEQ     DDNSL       ; If it isn't 1, continue checking     
0000211E                          1671      
0000211E                          1672      ; The issue with the below line:
0000211E                          1673      ;  We need to skip / if there are no An registers, as we do in INOA
0000211E                          1674      ;  We also need to skip / if there are no Dn registers, as we do here
0000211E                          1675      ;  However, we need to skip / if there are no An's, but we still need to run
0000211E                          1676      ;   the above code to determine the starting Dn, so we use the MSB of D7
0000211E                          1677      ;   as a boolean to determine if we had an An
0000211E  0807 001F               1678      BTST    #$1F,D7     ; If our MSB is equal to 1, we have no A
00002122  6600 0008               1679      BNE     DNOA2       ; .. So, skip the /
00002126  12FC 002F               1680      MOVE.B  #'/',(A1)+
0000212A  5241                    1681      ADDQ    #1,D1
0000212C                          1682  DNOA2     ; 2nd No An Skip label 
0000212C  0887 001F               1683      BCLR    #$1F,D7     ; If our MSB is set, clear it
00002130  12FC 0044               1684      MOVE.B  #'D',(A1)+
00002134  0607 0030               1685      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
00002138  12C7                    1686      MOVE.B  D7,(A1)+    
0000213A  5441                    1687      ADDQ    #2,D1
0000213C                          1688      
0000213C  0407 002F               1689      SUB.B   #47,D7      ; Balance out our D7 from ASCII conversion
00002140  E39E                    1690      ROL.L   #1,D6       ; Rotate one bit to the right  
00002142  BE3C 0008               1691      CMP.B   #8,D7       ; Check if we've hit A8
00002146  6700 002E               1692      BEQ     ENDEAMOVEMPD  ; If we have, break to the end
0000214A  0806 0000               1693      BTST    #$00,D6     ; Check the far right bit
0000214E  6700 0026               1694      BEQ     ENDEAMOVEMPD ; If it is 0, we have no -Dn
00002152                          1695  DDNEL    ; Decrement Dn End Loop  
00002152  5247                    1696      ADDQ    #1,D7       ; Itterate D7
00002154  E39E                    1697      ROL.L   #1,D6       ; Rotate one bit to the right  
00002156  BE3C 0008               1698      CMP.B   #8,D7       ; Check if we've hit A8
0000215A  6700 0008               1699      BEQ     DNENLE      ; If we have, break the loop
0000215E  0806 0000               1700      BTST    #$00,D6     ; Check the far right bit
00002162  66EE                    1701      BNE     DDNEL       ; If it isn't 0, continue checking    
00002164                          1702  DNENLE
00002164  5347                    1703      SUBQ    #1,D7
00002166                          1704      
00002166  12FC 002D               1705      MOVE.B  #'-',(A1)+
0000216A  12FC 0044               1706      MOVE.B  #'D',(A1)+
0000216E                          1707  
0000216E  0607 0030               1708      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
00002172  12C7                    1709      MOVE.B  D7,(A1)+
00002174  5641                    1710      ADDQ    #3,D1 
00002176                          1711      ; If no Dn, skip to the end
00002176                          1712  ENDEAMOVEMPD
00002176  4E75                    1713      RTS
00002178                          1714  
00002178                          1715  ; If the EA is unknown
00002178                          1716  EAUNKN
00002178  12FC 003C               1717      MOVE.B  #'<',(A1)+  ; We did this byte-by-byte in case A1 is at an odd register
0000217C  12FC 0045               1718      MOVE.B  #'E',(A1)+
00002180  12FC 0041               1719      MOVE.B  #'A',(A1)+
00002184  12FC 003E               1720      MOVE.B  #'>',(A1)+
00002188  5841                    1721      ADDQ    #4,D1
0000218A  4E75                    1722      RTS
0000218C                          1723  
0000218C                          1724  
0000218C                          1725  
0000218C                          1726  
0000218C                          1727  
0000218C                          1728  
0000218C                          1729  
0000218C                          1730  
0000218C                          1731  -------------------- end include --------------------
0000218C                          1732      
0000218C  FFFF FFFF               1733      SIMHALT             ; halt simulator
00002190                          1734  
00002190                          1735  * Put variables and constants here
00002190                          1736  
00002190                          1737      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AASD                1DC6
AASLSRO             1DA2
AASLSRODL           1DFA
AASLSRODR           1DE4
AASLSROOP           1E00
ADDADDA             1BA6
ADDAL               1C70
ADDAN               1C82
ADDAW               1C5E
ADDBDN              1C16
ADDBEA              1C4C
ADDI                1480
ADDI8               1494
ADDIB               14E4
ADDIL               1504
ADDIOP              1514
ADDIW               14F4
ADDLDN              1BF2
ADDLEA              1C28
ADDWDN              1C04
ADDWEA              1C3A
ALSD                1DD0
AND                 1AA8
ANDBDN              1B66
ANDBEA              1AFC
ANDDN               1B78
ANDEA               1B0C
ANDLDN              1B42
ANDLEA              1ADC
ANDWDN              1B54
ANDWEA              1AEC
AROD                1DDA
ASD                 1CE6
ASLSRO              1CB2
ASLSROB             1D46
ASLSRODL            1D1E
ASLSRODR            1D04
ASLSROIR            1D52
ASLSROIRDN          1D74
ASLSROOP            1D7A
ASLSROSIZE          1D28
ASLSROW             1D4E
BAD_EVEN            10D2
BAD_LENGTH          1094
BCC                 177A
BCC16               1820
BCC16NEG            1838
BCC32               1848
BCC32NEG            186A
BCC8NEG             1810
BCCOP               179E
BCCSIZE             17C8
BGTOP               17AC
BLEOP               17BA
CHECK31             1052
CLEARMEMORY         107C
CLR                 15D2
CLRB                15FE
CLRL                162A
CLROP               1640
CLRW                1614
CMP                 19BC
CMPB                19E2
CMPL                1A0E
CMPOP               1A24
CMPW                19F8
CNRJML              158A
COUNTER             1404
CR                  D
DANEL               20CC
DANELE              20DE
DANSL               2098
DDNEL               2152
DDNSL               210C
DIVU                18D8
DNENLE              2164
DNOA                20F8
DNOA2               212C
DNOEA               20FC
EA111               1F6A
EAALA               1F4C
EAAN                1ED0
EAANI               1EDE
EAAPOST             1EF4
EAAPRE              1F0E
EAAWA               1F3A
EADIGIT             1F94
EADN                1EC2
EAGETDSTEA          1E86
EAGETSRCEA          1E46
EAHEXTOASCII        1F80
EAID                1F28
EAMOVEMPOSTI        1FA4
EAMOVEMPRED         208E
EAUNKN              2178
ENDEAMOVEMPD        2176
ENDEAMOVEMPI        208C
ENDINGADDRESS       1400
ENDLOOP             1118
ENTERCHECK          105E
ENTERPROMPT         136E
FAIL_INPUT          1328
HEXEND              12AB
HEXSTART            1255
IANEL               1FE2
IANELE              1FF4
IANSL               1FAE
IDNEL               2068
IDNSL               2022
INENLE              207A
INOA                200E
INOA2               2042
INOEA               2012
INTROMSG            1238
IOASCIITOHEX        10E8
IOASCIITOHEX2       114C
IODIGIT             1214
IODONE              1222
IOHEXTOASCII        1200
IOINTRO             100C
IOLOOP              101A
IOORTAG             10FA
IOORTAG2            115E
IOSTRINGLOC         100
JSR                 1692
LEA                 1738
LENGTH_CHECK        107C
LF                  A
LSD                 1CF0
MOVEB               152C
MOVEL               154C
MOVEM               16BC
MOVEML              16E2
MOVEMOP             16E8
MOVEMPOSTI          171C
MOVEMPRED           1700
MOVEMW              16D8
MOVEOP              155C
MOVEQ               1886
MOVEW               153C
MULS                1A6C
MULSAND             1A5A
NOP                 165E
OPGETCODE           1408
OUTPUTOPCODE        1190
OUTRO               131E
RES                 1300
ROD                 1CFA
RTS                 1678
SPC                 130E
START               1000
STARTADDRESS        13FC
STARTGTEND          13B2
STARTLESSTHNEND     10A6
SUB                 1914
SUBBDN              19AA
SUBBEA              1974
SUBLDN              1986
SUBLEA              1950
SUBWDN              1998
SUBWEA              1962
TEST_ODD            10B8
UNKEA               1314
UNKNOWN             1E22
