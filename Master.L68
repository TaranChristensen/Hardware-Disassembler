00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 3/9/2016 8:11:47 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Master
00000000                             3  * Written by : Circles
00000000                             4  * Date       : ##/##/16
00000000                             5  * Description: Project Master File
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11      INCLUDE "IO.X68"        ; Handles our input and output, as well as which address to refer to
00001000  47F9 000013F6             12                  LEA     COUNTER,A3         initialize the COUNTER variable
00001006  26BC 00000000             13                  MOVE.L  #0,(A3)            clear the variable
0000100C                            14                  
0000100C                            15  
0000100C  5293                      16  IOINTRO         ADD.L   #$00000001,(A3)    COUNTER++
0000100E  43F9 0000122A             17                  LEA     IntroMsg,A1        Display the intro
00001014  103C 000E                 18                  MOVE.B  #14, D0
00001018  4E4F                      19                  TRAP    #15
0000101A                            20  
0000101A  43F9 00001247             21  IOLOOP          LEA     HexStart,A1        Display the prompt and loop it
00001020  103C 000E                 22                  MOVE.B  #14,D0          
00001024  4E4F                      23                  TRAP    #15   
00001026  5493                      24                  ADD.L   #$00000002,(A3)    COUNTER++ COUNTER++
00001028                            25  
00001028                            26  
00001028  43F9 00000100             27                  LEA     IOStringLoc,A1     Store the string of our user input at StartAddress,A1 
0000102E  103C 0002                 28                  MOVE.B  #2,D0              uses Trap #15, Task 2
00001032  4E4F                      29                  TRAP    #15              
00001034                            30          
00001034  B2BC 00000001             31                  CMP.L   #1,D1              Compares D1 to the number 1 (eg. String length of 1)
0000103A  6700 01D8                 32                  BEQ     IODONE             Branch to DONE if they are equal
0000103E                            33          
0000103E  4284                      34                  CLR.L   D4                 Ensure our counter (D4) is 0 
00001040                            35  
00001040  4EB9 0000107C             36                  JSR     LENGTH_CHECK 
00001046  4282                      37                  CLR.L   D2  
00001048  BA3C 0001                 38                  CMP.B   #1,D5              if 1 then it passed the tests         
0000104C                            39                  
0000104C  6700 009A                 40                  BEQ     IOASCIItoHEX
00001050  60C8                      41                  BRA     IOLOOP
00001052                            42                  
00001052  0C93 0000001D             43  CHECK31         CMP.L   #$0000001D,(A3)    compare the counter to 29
00001058  6E00 0004                 44                  BGT     ENTERCHECK         counter is at at least 30
0000105C  4E75                      45                  RTS                        counter is still low
0000105E                            46  
0000105E  4280                      47  ENTERCHECK      CLR.L   D0
00001060  43F9 00001360             48                  LEA     ENTERPROMPT,A1     display the enter prompt
00001066  103C 000E                 49                  MOVE.B  #14,D0
0000106A  4E4F                      50                  TRAP    #15
0000106C                            51                            
0000106C  103C 0002                 52                  MOVE.B  #2,D0              wait for the user to hit enter
00001070  4E4F                      53                  TRAP    #15
00001072                            54                  
00001072  26BC 00000000             55                  MOVE.L  #0,(A3)            clear the counter
00001078  5293                      56                  ADD.L   #$00000001,(A3)    COUNTER++
0000107A                            57               
0000107A  4E75                      58                  RTS
0000107C                            59                  
0000107C                            60  CLEARMEMORY     ***************************** a function to clear all data and address registers *****************************
0000107C                            61                  
0000107C  4285                      62  LENGTH_CHECK    CLR.L   D5                 store the result of the test
0000107E  7C00                      63                  MOVEQ   #$0,D6             make D6 0
00001080  B206                      64                  CMP.B   D6,D1              see if null
00001082  6700 0010                 65                  BEQ     BAD_LENGTH         if null then branch to bad input
00001086  0C41 0008                 66                  CMPI    #$8,D1             see if it is more than 8 characters long
0000108A  6E00 0008                 67                  BGT     BAD_LENGTH         if more than 8 branch to bad input
0000108E  1A3C 0001                 68                  MOVE.B  #$1,D5             passed the length checks so move 1
00001092  4E75                      69                  RTS                        go back
00001094                            70                  
00001094  7A00                      71  BAD_LENGTH      MOVEQ   #$0,D5             did not pass the test
00001096  43F9 0000131A             72                  LEA     FAIL_INPUT,A1      load bad input message
0000109C  103C 000E                 73                  MOVE.B  #14,D0          
000010A0  4E4F                      74                  TRAP    #15 
000010A2  5293                      75                  ADD.L   #$00000001,(A3)    COUNTER++
000010A4  4E75                      76                  RTS                        go back
000010A6                            77                  
000010A6  43F9 000013A4             78  STARTLESSTHNEND LEA     STARTGTEND,A1      load the error 
000010AC  103C 000E                 79                  MOVE.B  #14,D0
000010B0  4E4F                      80                  TRAP    #15
000010B2  5293                      81                  ADD.L   #$00000001,(A3)    COUNTER++
000010B4  6000 FF64                 82                  BRA     IOLOOP             go back to the start
000010B8                            83  
000010B8                            84  
000010B8  4286                      85  TEST_ODD        CLR.L   D6           
000010BA  4285                      86                  CLR.L   D5
000010BC  7A02                      87                  MOVE.L  #$00000002,D5      divide by 2 to see remainder
000010BE  2C02                      88                  MOVE.L  D2,D6              create a copy of the input in D7
000010C0  8CC5                      89                  DIVU    D5,D6              divide the hex number by 2
000010C2  4846                      90                  SWAP    D6                 put the remainder on the far right
000010C4  BC3C 0001                 91                  CMP.B   #1,D6              see if the remainder is one
000010C8  6700 0008                 92                  BEQ     BAD_EVEN           branch to even
000010CC  4286                      93                  CLR.L   D6
000010CE  4285                      94                  CLR.L   D5
000010D0  4E75                      95                  RTS
000010D2                            96                  
000010D2                            97                  
000010D2  4285                      98  BAD_EVEN        CLR.L   D5
000010D4  4286                      99                  CLR.L   D6
000010D6  43F9 0000131A            100                  LEA     FAIL_INPUT,A1      load bad input message  
000010DC  103C 000E                101                  MOVE.B  #14,D0          
000010E0  4E4F                     102                  TRAP    #15 
000010E2  5293                     103                  ADD.L   #$00000001,(A3)    COUNTER++
000010E4  6000 FF34                104                  BRA     IOLOOP             go back to the beginning
000010E8                           105                  
000010E8                           106  
000010E8  5244                     107  IOASCIItoHEX    ADDQ    #1,D4
000010EA  E98A                     108                  LSL.L   #4,D2              Scoot D2 a nybble
000010EC  1619                     109                  MOVE.B  (A1)+,D3           Move a Byte from A1's address to D3
000010EE  0403 0030                110                  SUB.B   #48,D3             Sub 48 to turn ASCII 0 into binary 0
000010F2  B63C 0009                111                  CMP.B   #9,D3              If our number is greater than 9..
000010F6  6F02                     112                  BLE.S   IOORTAG            .. it must be a character; A-F: 
000010F8  5F03                     113                  SUB.B   #7,D3              Sub 7 to turn A into 10
000010FA  8403                     114  IOORTAG         OR.B    D3,D2              Store our nybble into D2
000010FC  B204                     115                  CMP.B   D4,D1              See if we've read all the characters
000010FE  66E8                     116                  BNE.S   IOASCIItoHEX       Continue if we haven't
00001100                           117              
00001100                           118              
00001100  23FC 00000000 000013EE   119                  MOVE.L  #0,StartAddress
0000110A  23C2 000013EE            120                  MOVE.L  D2,StartAddress    Store our StartAddress
00001110                           121                  
00001110  4EB8 10B8                122                  JSR     TEST_ODD           test if the address is odd
00001114                           123                  
00001114  4281                     124                  CLR.L   D1
00001116  4282                     125                  CLR.L   D2
00001118                           126  
00001118                           127  
00001118  43F9 0000129D            128  ENDLOOP         LEA     HexEnd,A1          load the ending address prompt
0000111E  103C 000E                129                  MOVE.B  #14,D0
00001122  4E4F                     130                  TRAP    #15  
00001124  5493                     131                  ADD.L   #$00000002,(A3)
00001126                           132                  
00001126  43F9 00000100            133                  LEA     IOStringLoc,A1     Store the string of our user input at StartAddress,A1 
0000112C  103C 0002                134                  MOVE.B  #2,D0              uses Trap #15, Task 2
00001130  4E4F                     135                  TRAP    #15              
00001132                           136          
00001132  B2BC 00000001            137                  CMP.L   #1,D1              Compares D1 to the number 1 (eg. String length of 1)
00001138  6700 00DA                138                  BEQ     IODONE             Branch to DONE if they are equal
0000113C                           139          
0000113C  4284                     140                  CLR.L   D4                 Ensure our counter (D4) is 0 
0000113E                           141  
0000113E  4EB8 107C                142                  JSR     LENGTH_CHECK       check to make sure the length is ok
00001142  BA3C 0001                143                  CMP.B   #1,D5              if 1 then it passed the tests         
00001146                           144  
00001146  6700 0004                145                  BEQ     IOASCIItoHEX2      convert to hex
0000114A  60CC                     146                  BRA     ENDLOOP
0000114C                           147                  
0000114C  5244                     148  IOASCIItoHEX2   ADDQ    #1,D4
0000114E  E98A                     149                  LSL.L   #4,D2              Scoot D2 a nybble
00001150  1619                     150                  MOVE.B  (A1)+,D3           Move a Byte from A1's address to D3
00001152  0403 0030                151                  SUB.B   #48,D3             Sub 48 to turn ASCII 0 into binary 0
00001156  B63C 0009                152                  CMP.B   #9,D3              If our number is greater than 9..
0000115A  6F02                     153                  BLE.S   IOORTAG2           .. it must be a character; A-F: 
0000115C  5F03                     154                  SUB.B   #7,D3              Sub 7 to turn A into 10
0000115E  8403                     155  IOORTAG2        OR.B    D3,D2              Store our nybble into D2
00001160  B204                     156                  CMP.B   D4,D1              See if we've read all the characters
00001162  66E8                     157                  BNE.S   IOASCIItoHEX2      Continue if we haven't
00001164                           158              
00001164                           159    
00001164  23FC 00000000 000013F2   160                  MOVE.L  #0,EndingAddress
0000116E  23C2 000013F2            161                  MOVE.L  D2,EndingAddress   Store our EndingAddress
00001174                           162                  
00001174  4EB8 10B8                163                  JSR     TEST_ODD           tezt if the ending address is odd
00001178                           164                  
00001178  2479 000013EE            165                  MOVE.L  StartAddress,A2    Push our start address into A2
0000117E                           166                  
0000117E  B5F9 000013F2            167                  CMP.L   EndingAddress,A2   compare the ending address with the startingaddress
00001184  6E00 FF20                168                  BGT     STARTLESSTHNEND    branch if the starting is greater than the ending
00001188                           169                  
00001188  4281                     170                  CLR.L   D1
0000118A                           171                  
0000118A  2479 000013EE            172                  MOVE.L  StartAddress,A2    Push our start address into A2 
00001190                           173                  
00001190                           174  
00001190  23FC 00000000 00000100   175  OUTPUTOPCODE    MOVE.L  #0,IOStringLoc     ********** Testing purposes ********** 
0000119A  4281                     176                  CLR.L   D1
0000119C                           177          
0000119C                           178  
0000119C  43F9 00000100            179                  LEA     IOStringLoc,A1     Load our IOStringLoc into A1 for string contruction purposes
000011A2                           180          
000011A2                           181                  ; Here we could loop all of the addresses of A2 until End, or something.
000011A2  22FC 23232323            182                  MOVE.L  #'####',(A1)+      Move our "OpCode location" into our IOStringLoc <---- THIS NEEDS TO BE HEX
000011A8  5841                     183                  ADDQ    #4,D1              We added 4 new characters                       <---- THIS NEEDS TO BE 8
000011AA  22FC 20202020            184                  MOVE.L  #'    ',(A1)+      Add a spacer into our IOStringLoc
000011B0  32FC 2020                185                  MOVE.W  #'  ',(A1)+      Add a spacer into our IOStringLoc
000011B4  5C41                     186                  ADDQ    #6,D1              We added 4 bytes, aka 4 spaces
000011B6                           187          
000011B6  4EB9 000013FA            188                  JSR OPGETCODE              Get the OpCode pointed at by A2, it's string stored in IOStringLoc
000011BC                           189                  
000011BC  43F9 00000100            190                  LEA     IOStringLoc,A1     Now that we've populated the string, load it's beginning
000011C2  103C 0001                191                  MOVE.B  #1,D0              Trap task 1 prints a string at A1 with #D1 bytes.
000011C6  4E4F                     192                  TRAP    #15
000011C8                           193          
000011C8                           194                  ;LEA     UnkEA,A1          TEMPORARY Print "<EA>,<EA>"
000011C8                           195                  ;MOVE.B  #13,D0              
000011C8                           196                  ;TRAP    #15                 
000011C8                           197          
000011C8  43F9 00001300            198                  LEA     SPC,A1             Puts the space before the opCode
000011CE  103C 000D                199                  MOVE.B  #13,D0
000011D2  4E4F                     200                  TRAP    #15
000011D4                           201                  
000011D4  5293                     202                  ADD.L   #$00000001,(A3)    COUNTER++
000011D6  4EB8 1052                203                  JSR     CHECK31
000011DA                           204                  
000011DA  B5F9 000013F2            205                  CMP.L   EndingAddress,A2   compare the current address with the ending address
000011E0  6DAE                     206                  BLT     OUTPUTOPCODE       if the current is less than the ending keep looping
000011E2                           207                  
000011E2                           208  
000011E2                           209  
000011E2                           210  
000011E2                           211                  ; The following outputs the input, converting what we've saved in HEX to ASCII
000011E2                           212                  ; We won't need this in the final version, but the below code should be handy
000011E2                           213                  ;  for print out EA values
000011E2  2439 000013EE            214                  MOVE.L  StartAddress,D2    Ensure our address is actually at D2
000011E8  7208                     215                  MOVEQ   #8,D1              There are 8 characters in the hex of our address
000011EA  4284                     216                  CLR.L   D4                 Ensure our counter (D4) is 0
000011EC  43F9 00000100            217                  LEA     IOStringLoc,A1     Load our IO String location, to store our output at  
000011F2                           218  
000011F2                           219          
000011F2  5244                     220  IOHEXtoASCII    ADDQ    #1,D4
000011F4  E99A                     221                  ROL.L   #4,D2              Get the left-most nyblle to the front..
000011F6  1602                     222                  MOVE.B  D2,D3              .. Put the front-most byte into D3    
000011F8  C63C 000F                223                  AND.B   #$0F,D3            Distill D3 down to the original left-most nybble
000011FC  B63C 0009                224                  CMP.B   #9,D3              See if our number is greater than 9..
00001200  6F00 0004                225                  BLE     IODIGIT            If it is 9 or less, it's a digit..
00001204  5E03                     226                  ADD.B   #7,D3              Otherwise it is a digit, and needs an additional 7
00001206  0603 0030                227  IODIGIT         ADD.B   #48,D3             We now how the nybble's ASCII code
0000120A  12C3                     228                  MOVE.B  D3,(A1)+           Move the ASCII code into the output string at A1
0000120C  B204                     229                  CMP.B   D4,D1              See if we've read all the characters
0000120E  66E2                     230                  BNE.S   IOHEXtoASCII       Continue if we haven't
00001210                           231          
00001210                           232  
00001210  6000 FE08                233                  BRA     IOLOOP
00001214                           234          
00001214                           235        
00001214  43F9 00001310            236  IODONE          LEA     OUTRO,A1           Display the ending message 
0000121A  103C 000E                237                  MOVE.B  #14,D0
0000121E  4E4F                     238                  TRAP    #15
00001220  103C 0009                239                  MOVE.B  #9,D0
00001224  4E4F                     240                  TRAP    #15                Halt Simulator
00001226                           241          
00001226  FFFF FFFF                242                  SIMHALT
0000122A                           243          
0000122A  =0000000D                244  CR              EQU     $0D         
0000122A  =0000000A                245  LF              EQU     $0A 
0000122A  =00000100                246  IOStringLoc     EQU     $0100              This is where we will store the string of the user input, and other strings
0000122A                           247  
0000122A                           248  
0000122A= 54 65 61 6D 20 43 ...    249  IntroMsg        DC.B    'Team Circles Disassembler ',CR,LF,0     Intro
00001247= 45 6E 74 65 72 20 ...    250  HexStart        DC.B    'Enter a starting address in hex of length 8 or less and even, or',CR,LF,'type in 0 to quit: ',0 Prompt for the user
0000129D= 45 6E 74 65 72 20 ...    251  HexEnd          DC.B    'Enter an ending address in hex of length 8 or less and even, or',CR,LF,'type in 0 to quit: ',0 Prompt for the user
000012F2= 59 6F 75 20 74 79 ...    252  RES             DC.B    'You typed in ',0                        Response to the user
00001300= 20 20 20 20 20 00        253  SPC             DC.B    '     ',0                                tab
00001306= 3C 45 41 3E 2C 3C ...    254  UnkEA           DC.B    '<EA>,<EA>',0                            Interim message for unkown EAs.
00001310= 47 6F 6F 64 62 79 ...    255  OUTRO           DC.B    'Goodbye !',0                            Outro message
0000131A= 49 20 61 6D 20 73 ...    256  FAIL_INPUT      DC.B    'I am sorry, but you typed an address that did not meet the criteria',CR,LF,0 
00001360= 54 68 65 20 73 63 ...    257  ENTERPROMPT     DC.B    'The screen limit has been reached, please press enter to continue',CR,LF,0
000013A4= 54 68 65 20 65 6E ...    258  STARTGTEND      DC.B    'The ending address was less than the starting address, please try again',CR,LF,0
000013EE                           259  
000013EE                           260  
000013EE                           261  StartAddress    DS.L    1
000013F2                           262  EndingAddress   DS.L    1
000013F6                           263  COUNTER         DS.L    1 keep track of the lines on the screen
000013FA                           264  
000013FA                           265  
000013FA                           266  
000013FA                           267  
000013FA                           268  
000013FA                           269  
000013FA                           270  
000013FA                           271  
000013FA                           272  
000013FA                           273  
000013FA                           274  
000013FA                           275  
000013FA                           276  
000013FA                           277  
000013FA                           278  
000013FA                           279  -------------------- end include --------------------
000013FA                           280      INCLUDE "OpCode.X68"    ; Handles determining OpCodes
000013FA                           281  
000013FA                           282  
000013FA                           283  ; Here we assume that A2 contains the address pointing to our OpCode, and
000013FA                           284  ;  we assume that A1 contains the address pointing to our IOStringLoc
000013FA  3A1A                     285  OPGETCODE   MOVE.W  (A2)+,D5    ; Push our OpCode into D5
000013FC  2C05                     286              MOVE.L  D5,D6       ; Also store the OpCode in D6
000013FE  E09E                     287              ROR.L   #8,D6       ; Rotate our OpCode to right-most nybble
00001400  E89E                     288              ROR.L   #4,D6       ; 
00001402  0206 000F                289              ANDI.B  #$0F,D6     ; Isolate our opcode nybble
00001406  BC3C 0000                290              CMP.B   #$00,D6
0000140A  6700 0066                291              BEQ     ADDI        ; ADDI 
0000140E  BC3C 0001                292              CMP.B   #$01,D6     
00001412  6700 010A                293              BEQ     MOVEB       ; MOVE.B
00001416  BC3C 0003                294              CMP.B   #$03,D6     
0000141A  6700 0112                295              BEQ     MOVEW       ; MOVE.W
0000141E  BC3C 0002                296              CMP.B   #$02,D6
00001422  6700 011A                297              BEQ     MOVEL       ; MOVE.L
00001426  BC3C 0004                298              CMP.B   #$04,D6
0000142A  6700 0150                299              BEQ     CNRJML      ; CLR or NOP or RTS or JSR or MOVEM or LEA
0000142E  BC3C 0006                300              CMP.B   #$06,D6
00001432  6700 0338                301              BEQ     Bcc         ; Bcc (BCC, BGT, BLE) 
00001436  BC3C 0007                302              CMP.B   #$07,D6
0000143A  6700 0332                303              BEQ     MOVEQ       ; MOVEQ 
0000143E  BC3C 0008                304              CMP.B   #$08,D6
00001442  6700 036C                305              BEQ     DIVU        ; DIVU
00001446  BC3C 0009                306              CMP.B   #$09,D6
0000144A  6700 03A0                307              BEQ     SUB         ; SUB
0000144E  BC3C 000B                308              CMP.B   #$0B,D6
00001452  6700 0440                309              BEQ     CMP         ; CMP 
00001456  BC3C 000C                310              CMP.B   #$0C,D6
0000145A  6700 04D6                311              BEQ     MULSAND     ; MULS or AND opcodes
0000145E  BC3C 000D                312              CMP.B   #$0D,D6
00001462  6700 061A                313              BEQ     ADDADDA     ; ADD or ADDA
00001466  BC3C 000E                314              CMP.B   #$0E,D6 
0000146A  6700 071E                315              BEQ     ASLSRO      ; ASd (ASR) or LSd (LSL) or ROd (ROL)
0000146E  6000 088A                316              BRA     UNKNOWN  
00001472                           317              
00001472                           318  ;  Here we assume the first left-most 4 bits have been confirmed: 0000
00001472  2C05                     319  ADDI        MOVE.L  D5,D6               ; Push D5 into D6
00001474  E09E                     320              ROR.L   #8,D6               ; Rotate left-most middle nybble to the right-most nybble
00001476  0206 000F                321              ANDI.B  #$0F,D6             ; Isolate opcode nybble
0000147A  BC3C 0006                322              CMP.B   #$06,D6             ; If it matches ADDI's left-most middle nybble, branch
0000147E  6700 0006                323              BEQ     ADDI8               ; First 8 left-most bits of ADDI confirmed 
00001482  6000 0876                324              BRA     UNKNOWN             ; else unknown                       
00001486                           325  
00001486                           326  ;  Here we assume the first left-most 8 bits have been confirmed: 0000 0110            
00001486                           327  ADDI8                                  ; Two consecutive tests for illegal Src Modes
00001486  2C05                     328              MOVE.L  D5,D6              ; Push D5 into D6 
00001488  0286 0000003F            329              ANDI.L  #$003F,D6          ; Isolate the Src EA bits
0000148E  BCBC 0000003C            330              CMP.L   #$003C, D6         ; Compare with illegal mode #<data>
00001494  6700 0864                331              BEQ     UNKNOWN
00001498                           332              
00001498  E69E                     333              ROR.L   #3,D6              ; Roll 3 bits right
0000149A  0286 00000007            334              ANDI.L  #$0007,D6          ; Isolate the 3 Src Mode bits
000014A0  BCBC 00000001            335              CMP.L   #$0001, D6         ; Compare with illegal mode An
000014A6  6700 0852                336              BEQ     UNKNOWN
000014AA                           337              
000014AA                           338                                  
000014AA  2C05                     339              MOVE.L  D5,D6              ; Push D5 into D6 
000014AC  EC8E                     340              LSR.L   #6,D6              ; Shift six bits to the right
000014AE  0286 00000003            341              ANDI.L  #$0003,D6          ; Isolate the size bits
000014B4                           342                         
000014B4  BCBC 00000000            343              CMP.L   #$0000,D6          ; See if the size is '00'..
000014BA  6700 001A                344              BEQ     ADDIB              ; ..If so, it's ANDI.B
000014BE  BCBC 00000001            345              CMP.L   #$0001,D6          ; See if the size is '01'..
000014C4  6700 0020                346              BEQ     ADDIW              ; ..If so, it's ANDI.W
000014C8  BCBC 00000002            347              CMP.L   #$0002,D6          ; See if the size is '10'..
000014CE  6700 0026                348              BEQ     ADDIL              ; ..If so, it's ANDI.L
000014D2                           349              
000014D2  6000 0826                350              BRA     UNKNOWN            ; If it isn't any, then it's Unknown
000014D6                           351              
000014D6                           352  ADDIB       
000014D6  22FC 41444449            353              MOVE.L  #'ADDI',(A1)+
000014DC  32FC 2E42                354              MOVE.W  #'.B',(A1)+
000014E0  5C41                     355              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc
000014E2  6000 0022                356              BRA     ADDIOP
000014E6                           357              
000014E6                           358  ADDIW       
000014E6  22FC 41444449            359              MOVE.L  #'ADDI',(A1)+
000014EC  32FC 2E57                360              MOVE.W  #'.W',(A1)+
000014F0  5C41                     361              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
000014F2  6000 0012                362              BRA     ADDIOP
000014F6                           363              
000014F6                           364  ADDIL      
000014F6  22FC 41444449            365              MOVE.L  #'ADDI',(A1)+
000014FC  32FC 2E4C                366              MOVE.W  #'.L',(A1)+
00001500  5C41                     367              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
00001502  6000 0002                368              BRA     ADDIOP
00001506                           369  
00001506  22FC 20202020            370  ADDIOP      MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
0000150C  5841                     371              ADDQ    #4,D1              ; We added 4 bytes, aka 4 spaces
0000150E                           372              
0000150E  2C05                     373              MOVE.L  D5,D6              ; Push D5 into D6
00001510  0286 0000003F            374              ANDI.L  #$003F,D6          ; Isolate the Src EA bits 
00001516  4EB9 00001D1E            375              JSR EAGETSRCEA             ; Find and print the code stored in D6 
0000151C  4E75                     376              RTS
0000151E                           377                
0000151E  22FC 4D4F5645            378  MOVEB       MOVE.L  #'MOVE',(A1)+
00001524  32FC 2E42                379              MOVE.W  #'.B',(A1)+
00001528  5C41                     380              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
0000152A                           381              
0000152A  6000 0022                382              BRA MOVEOP
0000152E                           383              
0000152E  22FC 4D4F5645            384  MOVEW       MOVE.L  #'MOVE',(A1)+
00001534  32FC 2E57                385              MOVE.W  #'.W',(A1)+
00001538  5C41                     386              ADDQ    #6,D1               ; We added 6 new characters to our IOStringLoc 
0000153A                           387              
0000153A  6000 0012                388              BRA MOVEOP
0000153E                           389              
0000153E  22FC 4D4F5645            390  MOVEL       MOVE.L  #'MOVE',(A1)+
00001544  32FC 2E4C                391              MOVE.W  #'.L',(A1)+
00001548  5C41                     392              ADDQ    #6,D1               ; We added 6 new characters to our IOStringLoc 
0000154A                           393              
0000154A  6000 0002                394              BRA MOVEOP
0000154E                           395              
0000154E  22FC 20202020            396  MOVEOP      MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
00001554  5841                     397              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
00001556                           398              
00001556  2C05                     399              MOVE.L  D5,D6               ; Push D5 into D6
00001558  0286 0000003F            400              ANDI.L  #$003F,D6           ; Isolate the Src EA bits 
0000155E  4EB9 00001D1E            401              JSR EAGETSRCEA              ; Find and print the code stored in D6
00001564                           402              
00001564  12FC 002C                403              MOVE.B  #',',(A1)+
00001568  5241                     404              ADDQ    #1,D1
0000156A                           405              
0000156A  2C05                     406              MOVE.L  D5,D6               ; Push D5 into D6
0000156C  EC8E                     407              LSR.L   #6,D6               ; Shift six bits to the right
0000156E  0286 0000003F            408              ANDI.L  #$003F,D6           ; Isolate the Dst EA bits
00001574  4EB9 00001D5E            409              JSR EAGETDSTEA
0000157A  4E75                     410              RTS
0000157C                           411              
0000157C                           412  ; This label determines if the code is either CLR or NOP or RTS or JSR or MOVEM or LEA
0000157C                           413  ; Here we assume that the first left-most four bits equal 0100            
0000157C                           414  CNRJML      
0000157C  2C05                     415              MOVE.L  D5,D6              ; Push D5 into D6 (Copy OPcode over isolated nybble)
0000157E                           416              
0000157E                           417              *NOP & RTS's machine code is uniquely hardcoded, check first
0000157E  BCBC 00004E71            418              CMP.L   #$4E71,D6          ; See if the OPcode matches NOP's hardcode
00001584  6700 00CA                419              BEQ     NOP
00001588  BCBC 00004E75            420              CMP.L   #$4E75,D6          ; See if the OPcode matches RTS's hardcode
0000158E  6700 00DA                421              BEQ     RTS
00001592                           422                                         ; CLR's middle most left nybble is unique (0010)
00001592  E09E                     423              ROR.L   #8,D6              ; Rotate our OpCode to right-most nybble
00001594  0206 000F                424              ANDI.B  #$0F,D6            ; Isolate our opcode nybble
00001598  BC3C 0002                425              CMP.B   #$02,D6            ; See if matches nybble
0000159C  6700 0026                426              BEQ     CLR               
000015A0                           427              
000015A0  2C05                     428              MOVE.L  D5,D6              ; Push D5 into D6
000015A2  E08E                     429              LSR.L   #8,D6              ; Shift 8 bits to the right
000015A4                           430              
000015A4  0806 0000                431              BTST    #$00,D6            ; See if our right-most bit is set
000015A8  6600 0180                432              BNE     LEA                ; If our bit is set, branch to LEA     
000015AC                           433              
000015AC  E28E                     434              LSR.L   #1,D6              ; Shift another bit
000015AE  0806 0000                435              BTST    #$00,D6            ; See if our right-most bit is set
000015B2  6600 00D0                436              BNE     JSR                ; If this one is set, branch to JSR
000015B6                           437                 
000015B6                           438                                         ; MOVEM's middle most left nybble is unique (1-00)
000015B6  E49E                     439              ROR.L   #2,D6              ; first bit must be 0, rotate 1 bit 
000015B8  0806 0000                440              BTST    #0,D6               ; Compare again for 00 match
000015BC  6600 00F0                441              BNE     MOVEM                           
000015C0                           442                                         
000015C0  6000 0738                443              BRA     UNKNOWN            ; If it doesnt any match, then it's Unknown
000015C4                           444  
000015C4                           445  
000015C4                           446  ;  Here we assume the first left-most 8 bits have been confirmed: 0100 0010
000015C4                           447  CLR         
000015C4  2C05                     448              MOVE.L  D5,D6              ; Push D5 into D6
000015C6  EC8E                     449              LSR.L   #6,D6              ; Shift six bits to the right
000015C8  0286 00000003            450              ANDI.L  #$0003,D6          ; Isolate the two size bits
000015CE                           451                         
000015CE  BCBC 00000000            452              CMP.L   #$0000,D6          ; See if the size is '00'..
000015D4  6700 001A                453              BEQ     CLRB               ; ..If so, it's CLR.B
000015D8  BCBC 00000001            454              CMP.L   #$0001,D6          ; See if the size is '01'..
000015DE  6700 0026                455              BEQ     CLRW               ; ..If so, it's CLR.W
000015E2  BCBC 00000002            456              CMP.L   #$0002,D6          ; See if the size is '10'..
000015E8  6700 0032                457              BEQ     CLRL               ; ..If so, it's CLR.L
000015EC                           458              
000015EC  6000 070C                459              BRA     UNKNOWN            ; If it isn't any, then it's Unknown
000015F0                           460              
000015F0  32FC 434C                461  CLRB        MOVE.W  #'CL',(A1)+
000015F4  12FC 0052                462              MOVE.B  #'R',(A1)+
000015F8  12FC 002E                463              MOVE.B  #'.',(A1)+
000015FC  12FC 0042                464              MOVE.B  #'B',(A1)+
00001600  5A41                     465              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
00001602  6000 002E                466              BRA     CLROP
00001606                           467              
00001606  32FC 434C                468  CLRW        MOVE.W  #'CL',(A1)+
0000160A  12FC 0052                469              MOVE.B  #'R',(A1)+
0000160E  12FC 002E                470              MOVE.B  #'.',(A1)+
00001612  12FC 0057                471              MOVE.B  #'W',(A1)+
00001616  5A41                     472              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
00001618  6000 0018                473              BRA     CLROP
0000161C                           474  
0000161C  32FC 434C                475  CLRL        MOVE.W  #'CL',(A1)+
00001620  12FC 0052                476              MOVE.B  #'R',(A1)+
00001624  12FC 002E                477              MOVE.B  #'.',(A1)+
00001628  12FC 004C                478              MOVE.B  #'L',(A1)+
0000162C  5A41                     479              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
0000162E  6000 0002                480              BRA     CLROP
00001632                           481              
00001632  12FC 0020                482  CLROP       MOVE.B  #' ',(A1)+
00001636  32FC 2020                483              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
0000163A  32FC 2020                484              MOVE.W  #'  ',(A1)+
0000163E  5A41                     485              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces
00001640                           486              
00001640  2C05                     487              MOVE.L  D5,D6              ; Push D5 into D6
00001642  0286 0000003F            488              ANDI.L  #$003F,D6          ; Isolate the Src EA bits 
00001648  4EB9 00001D1E            489              JSR EAGETSRCEA             ; Find and print the code stored in D6
0000164E                           490  
0000164E  4E75                     491              RTS
00001650                           492              
00001650                           493  ;  Here we assume that all 16 bits have been confirmed 
00001650                           494  NOP
00001650  32FC 4E4F                495              MOVE.W  #'NO',(A1)+
00001654  12FC 0050                496              MOVE.B  #'P',(A1)+
00001658  5641                     497              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
0000165A                           498              
0000165A  12FC 0020                499              MOVE.B  #' ',(A1)+       ; Add a spacer into our IOStringLoc
0000165E  32FC 2020                500              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
00001662  32FC 2020                501              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
00001666  5A41                     502              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces        
00001668  4E75                     503              RTS
0000166A                           504  
0000166A                           505  ;  Here we assume that all 16 bits have been confirmed            
0000166A                           506  RTS         
0000166A  32FC 5254                507              MOVE.W  #'RT',(A1)+
0000166E  12FC 0053                508              MOVE.B  #'S',(A1)+
00001672  5641                     509              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
00001674                           510              
00001674  12FC 0020                511              MOVE.B  #' ',(A1)+       ; Add a spacer into our IOStringLoc
00001678  32FC 2020                512              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
0000167C  32FC 2020                513              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
00001680  5A41                     514              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces        
00001682  4E75                     515              RTS
00001684                           516              
00001684                           517  
00001684                           518  ;  Here we assume the first left-most 10 bits have been confirmed: 0100 1110 10 
00001684                           519  JSR         
00001684  32FC 4A53                520              MOVE.W  #'JS',(A1)+
00001688  12FC 0052                521              MOVE.B  #'R',(A1)+
0000168C  5641                     522              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
0000168E                           523              
0000168E  12FC 0020                524              MOVE.B  #' ',(A1)+
00001692  32FC 2020                525              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
00001696  22FC 20202020            526              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
0000169C  5E41                     527              ADDQ    #7,D1              ; We added 4 bytes, aka 4 spaces
0000169E  2C05                     528              MOVE.L  D5,D6              ; Push D5 into D6
000016A0                           529              
000016A0  0286 0000003F            530              ANDI.L  #$003F,D6          ; Isolate the Src EA bits 
000016A6  4EB9 00001D1E            531              JSR EAGETSRCEA             ; Find and print the code stored in D6 
000016AC  4E75                     532              RTS
000016AE                           533              
000016AE                           534  
000016AE                           535  ;  Here we assume that these left-most bits have been confirmed, where - have not been confirmed: 0100 --00
000016AE                           536  MOVEM       
000016AE  22FC 4D4F5645            537              MOVE.L  #'MOVE',(A1)+
000016B4  32FC 4D2E                538              MOVE.W  #'M.',(A1)+
000016B8  5C41                     539              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
000016BA                           540              
000016BA  2C05                     541              MOVE.L  D5,D6              ; Copy our OpCode
000016BC  EC8E                     542              LSR.L   #6,D6              ; Shift it 6 bits to the right
000016BE  0806 0000                543              BTST    #$00,D6            ; If our size bit is 0..
000016C2  6700 0006                544              BEQ     MOVEMW             ; .. Its a MOVEM of size W
000016C6  6000 000C                545              BRA     MOVEML             ; .. Otherwise it's of size L
000016CA                           546  
000016CA  12FC 0057                547  MOVEMW      MOVE.B  #'W',(A1)+
000016CE  5241                     548              ADDQ    #1,D1              ; We've added another character into IOStringLoc
000016D0  6000 0008                549              BRA     MOVEMOP            ; MovemOp label, to skip MovemL label
000016D4                           550              
000016D4  12FC 004C                551  MOVEML      MOVE.B  #'L',(A1)+
000016D8  5241                     552              ADDQ    #1,D1              ; We've added another character into IOStringLoc
000016DA                           553              
000016DA  12FC 0020                554  MOVEMOP     MOVE.B  #' ',(A1)+         ; Add a spacer into our IOStringLoc
000016DE  32FC 2020                555              MOVE.W  #'  ',(A1)+        ;
000016E2  5641                     556              ADDQ    #3,D1              ; We added 4 bytes, aka 4 spaces 
000016E4                           557              
000016E4  E88E                     558              LSR.L   #4,D6              ; Shift our OpCode 4 bits to the left of Size (going to the right)
000016E6  0806 0000                559              BTST    #$00,D6            ; Check our Direction bit
000016EA  6700 0006                560              BEQ     MOVEMPRED          ; If it's 0, our direction is Pre Decrement (eg. Move TO the stack)
000016EE  6000 001E                561              BRA     MOVEMPOSTI         ; Otherwise, it's Post Increment (eg. Move FROM the stack)
000016F2                           562              
000016F2                           563  MOVEMPRED   ; This part is where we get the gross A0-A6/D0-D7 part
000016F2  4EB9 00001F62            564              JSR     EAMOVEMPRED  
000016F8                           565              
000016F8  12FC 002C                566              MOVE.B  #',',(A1)+
000016FC  5241                     567              ADDQ    #1,D1
000016FE                           568              
000016FE  2C05                     569              MOVE.L  D5,D6              ; Copy our OpCode to D6
00001700  0286 0000003F            570              ANDI.L  #$3F,D6            ; Isolate our EA src bits
00001706                           571              
00001706  4EB9 00001D1E            572              JSR EAGETSRCEA  
0000170C                           573            
0000170C  4E75                     574              RTS
0000170E                           575  
0000170E  2C05                     576  MOVEMPOSTI  MOVE.L  D5,D6              ; Copy our OpCode to D6
00001710  0286 0000003F            577              ANDI.L  #$3F,D6            ; Isolate our EA src bits
00001716                           578              
00001716  4EB9 00001D1E            579              JSR EAGETSRCEA  
0000171C                           580              
0000171C  12FC 002C                581              MOVE.B  #',',(A1)+
00001720  5241                     582              ADDQ    #1,D1
00001722                           583              
00001722                           584              ; This part is where we get the gross A0-A6/D0-D7 part
00001722  4EB9 00001E78            585              JSR     EAMOVEMPOSTI
00001728                           586              
00001728  4E75                     587              RTS
0000172A                           588              
0000172A                           589  
0000172A                           590  ;  Here we assume that these left-most bits have been confirmed, where - have not been confirmed: 0100 ---1            
0000172A                           591  LEA
0000172A  32FC 4C45                592              MOVE.W  #'LE',(A1)+
0000172E  12FC 0041                593              MOVE.B  #'A',(A1)+
00001732  5641                     594              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
00001734                           595               
00001734  12FC 0020                596              MOVE.B  #' ',(A1)+          ; Added an extra space here, due to only 3 character OpCode
00001738  22FC 20202020            597              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
0000173E  32FC 2020                598              MOVE.W  #'  ',(A1)+ 
00001742  5E41                     599              ADDQ    #7,D1               ; We added 4 bytes, aka 4 spaces
00001744                           600              
00001744  2C05                     601              MOVE.L  D5,D6               ; Copy D5 into D6
00001746  0286 0000003F            602              ANDI.L  #$003F,D6           ; Isolate the Src EA bits
0000174C  4EB9 00001D1E            603              JSR EAGETSRCEA
00001752                           604              
00001752  12FC 002C                605              MOVE.B  #',',(A1)+
00001756  5241                     606              ADDQ    #1,D1
00001758                           607              
00001758  2C05                     608              MOVE.L  D5,D6               ; Copy D5 into D6
0000175A  E09E                     609              ROR.L   #8,D6               ; Rotate 9 bits to the right (An Dst bits)
0000175C  E29E                     610              ROR.L   #1,D6               ; 
0000175E  0286 00000003            611              ANDI.L  #$0003,D6           ; Isolate the An Destination bits
00001764  4EF9 00001DA8            612              JMP EAAN
0000176A  4E75                     613              RTS      
0000176C                           614              
0000176C                           615  Bcc         *(Implement)
0000176C                           616                   
0000176C  4E75                     617              RTS
0000176E                           618              
0000176E                           619  MOVEQ       *(Implement)
0000176E  22FC 4D4F5645            620              MOVE.L  #'MOVE',(A1)+
00001774  12FC 0051                621              MOVE.B  #'Q',(A1)+
00001778  5A41                     622              ADDQ    #5,D1               ; We added 4 new characters to our IOStringLoc
0000177A                           623              
0000177A  12FC 0020                624              MOVE.B  #' ',(A1)+
0000177E  32FC 2020                625              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
00001782  32FC 2020                626              MOVE.W  #'  ',(A1)+
00001786  5841                     627              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
00001788                           628              
00001788  2C05                     629              MOVE.L  D5,D6               ; Copy D5 into D6
0000178A  0286 000000FF            630              ANDI.L  #$00FF,D6           ; Isolate the Src EA bits
00001790                           631              
00001790  12FC 0023                632              MOVE.B  #'#',(A1)+
00001794  5241                     633              ADDQ    #1,D1               ; We added 4 bytes, aka 4 spaces
00001796                           634              ; THIS SECTION NEEDS TO POINT TO IMMEDIATE DATA EA, of size Word if it makes a difference
00001796                           635              
00001796  12FC 002C                636              MOVE.B  #',',(A1)+
0000179A  5241                     637              ADDQ    #1,D1
0000179C                           638              
0000179C  2C05                     639              MOVE.L  D5,D6               ; Copy D5 into D6
0000179E  E09E                     640              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
000017A0  E29E                     641              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
000017A2  0286 00000007            642              ANDI.L  #$0007,D6           ; Isolate the Dn Destination bits
000017A8  4EF9 00001D9A            643              JMP EADN
000017AE                           644              
000017AE  4E75                     645              RTS 
000017B0                           646              
000017B0                           647  DIVU 
000017B0  22FC 44495655            648              MOVE.L  #'DIVU',(A1)+
000017B6  5841                     649              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000017B8                           650              
000017B8  22FC 20202020            651              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
000017BE  32FC 2020                652              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
000017C2  5C41                     653              ADDQ    #6,D1               ; We added 4 bytes, aka 4 spaces
000017C4                           654              
000017C4  2C05                     655              MOVE.L  D5,D6               ; Copy D5 into D6
000017C6  0286 0000003F            656              ANDI.L  #$003F,D6           ; Isolate the Src EA bits
000017CC  4EB9 00001D1E            657              JSR EAGETSRCEA
000017D2                           658              
000017D2  12FC 002C                659              MOVE.B  #',',(A1)+
000017D6  5241                     660              ADDQ    #1,D1
000017D8                           661              
000017D8  2C05                     662              MOVE.L  D5,D6               ; Copy D5 into D6
000017DA  E09E                     663              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
000017DC  E29E                     664              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
000017DE  0286 00000007            665              ANDI.L  #$0007,D6           ; Isolate the Dn Destination bits
000017E4  4EF9 00001D9A            666              JMP EADN
000017EA                           667              
000017EA  4E75                     668              RTS
000017EC                           669  
000017EC                           670              
000017EC  2C05                     671  SUB         MOVE.L  D5,D6               ; Copy D5 into D6
000017EE  EC8E                     672              LSR.L   #6,D6               ; Shift the size bits to the far right
000017F0  0206 0007                673              ANDI.B  #$7,D6              ; Isolate the size bits    
000017F4                           674                   
000017F4  BC3C 0006                675              CMP.B   #%0110,D6            ; See if D6 is size "%100" through "%110"..
000017F8  6700 002E                676              BEQ     SUBLEA              ; If it is, our OpCode is in the format of..
000017FC  BC3C 0005                677              CMP.B   #%101,D6            ; .. Dn ~ <EA> --> <EA>
00001800  6700 0038                678              BEQ     SUBWEA
00001804  BC3C 0004                679              CMP.B   #%100,D6
00001808  6700 0042                680              BEQ     SUBBEA
0000180C                           681              
0000180C  BC3C 0002                682              CMP.B   #%10,D6             ; See if D6 is size "%000" through "%010"..
00001810  6700 004C                683              BEQ     SUBLDN              ; If it is, our OpCode is in the format of..
00001814  BC3C 0001                684              CMP.B   #%01,D6             ; .. <EA> ~ Dn --> Dn
00001818  6700 0056                685              BEQ     SUBWDN
0000181C  BC3C 0000                686              CMP.B   #%00,D6
00001820  6700 0060                687              BEQ     SUBBDN              ; == 000 at this point
00001824                           688              
00001824  6000 04D4                689              BRA     UNKNOWN
00001828                           690              
00001828  22FC 5355422E            691  SUBLEA      MOVE.L  #'SUB.',(A1)+
0000182E  5841                     692              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001830  12FC 004C                693              MOVE.B  #'L',(A1)+
00001834  5241                     694              ADDQ    #1,D1               ; We added 1 byte into D1
00001836  6000 01AC                695              BRA     ANDEA
0000183A                           696              
0000183A  22FC 5355422E            697  SUBWEA      MOVE.L  #'SUB.',(A1)+
00001840  5841                     698              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001842  12FC 0057                699              MOVE.B  #'W',(A1)+
00001846  5241                     700              ADDQ    #1,D1               ; We added 1 byte into D1
00001848  6000 019A                701              BRA     ANDEA
0000184C                           702  
0000184C  22FC 5355422E            703  SUBBEA      MOVE.L  #'SUB.',(A1)+
00001852  5841                     704              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001854  12FC 0042                705              MOVE.B  #'B',(A1)+
00001858  5241                     706              ADDQ    #1,D1               ; We added 1 byte into D1
0000185A  6000 0188                707              BRA     ANDEA
0000185E                           708  
0000185E  22FC 5355422E            709  SUBLDN      MOVE.L  #'SUB.',(A1)+
00001864  5841                     710              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001866  12FC 004C                711              MOVE.B  #'L',(A1)+
0000186A  5241                     712              ADDQ    #1,D1               ; We added 1 byte into D1
0000186C  6000 01E2                713              BRA ANDDN
00001870                           714              
00001870  22FC 5355422E            715  SUBWDN      MOVE.L  #'SUB.',(A1)+
00001876  5841                     716              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001878  12FC 0057                717              MOVE.B  #'W',(A1)+
0000187C  5241                     718              ADDQ    #1,D1               ; We added 1 byte into D1
0000187E  6000 01D0                719              BRA ANDDN
00001882                           720  
00001882  22FC 5355422E            721  SUBBDN      MOVE.L  #'SUB.',(A1)+
00001888  5841                     722              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
0000188A  12FC 0042                723              MOVE.B  #'B',(A1)+
0000188E  5241                     724              ADDQ    #1,D1               ; We added 1 byte into D1
00001890  6000 01BE                725              BRA ANDDN  
00001894                           726  
00001894                           727  ;  Here we assume that these left-most nybble has been confirmed: 1011  
00001894                           728  CMP        
00001894  2C05                     729              MOVE.L  D5,D6               ; Push D5 into D6
00001896  EC9E                     730              ROR.L   #6,D6               ; Rotate 6 bits to the right
00001898  E38E                     731              LSL.L   #1,D6               ; Add 0 to right most bit
0000189A  0206 000F                732              ANDI.B  #$0F,D6             ; Isolate right-most nybble
0000189E                           733              
0000189E  BC3C 0000                734              CMP.B   #$00,D6             ; If it matches CMP.B's size bit + 0 added to right
000018A2  6700 0016                735              BEQ     CMPB                ; First 4 left-most bits plus size of CMP confirmed
000018A6                           736  
000018A6  BC3C 0002                737              CMP.B   #$02,D6             ; If it matches CMP.W's size bit + 0 added to right
000018AA  6700 0024                738              BEQ     CMPW                ; First 4 left-most bits plus size of CMP confirmed 
000018AE                           739  
000018AE  BC3C 0004                740              CMP.B   #$04,D6             ; If it matches CMP.B's size bit + 0 added to right
000018B2  6700 0032                741              BEQ     CMPL                ; First 4 left-most bits plus size of CMP confirmed 
000018B6                           742   
000018B6  6000 0442                743              BRA     UNKNOWN             ; else unknown 
000018BA                           744  
000018BA                           745  ;  Here we assume that confirming these bits, 1011 --- 000 --- ---, is enough to identify CMP.B 
000018BA  32FC 434D                746  CMPB        MOVE.W  #'CM',(A1)+
000018BE  12FC 0050                747              MOVE.B  #'P',(A1)+
000018C2  12FC 002E                748              MOVE.B  #'.',(A1)+
000018C6  12FC 0042                749              MOVE.B  #'B',(A1)+
000018CA  5A41                     750              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
000018CC  6000 002E                751              BRA     CMPOP
000018D0                           752  
000018D0                           753  ;  Here we assume that confirming these bits, 1011 --- 001 --- ---, is enough to identify CMP.W   
000018D0  32FC 434D                754  CMPW        MOVE.W  #'CM',(A1)+
000018D4  12FC 0050                755              MOVE.B  #'P',(A1)+
000018D8  12FC 002E                756              MOVE.B  #'.',(A1)+
000018DC  12FC 0057                757              MOVE.B  #'W',(A1)+
000018E0  5A41                     758              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
000018E2  6000 0018                759              BRA     CMPOP
000018E6                           760              
000018E6                           761  ;  Here we assume that confirming these bits, 1011 --- 010 --- ---, is enough to identify CMP.L
000018E6  32FC 434D                762  CMPL        MOVE.W  #'CM',(A1)+
000018EA  12FC 0050                763              MOVE.B  #'P',(A1)+
000018EE  12FC 002E                764              MOVE.B  #'.',(A1)+
000018F2  12FC 004C                765              MOVE.B  #'L',(A1)+
000018F6  5A41                     766              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
000018F8  6000 0002                767              BRA     CMPOP
000018FC                           768              
000018FC  12FC 0020                769  CMPOP       MOVE.B  #' ',(A1)+
00001900  32FC 2020                770              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
00001904  32FC 2020                771              MOVE.W  #'  ',(A1)+
00001908  5A41                     772              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces
0000190A                           773              
0000190A  2C05                     774              MOVE.L  D5,D6               ; Push D5 into D6
0000190C  0286 0000003F            775              ANDI.L  #$003F,D6           ; Isolate the Src EA bits 
00001912  4EB9 00001D1E            776              JSR EAGETSRCEA              ; Find and print the code stored in D6
00001918                           777              
00001918  12FC 002C                778              MOVE.B  #',',(A1)+
0000191C  5241                     779              ADDQ    #1,D1
0000191E                           780              
0000191E  2C05                     781              MOVE.L  D5,D6               ; Copy D5 into D6
00001920  E09E                     782              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00001922  E29E                     783              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00001924  0286 00000003            784              ANDI.L  #$0003,D6           ; Isolate the Dn Destination bits
0000192A  4EF9 00001D9A            785              JMP EADN
00001930                           786              
00001930  4E75                     787              RTS          
00001932                           788          
00001932                           789  ; This label determines if the code is either MULS or AND, by looking at it's size bits     
00001932  2C05                     790  MULSAND     MOVE.L  D5,D6               ; Copy D5 into D6
00001934  EC8E                     791              LSR.L   #6,D6               ; Shift the size bits to the far right
00001936  0206 0007                792              ANDI.B  #$7,D6              ; Isolate the size bits
0000193A  BC3C 0007                793              CMP.B   #7,D6               ; See if the size is '111'..
0000193E  6704                     794              BEQ.S   MULS                ; ..If so, it's a MULS opcode
00001940  6000 003E                795              BRA     AND                 ; Otherwise, it's an AND code
00001944                           796          
00001944  22FC 4D554C53            797  MULS        MOVE.L  #'MULS',(A1)+
0000194A  5841                     798              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
0000194C                           799              
0000194C  22FC 20202020            800              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
00001952  32FC 2020                801              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
00001956  5C41                     802              ADDQ    #6,D1               ; We added 4 bytes, aka 4 spaces
00001958                           803              
00001958  2C05                     804              MOVE.L  D5,D6               ; Copy D5 into D6
0000195A  0286 0000003F            805              ANDI.L  #$003F,D6           ; Isolate the Src EA bits
00001960  4EB9 00001D1E            806              JSR EAGETSRCEA
00001966                           807              
00001966  12FC 002C                808              MOVE.B  #',',(A1)+
0000196A  5241                     809              ADDQ    #1,D1
0000196C                           810              
0000196C  2C05                     811              MOVE.L  D5,D6               ; Copy D5 into D6
0000196E  E09E                     812              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00001970  E29E                     813              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00001972  0286 00000007            814              ANDI.L  #$0007,D6           ; Isolate the Dn Destination bits
00001978  4EF9 00001D9A            815              JMP EADN
0000197E                           816              
0000197E  4E75                     817              RTS
00001980                           818              
00001980                           819  ; At this point, we know D6 is the size of our opcode
00001980  BC3C 0006                820  AND         CMP.B   #%0110,D6            ; See if D6 is size "%100" through "%110"..
00001984  6700 002E                821              BEQ     ANDLEA              ; If it is, our OpCode is in the format of..
00001988  BC3C 0005                822              CMP.B   #%101,D6            ; .. Dn ~ <EA> --> <EA>
0000198C  6700 0036                823              BEQ     ANDWEA
00001990  BC3C 0004                824              CMP.B   #%100,D6
00001994  6700 003E                825              BEQ     ANDBEA
00001998                           826              
00001998  BC3C 0002                827              CMP.B   #%10,D6             ; See if D6 is size "%000" through "%010"..
0000199C  6700 007C                828              BEQ     ANDLDN              ; If it is, our OpCode is in the format of..
000019A0  BC3C 0001                829              CMP.B   #%01,D6             ; .. <EA> ~ Dn --> Dn
000019A4  6700 0086                830              BEQ     ANDWDN
000019A8  BC3C 0000                831              CMP.B   #%00,D6
000019AC  6700 0090                832              BEQ     ANDBDN              ; == 000 at this point
000019B0                           833              
000019B0  6000 0348                834              BRA     UNKNOWN
000019B4                           835              
000019B4  22FC 414E442E            836  ANDLEA      MOVE.L  #'AND.',(A1)+
000019BA  12FC 004C                837              MOVE.B  #'L',(A1)+
000019BE  5A41                     838              ADDQ    #5,D1               ; We added 5 byte into D1
000019C0  6000 0022                839              BRA     ANDEA
000019C4                           840              
000019C4  22FC 414E442E            841  ANDWEA      MOVE.L  #'AND.',(A1)+
000019CA  12FC 0057                842              MOVE.B  #'W',(A1)+
000019CE  5A41                     843              ADDQ    #5,D1               ; We added 5 byte into D1
000019D0  6000 0012                844              BRA     ANDEA
000019D4                           845  
000019D4  22FC 414E442E            846  ANDBEA      MOVE.L  #'AND.',(A1)+
000019DA  12FC 0042                847              MOVE.B  #'B',(A1)+
000019DE  5A41                     848              ADDQ    #5,D1               ; We added 5 byte into D1
000019E0  6000 0002                849              BRA     ANDEA
000019E4                           850  
000019E4  12FC 0020                851  ANDEA       MOVE.B  #' ',(A1)+          ; Add a spacer into our IOStringLoc
000019E8  32FC 2020                852              MOVE.W  #'  ',(A1)+          ; Add a spacer into our IOStringLoc
000019EC  12FC 0020                853              MOVE.B  #' ',(A1)+          ; Add a spacer into our IOStringLoc
000019F0  5241                     854              ADDQ    #1,D1               ; We added 4 bytes, aka 4 spaces
000019F2                           855              
000019F2  2C05                     856              MOVE.L  D5,D6
000019F4  E08E                     857              LSR.L   #8,D6               ; Shift our OpCode a total of 9 bits to the right
000019F6  E28E                     858              LSR.L   #1,D6               ; 
000019F8  0286 00000007            859              ANDI.L  #$07,D6             ; Isolate our data register
000019FE                           860              
000019FE  4EB9 00001D9A            861              JSR EADN
00001A04                           862              
00001A04  12FC 002C                863              MOVE.B  #',',(A1)+
00001A08  5241                     864              ADDQ    #1,D1
00001A0A                           865              
00001A0A  2C05                     866              MOVE.L  D5,D6               ; Copy our OpCode again
00001A0C  0286 0000003F            867              ANDI.L  #$3F,D6             ; Isolate our EA bits
00001A12                           868              
00001A12  4EB9 00001D1E            869              JSR EAGETSRCEA  
00001A18                           870              
00001A18  4E75                     871              RTS
00001A1A                           872              
00001A1A  22FC 414E442E            873  ANDLDN      MOVE.L  #'AND.',(A1)+
00001A20  5841                     874              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001A22  12FC 004C                875              MOVE.B  #'L',(A1)+
00001A26  5241                     876              ADDQ    #1,D1               ; We added 1 byte into D1
00001A28  6000 0026                877              BRA ANDDN
00001A2C                           878              
00001A2C  22FC 414E442E            879  ANDWDN      MOVE.L  #'AND.',(A1)+
00001A32  5841                     880              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001A34  12FC 0057                881              MOVE.B  #'W',(A1)+
00001A38  5241                     882              ADDQ    #1,D1               ; We added 1 byte into D1
00001A3A  6000 0014                883              BRA ANDDN
00001A3E                           884  
00001A3E  22FC 414E442E            885  ANDBDN      MOVE.L  #'AND.',(A1)+
00001A44  5841                     886              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001A46  12FC 0042                887              MOVE.B  #'B',(A1)+
00001A4A  5241                     888              ADDQ    #1,D1               ; We added 1 byte into D1
00001A4C  6000 0002                889              BRA ANDDN  
00001A50                           890  
00001A50                           891  ANDDN
00001A50  12FC 0009                892              MOVE.B  #$09,(A1)+          ; Add a spacer into our IOStringLoc
00001A54  5241                     893              ADDQ    #1,D1               ; We added 4 bytes, aka 4 spaces
00001A56                           894              
00001A56  2C05                     895              MOVE.L  D5,D6               ; Copy our OpCode again
00001A58  0286 0000003F            896              ANDI.L  #$3F,D6             ; Isolate our EA bits
00001A5E                           897              
00001A5E  4EB9 00001D1E            898              JSR EAGETSRCEA              
00001A64                           899              
00001A64  12FC 002C                900              MOVE.B  #',',(A1)+
00001A68  5241                     901              ADDQ    #1,D1
00001A6A                           902              
00001A6A  2C05                     903              MOVE.L  D5,D6
00001A6C  E08E                     904              LSR.L   #8,D6               ; Shift our OpCode a total of 9 bits to the right
00001A6E  E28E                     905              LSR.L   #1,D6               ; 
00001A70  0286 00000007            906              ANDI.L  #$07,D6             ; Isolate our data register
00001A76                           907              
00001A76  4EB9 00001D9A            908              JSR EADN
00001A7C                           909              
00001A7C  4E75                     910              RTS
00001A7E                           911  
00001A7E                           912  ; This label determines if the code is either ADD or ADDA           
00001A7E  2C05                     913  ADDADDA     MOVE.L  D5,D6               ; Copy D5 into D6
00001A80  EC8E                     914              LSR.L   #6,D6               ; Shift the size bits to the far right
00001A82  0206 0007                915              ANDI.B  #$7,D6              ; Isolate the size bits
00001A86                           916              
00001A86  BC3C 0006                917              CMP.B   #%0110,D6           ; See if D6 is size "%100" through "%110"..
00001A8A  6700 0074                918              BEQ     ADDLEA              ; If it is, our OpCode is in the format of..
00001A8E  BC3C 0005                919              CMP.B   #%101,D6            ; .. Dn ~ <EA> --> <EA>
00001A92  6700 007E                920              BEQ     ADDWEA
00001A96  BC3C 0004                921              CMP.B   #%100,D6
00001A9A  6700 0088                922              BEQ     ADDBEA
00001A9E                           923              
00001A9E  BC3C 0002                924              CMP.B   #%10,D6             ; See if D6 is size "%000" through "%010"..
00001AA2  6700 0026                925              BEQ     ADDLDN              ; If it is, our OpCode is in the format of..
00001AA6  BC3C 0001                926              CMP.B   #%01,D6             ; .. <EA> ~ Dn --> Dn
00001AAA  6700 0030                927              BEQ     ADDWDN
00001AAE  BC3C 0000                928              CMP.B   #%00,D6
00001AB2  6700 003A                929              BEQ     ADDBDN              ; == 000 at this point
00001AB6                           930              
00001AB6  BC3C 0003                931              CMP.B   #%011,D6            ; ADDA Word Operation <EA> -> An 
00001ABA  6700 007A                932              BEQ     ADDAW
00001ABE  BC3C 0007                933              CMP.B   #%111,D6            ; ADDA Word Operation <EA> -> An  
00001AC2  6700 0084                934              BEQ     ADDAL
00001AC6  6000 0232                935              BRA     UNKNOWN
00001ACA                           936              
00001ACA  22FC 4144442E            937  ADDLDN      MOVE.L  #'ADD.',(A1)+
00001AD0  5841                     938              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001AD2  12FC 004C                939              MOVE.B  #'L',(A1)+
00001AD6  5241                     940              ADDQ    #1,D1               ; We added 1 byte into D1
00001AD8  6000 FF76                941              BRA ANDDN
00001ADC                           942              
00001ADC  22FC 4144442E            943  ADDWDN      MOVE.L  #'ADD.',(A1)+
00001AE2  5841                     944              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001AE4  12FC 0057                945              MOVE.B  #'W',(A1)+
00001AE8  5241                     946              ADDQ    #1,D1               ; We added 1 byte into D1
00001AEA  6000 FF64                947              BRA ANDDN
00001AEE                           948  
00001AEE  22FC 4144442E            949  ADDBDN      MOVE.L  #'ADD.',(A1)+
00001AF4  5841                     950              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001AF6  12FC 0042                951              MOVE.B  #'B',(A1)+
00001AFA  5241                     952              ADDQ    #1,D1               ; We added 1 byte into D1
00001AFC  6000 FF52                953              BRA ANDDN  
00001B00                           954              
00001B00  22FC 4144442E            955  ADDLEA      MOVE.L  #'ADD.',(A1)+
00001B06  5841                     956              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001B08  12FC 004C                957              MOVE.B  #'L',(A1)+
00001B0C  5241                     958              ADDQ    #1,D1               ; We added 1 byte into D1
00001B0E  6000 FED4                959              BRA     ANDEA
00001B12                           960              
00001B12  22FC 4144442E            961  ADDWEA      MOVE.L  #'ADD.',(A1)+
00001B18  5841                     962              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001B1A  12FC 0057                963              MOVE.B  #'W',(A1)+
00001B1E  5241                     964              ADDQ    #1,D1               ; We added 1 byte into D1
00001B20  6000 FEC2                965              BRA     ANDEA
00001B24                           966  
00001B24  22FC 4144442E            967  ADDBEA      MOVE.L  #'ADD.',(A1)+
00001B2A  5841                     968              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001B2C  12FC 0042                969              MOVE.B  #'B',(A1)+
00001B30  5241                     970              ADDQ    #1,D1               ; We added 1 byte into D1
00001B32  6000 FEB0                971              BRA     ANDEA
00001B36                           972              
00001B36  22FC 41444441            973  ADDAW       MOVE.L  #'ADDA',(A1)+
00001B3C  5841                     974              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001B3E  32FC 2E57                975              MOVE.W  #'.W',(A1)+
00001B42  5441                     976              ADDQ    #2,D1               ; We added 1 byte into D1
00001B44  6000 0014                977              BRA     ADDAN
00001B48                           978              
00001B48  22FC 41444441            979  ADDAL       MOVE.L  #'ADDA',(A1)+
00001B4E  5841                     980              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001B50  32FC 2E4C                981              MOVE.W  #'.L',(A1)+
00001B54  5441                     982              ADDQ    #2,D1               ; We added 1 byte into D1
00001B56  6000 0002                983              BRA     ADDAN
00001B5A                           984         
00001B5A                           985  ADDAN
00001B5A  22FC 20202020            986              MOVE.L  #'    ',(A1)+          ; Add a spacer into our IOStringLoc
00001B60                           987              
00001B60  5841                     988              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
00001B62                           989              
00001B62  2C05                     990              MOVE.L  D5,D6               ; Copy our OpCode again
00001B64  0286 0000003F            991              ANDI.L  #$3F,D6             ; Isolate our EA bits
00001B6A                           992              
00001B6A  4EB9 00001D1E            993              JSR EAGETSRCEA              
00001B70                           994              
00001B70  12FC 002C                995              MOVE.B  #',',(A1)+
00001B74  5241                     996              ADDQ    #1,D1
00001B76                           997              
00001B76  2C05                     998              MOVE.L  D5,D6
00001B78  E08E                     999              LSR.L   #8,D6               ; Shift our OpCode a total of 9 bits to the right
00001B7A  E28E                    1000              LSR.L   #1,D6               ; 
00001B7C  0286 00000007           1001              ANDI.L  #$07,D6             ; Isolate our data register
00001B82                          1002              
00001B82  4EB9 00001DA8           1003              JSR EAAN
00001B88                          1004              
00001B88  4E75                    1005              RTS
00001B8A                          1006  ; This label determines if the code is either ASd (ASR) or LSd (LSL) or ROd (ROL) 
00001B8A                          1007  ASLSRO
00001B8A  2C05                    1008              MOVE.L  D5,D6               ; Copy our OpCode
00001B8C  EC4E                    1009              LSR.W   #6,D6               ; Shift our size bits into place
00001B8E  0206 0003               1010              ANDI.B  #$03,D6             ; Isolate our size bits
00001B92  BC3C 0003               1011              CMP.B   #%11,D6             ; If our size is '11'..
00001B96  6700 00E2               1012              BEQ     AASLSRO             ; ..this is an address ASLSRO
00001B9A                          1013              
00001B9A  2C05                    1014              MOVE.L  D5,D6               ; Copy our OpCode
00001B9C  E64E                    1015              LSR.W   #3,D6               ; Shift our identification bits over
00001B9E  0206 0003               1016              ANDI.B  #03,D6              ;  and isolate them
00001BA2                          1017              
00001BA2  BC3C 0000               1018              CMP.B   #%00,D6             ; If '00', this is a ASd op
00001BA6  6700 0016               1019              BEQ     ASD
00001BAA  BC3C 0001               1020              CMP.B   #%01,D6             ; If '01', this is a LSd op
00001BAE  6700 0018               1021              BEQ     LSD
00001BB2  BC3C 0003               1022              CMP.B   #%11,D6             ; If '11', this is a ROd op
00001BB6  6700 001A               1023              BEQ     ROD
00001BBA                          1024              
00001BBA  6000 013E               1025              BRA     UNKNOWN             ; This catches for ROX, non-required op
00001BBE                          1026  
00001BBE  32FC 4153               1027  ASD         MOVE.W  #'AS',(A1)+
00001BC2  5441                    1028              ADDQ    #2,D1
00001BC4  6000 0016               1029              BRA     ASLSRODR
00001BC8                          1030              
00001BC8  32FC 4C53               1031  LSD         MOVE.W  #'LS',(A1)+
00001BCC  5441                    1032              ADDQ    #2,D1
00001BCE  6000 000C               1033              BRA     ASLSRODR
00001BD2                          1034              
00001BD2  32FC 524F               1035  ROD         MOVE.W  #'RO',(A1)+
00001BD6  5441                    1036              ADDQ    #2,D1
00001BD8  6000 0002               1037              BRA     ASLSRODR
00001BDC                          1038              
00001BDC                          1039  ; This section checks our ASd/LSd/ROd direction, and defaults to Right 
00001BDC  2C05                    1040  ASLSRODR    MOVE.L  D5,D6               ; Copy our OpCode
00001BDE  E09E                    1041              ROR.L   #8,D6               ; Shift our direction bit into place
00001BE0  0806 0000               1042              BTST    #$00,D6             ; Check our right-most bit 
00001BE4  6600 0010               1043              BNE     ASLSRODL            ; If it's '1', our direction is left
00001BE8                          1044              
00001BE8  12FC 0052               1045              MOVE.B  #'R',(A1)+          ; Otherwise it's right
00001BEC  12FC 002E               1046              MOVE.B  #'.',(A1)+
00001BF0  5441                    1047              ADDQ    #2,D1
00001BF2                          1048              
00001BF2  6000 000C               1049              BRA ASLSROSIZE
00001BF6                          1050              
00001BF6                          1051  ; This section is our ASd/LSd/ROd left direction
00001BF6  12FC 004C               1052  ASLSRODL    MOVE.B  #'L',(A1)+          ; L for Left
00001BFA  12FC 002E               1053              MOVE.B  #'.',(A1)+
00001BFE  5441                    1054              ADDQ    #2,D1
00001C00                          1055              ; Carry into our Size determiner
00001C00                          1056  ; Determines what size our ASd/LSd/ROd is
00001C00                          1057  ;  Our previous operations on D6 leave our size bits
00001C00                          1058  ;  just our of range, so we shift them in
00001C00                          1059  ASLSROSIZE  
00001C00  E59E                    1060              ROL.L   #2,D6               ; Shift our size bits in
00001C02  0206 0003               1061              ANDI.B  #$03,D6             ; Isolate our size bits
00001C06  BC3C 0000               1062              CMP.B   #%00,D6             ; If our size is '00'..
00001C0A  6700 0012               1063              BEQ     ASLSROB             ; ..Then it's a byte op
00001C0E  BC3C 0001               1064              CMP.B   #%01,D6             ; If our size is '01'..
00001C12  6700 0012               1065              BEQ     ASLSROW             ; ..Then it's a word op
00001C16                          1066              ; Otherwise it's a long op, because we accounted for '11' earlier
00001C16                          1067              
00001C16  12FC 004C               1068              MOVE.B  #'L',(A1)+          ; Add L for Long
00001C1A  6000 000E               1069              BRA     ASLSROIR            ; Complete the rest of the ASLSRO Op
00001C1E                          1070              
00001C1E  12FC 0042               1071  ASLSROB     MOVE.B  #'B',(A1)+          ; Add B for Byte
00001C22  6000 0006               1072              BRA     ASLSROIR            ; Complete the rest of the ASLSRO Op
00001C26                          1073              
00001C26  12FC 0057               1074  ASLSROW     MOVE.B  #'W',(A1)+          ; Add W for Word
00001C2A                          1075              ; Carry through to complete the rest of the ASLSRO Op  
00001C2A                          1076       
00001C2A                          1077  ; This section determines if our ASLSRO is an Immediate or Dn shfit, and defaults to Immediate
00001C2A  12FC 0020               1078  ASLSROIR    MOVE.B  #' ',(A1)+
00001C2E  32FC 2020               1079              MOVE.W  #'  ',(A1)+
00001C32  32FC 2020               1080              MOVE.W  #'  ',(A1)+
00001C36  5C41                    1081              ADDQ    #6,D1               ; We've added 5 new characters (Size char, plus spaces)
00001C38                          1082              
00001C38                          1083              ;MOVE.L  D5,D6
00001C38  E39E                    1084              ROL.L   #1,D6               ; Get our Immediate / Register bit out front
00001C3A  0806 0000               1085              BTST.L  #$00,D6
00001C3E  6600 000C               1086              BNE     ASLSROIRDN          ; If it's '1', we have a Dn ASLSRO
00001C42                          1087              ; Otherwise, assume immediate ASLSRO
00001C42  12FC 0023               1088              MOVE.B  #'#',(A1)+
00001C46  5241                    1089              ADDQ    #1,D1
00001C48  6000 0008               1090              BRA     ASLSROOP            ; Branch to our ASLSRO Op finish
00001C4C                          1091  ; An ASLSRO of Dn Register type   
00001C4C  12FC 0044               1092  ASLSROIRDN  MOVE.B  #'D',(A1)+
00001C50  5241                    1093              ADDQ    #1,D1
00001C52                          1094              ; Continue through to our ASLSRO Op finish
00001C52                          1095  ; Finishes the ASLSRO Op
00001C52                          1096  ASLSROOP
00001C52  2C05                    1097              MOVE.L  D5,D6               ; Copy our OpCode into D6
00001C54  E09E                    1098              ROR.L   #8,D6               ; Shift our Count/Reg bits into place
00001C56  E29E                    1099              ROR.L   #1,D6               ;
00001C58  0206 0007               1100              ANDI.B  #$07,D6             ; Isolate the Count/Reg bits
00001C5C                          1101              
00001C5C  0606 0030               1102              ADDI.B  #48,D6 
00001C60  12C6                    1103              MOVE.B  D6,(A1)+            ; Push our number to the IOStringLoc
00001C62  5241                    1104              ADDQ    #1,D1
00001C64                          1105              
00001C64  12FC 002C               1106              MOVE.B  #',',(A1)+
00001C68  5241                    1107              ADDQ    #1,D1
00001C6A                          1108              
00001C6A  2C05                    1109              MOVE.L  D5,D6               ; Isolate our Dn affected num bits
00001C6C  0286 00000007           1110              ANDI.L  #$07,D6             ;
00001C72  4EB9 00001D9A           1111              JSR     EADN
00001C78                          1112              
00001C78  4E75                    1113              RTS
00001C7A                          1114  ; Start of the Effective Address version of ASLSRO
00001C7A  2C05                    1115  AASLSRO     MOVE.L  D5,D6               ; Copy our OpCode into D6
00001C7C  EF5E                    1116              ROL.W   #7,D6               ; Shift our determination bits to the far right
00001C7E  0206 0007               1117              ANDI.B  #$07,D6             ; Isolate the determination bits   
00001C82                          1118              
00001C82  BC3C 0001               1119              CMP.B   #$01,D6             ; If our determination is '001'..
00001C86  6700 0020               1120              BEQ     ALSD                ; It's a Logical Shift
00001C8A  BC3C 0003               1121              CMP.B   #$03,D6             ; If it's '011'
00001C8E  6700 0022               1122              BEQ     AROD                ; It's a Rotation 
00001C92  BC3C 0000               1123              CMP.B   #$00,D6             ; If it's '000'
00001C96  6700 0006               1124              BEQ     AASD                ; It's an Arithmetic Shift
00001C9A                          1125              
00001C9A  6000 005E               1126              BRA     UNKNOWN              ; Otherwise it's data
00001C9E                          1127  
00001C9E  32FC 4153               1128  AASD        MOVE.W  #'AS',(A1)+
00001CA2  5441                    1129              ADDQ    #2,D1
00001CA4  6000 0016               1130              BRA     AASLSRODR
00001CA8                          1131              
00001CA8  32FC 4C53               1132  ALSD        MOVE.W  #'LS',(A1)+
00001CAC  5441                    1133              ADDQ    #2,D1
00001CAE  6000 000C               1134              BRA     AASLSRODR
00001CB2                          1135              
00001CB2  32FC 524F               1136  AROD        MOVE.W  #'RO',(A1)+
00001CB6  5441                    1137              ADDQ    #2,D1
00001CB8  6000 0002               1138              BRA     AASLSRODR
00001CBC                          1139              
00001CBC                          1140  ; This section checks our ASd/LSd/ROd direction, and defaults to Right 
00001CBC  2C05                    1141  AASLSRODR   MOVE.L  D5,D6              ; Copy our OpCode
00001CBE  E09E                    1142              ROR.L   #8,D6               ; Shift our direction bit into place
00001CC0  0806 0000               1143              BTST    #$00,D6             ; Check our right-most bit 
00001CC4  6600 000C               1144              BNE     AASLSRODL           ; If it's '1', our direction is left
00001CC8                          1145              
00001CC8  12FC 0052               1146              MOVE.B  #'R',(A1)+          ; Otherwise it's right
00001CCC  5241                    1147              ADDQ    #1,D1
00001CCE                          1148              
00001CCE  6000 0008               1149              BRA AASLSROOP
00001CD2                          1150              
00001CD2                          1151  ; This section is our ASd/LSd/ROd left direction
00001CD2  12FC 004C               1152  AASLSRODL   MOVE.B  #'L',(A1)+          ; L for Left
00001CD6  5241                    1153              ADDQ    #1,D1
00001CD8                          1154              ; Carry into finishing AASLSRO op
00001CD8                          1155  
00001CD8                          1156  ; This section finishes off our Effective Address ASLSRO Op
00001CD8  2C05                    1157  AASLSROOP   MOVE.L  D5,D6               ; Copy our OpCode
00001CDA  0286 0000003F           1158              ANDI.L  #$3F,D6             ; Isolate our EA bits
00001CE0                          1159              
00001CE0  12FC 0020               1160              MOVE.B  #' ',(A1)+
00001CE4  12FC 0020               1161              MOVE.B  #' ',(A1)+
00001CE8  12FC 0020               1162              MOVE.B  #' ',(A1)+
00001CEC  12FC 0020               1163              MOVE.B  #' ',(A1)+
00001CF0  5841                    1164              ADDQ    #4,D1
00001CF2                          1165              
00001CF2  4EB9 00001D1E           1166              JSR EAGETSRCEA
00001CF8                          1167              
00001CF8  4E75                    1168              RTS
00001CFA                          1169  UNKNOWN
00001CFA  22FC 44415441           1170              MOVE.L  #'DATA',(A1)+
00001D00  5841                    1171              ADDQ    #4,D1           ; We added 4 new characters to our IOStringLoc 
00001D02                          1172              
00001D02  22FC 20202020           1173              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
00001D08  32FC 2020               1174              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
00001D0C  5C41                    1175              ADDQ    #6,D1               ; We added 6 bytes, aka 6 spaces
00001D0E                          1176              
00001D0E  12FC 0024               1177              MOVE.B  #'$',(A1)+
00001D12  5241                    1178              ADDQ    #1,D1
00001D14                          1179              
00001D14  2C05                    1180              MOVE.L  D5,D6
00001D16  4EB9 00001E54           1181              JSR     EAHEXtoASCII
00001D1C                          1182              
00001D1C  4E75                    1183              RTS
00001D1E                          1184  
00001D1E                          1185  
00001D1E                          1186  
00001D1E                          1187  
00001D1E                          1188  
00001D1E                          1189  
00001D1E                          1190  
00001D1E                          1191  
00001D1E                          1192  
00001D1E                          1193  
00001D1E                          1194  -------------------- end include --------------------
00001D1E                          1195      INCLUDE "EA.X68"        ; Handles EA types
00001D1E                          1196  
00001D1E                          1197  
00001D1E                          1198  ; It is assumed that D6 contains the bits for the EA, algined to the far right. D5 contains
00001D1E                          1199  ;  the original full op-code being reffered to. We assume that A2 contains the address 
00001D1E                          1200  ;  pointing to the start of our EA address (if applicable), and we assume that A1 contains
00001D1E                          1201  ;  the address pointing to our IOStringLoc. D1 contains the current length to be printed from A1
00001D1E                          1202  
00001D1E                          1203  ; For this method, D6 is in the format of: <3 bits Src Mode><3 bits Src Reg> 
00001D1E                          1204  EAGETSRCEA  
00001D1E  E69E                    1205      ROR.L   #3,D6       ; Rotate our bits 3 to the right
00001D20  1E06                    1206      MOVE.B  D6,D7       ; Store the mode of the EA in D7
00001D22  E79E                    1207      ROL.L   #3,D6       ; Rotate our 3 bits back
00001D24  0286 00000007           1208      ANDI.L  #$0007,D6   ; Isolate the 3 rightmost bits as 'Reg'
00001D2A  BE3C 0000               1209      CMP.B   #0,D7       ; See if the mode == '000'
00001D2E  6700 006A               1210      BEQ     EADN
00001D32                          1211  
00001D32  BE3C 0001               1212      CMP.B   #1,D7       ; See if the mode == '001'
00001D36  6700 0070               1213      BEQ     EAAN        ; Address Register Direct
00001D3A                          1214      
00001D3A  BE3C 0002               1215      CMP.B   #2,D7       ; See if the mode == '010'
00001D3E  6700 0076               1216      BEQ     EAANI       ; Address Register Indirect
00001D42                          1217      
00001D42  BE3C 0003               1218      CMP.B   #3,D7       ; See if the mode == '011'
00001D46  6700 0084               1219      BEQ     EAAPOST     ; Address Register Indirect with Post increment
00001D4A                          1220      
00001D4A  BE3C 0004               1221      CMP.B   #4,D7       ; See if the mode == '100'
00001D4E  6700 0096               1222      BEQ     EAAPRE      ; Address Register Indirect with Pre increment
00001D52                          1223      
00001D52  BE3C 0007               1224      CMP.B   #7,D7       ; See if the mode == '111' 
00001D56  6700 00E6               1225      BEQ     EA111       ; Determine if (Immediate Data, Aboslute Word or Long Address)
00001D5A                          1226  
00001D5A  6000 02EE               1227      BRA     EAUNKN
00001D5E                          1228  
00001D5E                          1229  ; For this method, D6 is in the format of: <3 bits Dst Reg><3 bits Dst Mode> 
00001D5E                          1230  EAGETDSTEA  
00001D5E  1E06                    1231      MOVE.B  D6,D7       ; Store the right-most byte into D7
00001D60  CE3C 0007               1232      AND.B   #$07,D7     ; Isolate 3 rightmost bits as 'Mode'
00001D64  E68E                    1233      LSR.L   #3,D6       ; Shift D6 to the right 3 bits (D6 Byte = 'Reg')
00001D66  BE3C 0000               1234      CMP.B   #0,D7       ; See if the mode == '000'
00001D6A  6700 002E               1235      BEQ     EADN
00001D6E                          1236  
00001D6E  BE3C 0001               1237      CMP.B   #1,D7       ; See if the mode == '001'
00001D72  6700 0034               1238      BEQ     EAAN        ; Address Register Direct
00001D76                          1239      
00001D76  BE3C 0002               1240      CMP.B   #2,D7       ; See if the mode == '010'
00001D7A  6700 003A               1241      BEQ     EAANI       ; Address Register Indirect
00001D7E                          1242      
00001D7E  BE3C 0003               1243      CMP.B   #3,D7       ; See if the mode == '011'
00001D82  6700 0048               1244      BEQ     EAAPOST     ; Address Register Indirect with Post increment
00001D86                          1245      
00001D86  BE3C 0004               1246      CMP.B   #4,D7       ; See if the mode == '100'
00001D8A  6700 005A               1247      BEQ     EAAPRE      ; Address Register Indirect with Pre increment
00001D8E                          1248      
00001D8E  BE3C 0007               1249      CMP.B   #7,D7       ; See if the mode == '111' 
00001D92  6700 00AA               1250      BEQ     EA111       ; Determine if (Immediate Data, Aboslute Word or Long Address)
00001D96                          1251  
00001D96  6000 02B2               1252      BRA     EAUNKN
00001D9A                          1253           
00001D9A                          1254  ;If the EA is a Dn EA    
00001D9A                          1255  ;This method assume D6 contains the Reg for Dn  
00001D9A                          1256  EADN
00001D9A  12FC 0044               1257      MOVE.B  #'D',(A1)+
00001D9E  0606 0030               1258      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
00001DA2  12C6                    1259      MOVE.B  D6,(A1)+
00001DA4  5441                    1260      ADDQ    #2,D1
00001DA6  4E75                    1261      RTS
00001DA8                          1262  ;If the EA is a An EA    
00001DA8                          1263  ;This method assume D6 contains the Reg for An  
00001DA8                          1264  EAAN
00001DA8  12FC 0041               1265      MOVE.B  #'A',(A1)+
00001DAC  0606 0030               1266      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
00001DB0  12C6                    1267      MOVE.B  D6,(A1)+
00001DB2  5441                    1268      ADDQ    #2,D1
00001DB4  4E75                    1269      RTS
00001DB6                          1270  
00001DB6                          1271  ;If the EA is a (An) EA    
00001DB6                          1272  ;This method assume D6 contains the Reg for (An)  
00001DB6                          1273  EAANI
00001DB6  12FC 0028               1274      MOVE.B  #'(',(A1)+
00001DBA  12FC 0041               1275      MOVE.B  #'A',(A1)+
00001DBE  0606 0030               1276      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
00001DC2  12C6                    1277      MOVE.B  D6,(A1)+
00001DC4  12FC 0029               1278      MOVE.B  #')',(A1)+
00001DC8  5841                    1279      ADDQ    #4,D1
00001DCA  4E75                    1280      RTS
00001DCC                          1281  ;If the EA is a (An)+ EA    
00001DCC                          1282  ;This method assume D6 contains the Reg for (An)+  
00001DCC                          1283  EAAPOST
00001DCC  12FC 0028               1284      MOVE.B  #'(',(A1)+
00001DD0  12FC 0041               1285      MOVE.B  #'A',(A1)+
00001DD4  0606 0030               1286      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
00001DD8  12C6                    1287      MOVE.B  D6,(A1)+
00001DDA  12FC 0029               1288      MOVE.B  #')',(A1)+
00001DDE  12FC 002B               1289      MOVE.B  #'+',(A1)+
00001DE2  5A41                    1290      ADDQ    #5,D1
00001DE4  4E75                    1291      RTS
00001DE6                          1292  ;If the EA is a -(An) EA    
00001DE6                          1293  ;This method assume D6 contains the Reg for -(An) 
00001DE6                          1294  EAAPRE
00001DE6  12FC 002D               1295      MOVE.B  #'-',(A1)+
00001DEA  12FC 0028               1296      MOVE.B  #'(',(A1)+
00001DEE  12FC 0041               1297      MOVE.B  #'A',(A1)+
00001DF2  0606 0030               1298      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
00001DF6  12C6                    1299      MOVE.B  D6,(A1)+
00001DF8  12FC 0029               1300      MOVE.B  #')',(A1)+
00001DFC  5A41                    1301      ADDQ    #5,D1
00001DFE  4E75                    1302      RTS 
00001E00                          1303  ;If the EA is a #<data> EA    
00001E00                          1304  ;This method assume D6 contains the Reg for #<data>  
00001E00                          1305  EAID
00001E00  12FC 0020               1306      MOVE.B  #' ',(A1)+
00001E04  0606 0030               1307      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
00001E08  12C6                    1308      MOVE.B  D6,(A1)+
00001E0A  5441                    1309      ADDQ    #2,D1
00001E0C  4E75                    1310      RTS
00001E0E                          1311  ;If the EA is a (xxx).W EA    
00001E0E                          1312  ;This method assume D6 contains the Reg for (xxx).W  
00001E0E                          1313  EAAWA
00001E0E  12FC 0024               1314      MOVE.B  #'$',(A1)+
00001E12  5241                    1315      ADDQ    #1,D1
00001E14  3C1A                    1316      MOVE.W  (A2)+,D6   ; Push our next Word value into D6
00001E16                          1317      ; Push the ASCII equivlent characters of D6-- only the
00001E16                          1318      ;   first Word's worth (our entire Word we just acquired)
00001E16  4244                    1319      CLR     D4
00001E18  4EB9 00001E54           1320      JSR     EAHEXtoASCII
00001E1E                          1321      
00001E1E  4E75                    1322      RTS
00001E20                          1323  ;If the EA is a (xxx).L EA    
00001E20                          1324  ;This method assume D6 contains the Reg for (xxx).L  
00001E20                          1325  EAALA
00001E20  12FC 0024               1326      MOVE.B  #'$',(A1)+
00001E24  5241                    1327      ADDQ    #1,D1
00001E26  2C1A                    1328      MOVE.L  (A2)+,D6   ; Push our next Long value into D6
00001E28                          1329      ; Push the ASCII equivlent characters of D6-- only the
00001E28                          1330      ;   first Word's worth of our Long
00001E28  4244                    1331      CLR     D4         ; Clear our counter
00001E2A  4846                    1332      SWAP    D6         ; Flip the high-order Word with the Low-order
00001E2C  4EB9 00001E54           1333      JSR     EAHEXtoASCII
00001E32  4846                    1334      SWAP    D6         ; Flip the high-order Word with the Low-order
00001E34                          1335      ; Print the second half of the Long, too
00001E34  4244                    1336      CLR     D4
00001E36  4EB9 00001E54           1337      JSR     EAHEXtoASCII
00001E3C                          1338      
00001E3C  4E75                    1339      RTS
00001E3E                          1340  ;If the EA Mode = 111, Determine EA    
00001E3E                          1341  ;This method assume D6 contains the Reg for EA  
00001E3E                          1342  EA111
00001E3E  BC3C 0000               1343      CMP.B #0,D6
00001E42  67CA                    1344      BEQ     EAAWA       ; Absolute Word Address 
00001E44  BC3C 0001               1345      CMP.B #1,D6
00001E48  67D6                    1346      BEQ     EAALA       ; Absolute Long Address 
00001E4A  BC3C 0004               1347      CMP.B #4,D6
00001E4E  67B0                    1348      BEQ     EAID        ; Immediate Data 
00001E50                          1349      *-----------------------------------------------let fall through? it shouldn't RTS right?
00001E50  6000 01F8               1350      BRA     EAUNKN
00001E54                          1351      
00001E54                          1352  ; Uses D6 as a storage, D3 as a go-between, and D4 as a counter..
00001E54                          1353  ;  This operates on the low-order word of D2, and pushes exactly 4 
00001E54                          1354  ;  characters into IOStringLoc, converted from HEX of D2's nybble,
00001E54                          1355  ;  to ASCII in IOStringLoc
00001E54  5244                    1356  EAHEXtoASCII    ADDQ    #1,D4
00001E56  E95E                    1357                  ROL.W   #4,D6              Get the left-most nyblle to the front..
00001E58  1606                    1358                  MOVE.B  D6,D3              .. Put the front-most byte into D3    
00001E5A  C63C 000F               1359                  AND.B   #$0F,D3            Distill D3 down to the original left-most nybble
00001E5E  B63C 0009               1360                  CMP.B   #9,D3              See if our number is greater than 9..
00001E62  6F00 0004               1361                  BLE     EADIGIT            If it is 9 or less, it's a digit..
00001E66  5E03                    1362                  ADD.B   #7,D3              Otherwise it is a digit, and needs an additional 7
00001E68  0603 0030               1363  EADIGIT         ADD.B   #48,D3             We now have the nybble's ASCII code
00001E6C  12C3                    1364                  MOVE.B  D3,(A1)+           Move the ASCII code into the output string at A1
00001E6E  B83C 0004               1365                  CMP.B   #4,D4              See if we've read all the characters
00001E72  66E0                    1366                  BNE.S   EAHEXtoASCII       Continue if we haven't
00001E74                          1367                  
00001E74  5841                    1368                  ADDQ    #4,D1
00001E76  4E75                    1369                  RTS
00001E78                          1370      
00001E78                          1371  ; MOVEM's (A7)+,A0-A6,D0-D7 format
00001E78                          1372  ; Gets the follow-up WORD in order to process it
00001E78                          1373  EAMOVEMPOSTI
00001E78  3C1A                    1374      MOVE.W  (A2)+,D6    ; Get follow-up word for processing
00001E7A                          1375      
00001E7A  2E3C 000000FF           1376      MOVE.L  #$FF,D7     ; Initilize D7 to be our counter
00001E80                          1377      
00001E80  EE9E                    1378      ROR.L   #7,D6       ; Shift our new bits seven to the right
00001E82                          1379  IANSL    ; Increment An Start Loop  
00001E82  5247                    1380      ADDQ    #1,D7       ; Itterate D7
00001E84  E29E                    1381      ROR.L   #1,D6       ; Rotate one bit to the right  
00001E86  BE3C 0008               1382      CMP.B   #8,D7       ; Check if we've hit A8
00001E8A  6700 0056               1383      BEQ     INOA        ; If we have, break the loop
00001E8E  0806 0000               1384      BTST    #$00,D6     ; Check the far right bit
00001E92  67EE                    1385      BEQ     IANSL       ; If it isn't 1, continue checking
00001E94                          1386      
00001E94  12FC 0041               1387      MOVE.B  #'A',(A1)+
00001E98                          1388      
00001E98  0607 0030               1389      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
00001E9C  12C7                    1390      MOVE.B  D7,(A1)+
00001E9E  5441                    1391      ADDQ    #2,D1
00001EA0                          1392      
00001EA0  0407 002F               1393      SUB.B   #47,D7      ; Balance out out D7 from ASCII conversion
00001EA4  E29E                    1394      ROR.L   #1,D6       ; Rotate one bit to the right  
00001EA6  BE3C 0008               1395      CMP.B   #8,D7       ; Check if we've hit A8
00001EAA  6700 003A               1396      BEQ     INOEA       ; If we have, break the loop
00001EAE  0806 0000               1397      BTST    #$00,D6     ; Check the far right bit
00001EB2  6700 0032               1398      BEQ     INOEA       ; If it is 0, skip past -A
00001EB6                          1399  IANEL    ; Increment An End Loop  
00001EB6  5247                    1400      ADDQ    #1,D7       ; Itterate D7
00001EB8  E29E                    1401      ROR.L   #1,D6       ; Rotate one bit to the right  
00001EBA  BE3C 0008               1402      CMP.B   #8,D7       ; Check if we've hit A8
00001EBE  6700 0008               1403      BEQ     IANELE      ; If we have, break the loop
00001EC2  0806 0000               1404      BTST    #$00,D6     ; Check the far right bit
00001EC6  66EE                    1405      BNE     IANEL       ; If it isn't 0, continue checking    
00001EC8                          1406  IANELE
00001EC8  5347                    1407      SUBQ    #1,D7
00001ECA                          1408      
00001ECA  12FC 002D               1409      MOVE.B  #'-',(A1)+
00001ECE  12FC 0041               1410      MOVE.B  #'A',(A1)+
00001ED2                          1411      
00001ED2  0607 0030               1412      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
00001ED6  12C7                    1413      MOVE.B  D7,(A1)+
00001ED8  5641                    1414      ADDQ    #3,D1
00001EDA  0407 0030               1415      SUB.B   #48,D7      ; SUB 48 into D7 for ASCII conversion
00001EDE  6000 0006               1416      BRA     INOEA       ; Branch past the 'No An Skip Label'
00001EE2                          1417  
00001EE2                          1418  INOA     ; No An Skip label 
00001EE2  08C7 001F               1419      BSET.L  #$1F,D7     ; Set our MSB to equal 1
00001EE6                          1420   
00001EE6                          1421  INOEA    ; No An Ending (aka Single An) Skip Label
00001EE6  5207                    1422      ADD.B   #1,D7       ; Add 1 for 0ing balance
00001EE8  0887 0008               1423      BCLR    #$08,D7     ; Incase we're iterated base FF in A
00001EEC  EFBE                    1424      ROL.L   D7,D6       ; Rotate our A bits back into view
00001EEE  E19E                    1425      ROL.L   #8,D6       ; Rotate our D bits back into place
00001EF0  E39E                    1426      ROL.L   #1,D6       ; Rotate an extra bit over, to account for the loop
00001EF2  1E3C 00FF               1427      MOVE.B  #$FF,D7     ; Initilize D7
00001EF6                          1428  
00001EF6                          1429  IDNSL    ; Increment Dn Start Loop  
00001EF6  5247                    1430      ADDQ    #1,D7       ; Itterate D7
00001EF8  E29E                    1431      ROR.L   #1,D6       ; Rotate one bit to the right  
00001EFA  BE3C 0008               1432      CMP.B   #8,D7       ; Check if we've hit D8
00001EFE  6700 0060               1433      BEQ     ENDEAMOVEMPI ; If we have, break the loop
00001F02  0806 0000               1434      BTST    #$00,D6     ; Check the far right bit
00001F06  67EE                    1435      BEQ     IDNSL       ; If it isn't 1, continue checking     
00001F08                          1436      
00001F08                          1437      ; The issue with the below line:
00001F08                          1438      ;  We need to skip / if there are no An registers, as we do in INOA
00001F08                          1439      ;  We also need to skip / if there are no Dn registers, as we do here
00001F08                          1440      ;  However, we need to skip / if there are no An's, but we still need to run
00001F08                          1441      ;   the above code to determine the starting Dn, so we use the MSB of D7
00001F08                          1442      ;   as a boolean to determine if we had an An
00001F08  0807 001F               1443      BTST    #$1F,D7     ; If our MSB is equal to 1, we have no A
00001F0C  6600 0008               1444      BNE     INOA2       ; .. So, skip the /
00001F10  12FC 002F               1445      MOVE.B  #'/',(A1)+
00001F14  5241                    1446      ADDQ    #1,D1
00001F16                          1447  INOA2     ; 2nd No An Skip label 
00001F16  0887 001F               1448      BCLR    #$1F,D7     ; If our MSB is set, clear it
00001F1A  12FC 0044               1449      MOVE.B  #'D',(A1)+
00001F1E  0607 0030               1450      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
00001F22  12C7                    1451      MOVE.B  D7,(A1)+    
00001F24  5441                    1452      ADDQ    #2,D1
00001F26                          1453      
00001F26  0407 002F               1454      SUB.B   #47,D7      ; Balance out our D7 from ASCII conversion
00001F2A  E29E                    1455      ROR.L   #1,D6       ; Rotate one bit to the right  
00001F2C  BE3C 0008               1456      CMP.B   #8,D7       ; Check if we've hit A8
00001F30  6700 002E               1457      BEQ     ENDEAMOVEMPI  ; If we have, break to the end
00001F34  0806 0000               1458      BTST    #$00,D6     ; Check the far right bit
00001F38  6700 0026               1459      BEQ     ENDEAMOVEMPI ; If it is 0, we have no -Dn
00001F3C                          1460  IDNEL    ; Increment Dn End Loop  
00001F3C  5247                    1461      ADDQ    #1,D7       ; Itterate D7
00001F3E  E29E                    1462      ROR.L   #1,D6       ; Rotate one bit to the right  
00001F40  BE3C 0008               1463      CMP.B   #8,D7       ; Check if we've hit A8
00001F44  6700 0008               1464      BEQ     INENLE      ; If we have, break the loop
00001F48  0806 0000               1465      BTST    #$00,D6     ; Check the far right bit
00001F4C  66EE                    1466      BNE     IDNEL       ; If it isn't 0, continue checking    
00001F4E                          1467  INENLE
00001F4E  5347                    1468      SUBQ    #1,D7
00001F50                          1469      
00001F50  12FC 002D               1470      MOVE.B  #'-',(A1)+
00001F54  12FC 0044               1471      MOVE.B  #'D',(A1)+
00001F58                          1472  
00001F58  0607 0030               1473      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
00001F5C  12C7                    1474      MOVE.B  D7,(A1)+
00001F5E  5641                    1475      ADDQ    #3,D1 
00001F60                          1476      ; If no Dn, skip to the end
00001F60                          1477  ENDEAMOVEMPI
00001F60  4E75                    1478      RTS
00001F62                          1479      
00001F62                          1480  EAMOVEMPRED
00001F62  3C1A                    1481      MOVE.W  (A2)+,D6    ; Get follow-up word for processing
00001F64                          1482      
00001F64  2E3C 000000FF           1483      MOVE.L  #$FF,D7     ; Initilize D7 to be our counter
00001F6A                          1484      
00001F6A  E09E                    1485      ROR.L   #8,D6       ; Shift our new bits eight to the right
00001F6C                          1486  DANSL    ; Decrement An Start Loop  
00001F6C  5247                    1487      ADDQ    #1,D7       ; Itterate D7
00001F6E  E39E                    1488      ROL.L   #1,D6       ; Rotate one bit to the left  
00001F70  BE3C 0008               1489      CMP.B   #8,D7       ; Check if we've hit A8
00001F74  6700 0056               1490      BEQ     DNOA        ; If we have, break the loop
00001F78  0806 0000               1491      BTST    #$00,D6     ; Check the far right bit
00001F7C  67EE                    1492      BEQ     DANSL       ; If it isn't 1, continue checking
00001F7E                          1493      
00001F7E  12FC 0041               1494      MOVE.B  #'A',(A1)+
00001F82                          1495      
00001F82  0607 0030               1496      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
00001F86  12C7                    1497      MOVE.B  D7,(A1)+
00001F88  5441                    1498      ADDQ    #2,D1
00001F8A                          1499      
00001F8A  0407 002F               1500      SUB.B   #47,D7      ; Balance out out D7 from ASCII conversion
00001F8E  E39E                    1501      ROL.L   #1,D6       ; Rotate one bit to the left  
00001F90  BE3C 0008               1502      CMP.B   #8,D7       ; Check if we've hit A8
00001F94  6700 003A               1503      BEQ     DNOEA       ; If we have, break the loop
00001F98  0806 0000               1504      BTST    #$00,D6     ; Check the far right bit
00001F9C  6700 0032               1505      BEQ     DNOEA       ; If it is 0, skip past -A
00001FA0                          1506  DANEL    ; Decrement An End Loop  
00001FA0  5247                    1507      ADDQ    #1,D7       ; Itterate D7
00001FA2  E39E                    1508      ROL.L   #1,D6       ; Rotate one bit to the left  
00001FA4  BE3C 0008               1509      CMP.B   #8,D7       ; Check if we've hit A8
00001FA8  6700 0008               1510      BEQ     DANELE      ; If we have, break the loop
00001FAC  0806 0000               1511      BTST    #$00,D6     ; Check the far right bit
00001FB0  66EE                    1512      BNE     DANEL       ; If it isn't 0, continue checking    
00001FB2                          1513  DANELE
00001FB2  5347                    1514      SUBQ    #1,D7
00001FB4                          1515      
00001FB4  12FC 002D               1516      MOVE.B  #'-',(A1)+
00001FB8  12FC 0041               1517      MOVE.B  #'A',(A1)+
00001FBC                          1518      
00001FBC  0607 0030               1519      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
00001FC0  12C7                    1520      MOVE.B  D7,(A1)+
00001FC2  5641                    1521      ADDQ    #3,D1
00001FC4  0407 0030               1522      SUB.B   #48,D7      ; SUB 48 into D7 for ASCII conversion
00001FC8  6000 0006               1523      BRA     DNOEA       ; Branch past the 'No An Skip Label'
00001FCC                          1524  
00001FCC                          1525  DNOA     ; No An Skip label 
00001FCC  08C7 001F               1526      BSET.L  #$1F,D7     ; Set our MSB to equal 1
00001FD0                          1527   
00001FD0                          1528  DNOEA    ; No An Ending (aka Single An) Skip Label
00001FD0  5207                    1529      ADD.B   #1,D7       ; Add 1 for 0ing balance
00001FD2  0887 0008               1530      BCLR    #$08,D7     ; Incase we're iterated base FF in A
00001FD6  EEBE                    1531      ROR.L   D7,D6       ; Rotate our A bits back into view
00001FD8  E09E                    1532      ROR.L   #8,D6       ; Rotate our D bits back into place
00001FDA                          1533      ;ROR.L   #1,D6       ; Rotate an extra bit over, to account for the loop
00001FDA  1E3C 00FF               1534      MOVE.B  #$FF,D7     ; Initilize D7
00001FDE                          1535  
00001FDE                          1536  DDNSL    ; Decrement Dn Start Loop  
00001FDE  5247                    1537      ADDQ    #1,D7       ; Itterate D7
00001FE0  E39E                    1538      ROL.L   #1,D6       ; Rotate one bit to the right  
00001FE2  BE3C 0008               1539      CMP.B   #8,D7       ; Check if we've hit D8
00001FE6  6700 0060               1540      BEQ     ENDEAMOVEMPD ; If we have, break the loop
00001FEA  0806 0000               1541      BTST    #$00,D6     ; Check the far right bit
00001FEE  67EE                    1542      BEQ     DDNSL       ; If it isn't 1, continue checking     
00001FF0                          1543      
00001FF0                          1544      ; The issue with the below line:
00001FF0                          1545      ;  We need to skip / if there are no An registers, as we do in INOA
00001FF0                          1546      ;  We also need to skip / if there are no Dn registers, as we do here
00001FF0                          1547      ;  However, we need to skip / if there are no An's, but we still need to run
00001FF0                          1548      ;   the above code to determine the starting Dn, so we use the MSB of D7
00001FF0                          1549      ;   as a boolean to determine if we had an An
00001FF0  0807 001F               1550      BTST    #$1F,D7     ; If our MSB is equal to 1, we have no A
00001FF4  6600 0008               1551      BNE     DNOA2       ; .. So, skip the /
00001FF8  12FC 002F               1552      MOVE.B  #'/',(A1)+
00001FFC  5241                    1553      ADDQ    #1,D1
00001FFE                          1554  DNOA2     ; 2nd No An Skip label 
00001FFE  0887 001F               1555      BCLR    #$1F,D7     ; If our MSB is set, clear it
00002002  12FC 0044               1556      MOVE.B  #'D',(A1)+
00002006  0607 0030               1557      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
0000200A  12C7                    1558      MOVE.B  D7,(A1)+    
0000200C  5441                    1559      ADDQ    #2,D1
0000200E                          1560      
0000200E  0407 002F               1561      SUB.B   #47,D7      ; Balance out our D7 from ASCII conversion
00002012  E39E                    1562      ROL.L   #1,D6       ; Rotate one bit to the right  
00002014  BE3C 0008               1563      CMP.B   #8,D7       ; Check if we've hit A8
00002018  6700 002E               1564      BEQ     ENDEAMOVEMPD  ; If we have, break to the end
0000201C  0806 0000               1565      BTST    #$00,D6     ; Check the far right bit
00002020  6700 0026               1566      BEQ     ENDEAMOVEMPD ; If it is 0, we have no -Dn
00002024                          1567  DDNEL    ; Decrement Dn End Loop  
00002024  5247                    1568      ADDQ    #1,D7       ; Itterate D7
00002026  E39E                    1569      ROL.L   #1,D6       ; Rotate one bit to the right  
00002028  BE3C 0008               1570      CMP.B   #8,D7       ; Check if we've hit A8
0000202C  6700 0008               1571      BEQ     DNENLE      ; If we have, break the loop
00002030  0806 0000               1572      BTST    #$00,D6     ; Check the far right bit
00002034  66EE                    1573      BNE     DDNEL       ; If it isn't 0, continue checking    
00002036                          1574  DNENLE
00002036  5347                    1575      SUBQ    #1,D7
00002038                          1576      
00002038  12FC 002D               1577      MOVE.B  #'-',(A1)+
0000203C  12FC 0044               1578      MOVE.B  #'D',(A1)+
00002040                          1579  
00002040  0607 0030               1580      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
00002044  12C7                    1581      MOVE.B  D7,(A1)+
00002046  5641                    1582      ADDQ    #3,D1 
00002048                          1583      ; If no Dn, skip to the end
00002048                          1584  ENDEAMOVEMPD
00002048  4E75                    1585      RTS
0000204A                          1586  
0000204A                          1587  ; If the EA is unknown
0000204A                          1588  EAUNKN
0000204A  12FC 003C               1589      MOVE.B  #'<',(A1)+  ; We did this byte-by-byte in case A1 is at an odd register
0000204E  12FC 0045               1590      MOVE.B  #'E',(A1)+
00002052  12FC 0041               1591      MOVE.B  #'A',(A1)+
00002056  12FC 003E               1592      MOVE.B  #'>',(A1)+
0000205A  5841                    1593      ADDQ    #4,D1
0000205C  4E75                    1594      RTS
0000205E                          1595  
0000205E                          1596  
0000205E                          1597  
0000205E                          1598  
0000205E                          1599  
0000205E                          1600  
0000205E                          1601  
0000205E                          1602  -------------------- end include --------------------
0000205E                          1603      
0000205E  FFFF FFFF               1604      SIMHALT             ; halt simulator
00002062                          1605  
00002062                          1606  * Put variables and constants here
00002062                          1607  
00002062                          1608      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AASD                1C9E
AASLSRO             1C7A
AASLSRODL           1CD2
AASLSRODR           1CBC
AASLSROOP           1CD8
ADDADDA             1A7E
ADDAL               1B48
ADDAN               1B5A
ADDAW               1B36
ADDBDN              1AEE
ADDBEA              1B24
ADDI                1472
ADDI8               1486
ADDIB               14D6
ADDIL               14F6
ADDIOP              1506
ADDIW               14E6
ADDLDN              1ACA
ADDLEA              1B00
ADDWDN              1ADC
ADDWEA              1B12
ALSD                1CA8
AND                 1980
ANDBDN              1A3E
ANDBEA              19D4
ANDDN               1A50
ANDEA               19E4
ANDLDN              1A1A
ANDLEA              19B4
ANDWDN              1A2C
ANDWEA              19C4
AROD                1CB2
ASD                 1BBE
ASLSRO              1B8A
ASLSROB             1C1E
ASLSRODL            1BF6
ASLSRODR            1BDC
ASLSROIR            1C2A
ASLSROIRDN          1C4C
ASLSROOP            1C52
ASLSROSIZE          1C00
ASLSROW             1C26
BAD_EVEN            10D2
BAD_LENGTH          1094
BCC                 176C
CHECK31             1052
CLEARMEMORY         107C
CLR                 15C4
CLRB                15F0
CLRL                161C
CLROP               1632
CLRW                1606
CMP                 1894
CMPB                18BA
CMPL                18E6
CMPOP               18FC
CMPW                18D0
CNRJML              157C
COUNTER             13F6
CR                  D
DANEL               1FA0
DANELE              1FB2
DANSL               1F6C
DDNEL               2024
DDNSL               1FDE
DIVU                17B0
DNENLE              2036
DNOA                1FCC
DNOA2               1FFE
DNOEA               1FD0
EA111               1E3E
EAALA               1E20
EAAN                1DA8
EAANI               1DB6
EAAPOST             1DCC
EAAPRE              1DE6
EAAWA               1E0E
EADIGIT             1E68
EADN                1D9A
EAGETDSTEA          1D5E
EAGETSRCEA          1D1E
EAHEXTOASCII        1E54
EAID                1E00
EAMOVEMPOSTI        1E78
EAMOVEMPRED         1F62
EAUNKN              204A
ENDEAMOVEMPD        2048
ENDEAMOVEMPI        1F60
ENDINGADDRESS       13F2
ENDLOOP             1118
ENTERCHECK          105E
ENTERPROMPT         1360
FAIL_INPUT          131A
HEXEND              129D
HEXSTART            1247
IANEL               1EB6
IANELE              1EC8
IANSL               1E82
IDNEL               1F3C
IDNSL               1EF6
INENLE              1F4E
INOA                1EE2
INOA2               1F16
INOEA               1EE6
INTROMSG            122A
IOASCIITOHEX        10E8
IOASCIITOHEX2       114C
IODIGIT             1206
IODONE              1214
IOHEXTOASCII        11F2
IOINTRO             100C
IOLOOP              101A
IOORTAG             10FA
IOORTAG2            115E
IOSTRINGLOC         100
JSR                 1684
LEA                 172A
LENGTH_CHECK        107C
LF                  A
LSD                 1BC8
MOVEB               151E
MOVEL               153E
MOVEM               16AE
MOVEML              16D4
MOVEMOP             16DA
MOVEMPOSTI          170E
MOVEMPRED           16F2
MOVEMW              16CA
MOVEOP              154E
MOVEQ               176E
MOVEW               152E
MULS                1944
MULSAND             1932
NOP                 1650
OPGETCODE           13FA
OUTPUTOPCODE        1190
OUTRO               1310
RES                 12F2
ROD                 1BD2
RTS                 166A
SPC                 1300
START               1000
STARTADDRESS        13EE
STARTGTEND          13A4
STARTLESSTHNEND     10A6
SUB                 17EC
SUBBDN              1882
SUBBEA              184C
SUBLDN              185E
SUBLEA              1828
SUBWDN              1870
SUBWEA              183A
TEST_ODD            10B8
UNKEA               1306
UNKNOWN             1CFA
