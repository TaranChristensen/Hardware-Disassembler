00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 3/13/2016 10:06:53 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Master
00000000                             3  * Written by : Circles
00000000                             4  * Date       : ##/##/16
00000000                             5  * Description: Project Master File
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11      INCLUDE "IO.X68"        ; Handles our input and output, as well as which address to refer to
00001000  47F9 000017BE             12                  LEA     COUNTER,A3         initialize the COUNTER variable
00001006  26BC 00000000             13                  MOVE.L  #0,(A3)            clear the variable
0000100C                            14                  
0000100C                            15  
0000100C  0693 00000016             16  IOINTRO         ADD.L   #$00000016,(A3)    COUNTER++
00001012  43F9 00001264             17                  LEA     IntroMsg,A1        Display the intro
00001018  103C 000E                 18                  MOVE.B  #14, D0
0000101C  4E4F                      19                  TRAP    #15
0000101E                            20                  
0000101E  43F9 00001461             21                  LEA     Intro2,A1        Display the intro
00001024  103C 000E                 22                  MOVE.B  #14, D0
00001028  4E4F                      23                  TRAP    #15
0000102A                            24  
0000102A  43F9 00001632             25  IOLOOP          LEA     HexStart,A1        Display the prompt and loop it
00001030  103C 000E                 26                  MOVE.B  #14,D0          
00001034  4E4F                      27                  TRAP    #15   
00001036  5493                      28                  ADD.L   #$00000002,(A3)    COUNTER++ COUNTER++
00001038                            29  
00001038                            30  
00001038  43F9 00000100             31                  LEA     IOStringLoc,A1     Store the string of our user input at StartAddress,A1 
0000103E  103C 0002                 32                  MOVE.B  #2,D0              uses Trap #15, Task 2
00001042  4E4F                      33                  TRAP    #15              
00001044                            34          
00001044  4284                      35                  CLR.L   D4                 Ensure our counter (D4) is 0 
00001046                            36  
00001046  4EB9 00001088             37                  JSR     LENGTH_CHECK 
0000104C  4282                      38                  CLR.L   D2  
0000104E  BA3C 0001                 39                  CMP.B   #1,D5              if 1 then it passed the tests         
00001052                            40                  
00001052  6700 00A0                 41                  BEQ     IOASCIItoHEX
00001056  60D2                      42                  BRA     IOLOOP
00001058                            43                  
00001058  0C93 0000001F             44  CHECK31         CMP.L   #$0000001F,(A3)    compare the counter to 29
0000105E  6E00 0004                 45                  BGT     ENTERCHECK         counter is at at least 30
00001062  4E75                      46                  RTS                        counter is still low
00001064                            47  
00001064  4280                      48  ENTERCHECK      CLR.L   D0
00001066  43F9 000016F3             49                  LEA     ENTERPROMPT,A1     display the enter prompt
0000106C  103C 000E                 50                  MOVE.B  #14,D0
00001070  4E4F                      51                  TRAP    #15
00001072                            52                  
00001072  227C 00002000             53                  MOVE.L  #$2000,A1  
00001078                            54  
00001078  103C 0002                 55                  MOVE.B  #2,D0              wait for the user to hit enter
0000107C  4E4F                      56                  TRAP    #15
0000107E                            57                  
0000107E  26BC 00000000             58                  MOVE.L  #0,(A3)            clear the counter
00001084  5293                      59                  ADD.L   #$00000001,(A3)    COUNTER++
00001086                            60               
00001086  4E75                      61                  RTS
00001088                            62                  
00001088  4285                      63  LENGTH_CHECK    CLR.L   D5                 store the result of the test
0000108A  7C00                      64                  MOVEQ   #$0,D6             make D6 0
0000108C  B206                      65                  CMP.B   D6,D1              see if null
0000108E  6700 0010                 66                  BEQ     BAD_LENGTH         if null then branch to bad input
00001092  0C41 0008                 67                  CMPI    #$8,D1             see if it is more than 8 characters long
00001096  6E00 0008                 68                  BGT     BAD_LENGTH         if more than 8 branch to bad input
0000109A  1A3C 0001                 69                  MOVE.B  #$1,D5             passed the length checks so move 1
0000109E  4E75                      70                  RTS                        go back
000010A0                            71                  
000010A0  7A00                      72  BAD_LENGTH      MOVEQ   #$0,D5             did not pass the test
000010A2  43F9 000016AD             73                  LEA     FAIL_INPUT,A1      load bad input message
000010A8  103C 000E                 74                  MOVE.B  #14,D0          
000010AC  4E4F                      75                  TRAP    #15 
000010AE  5293                      76                  ADD.L   #$00000001,(A3)    COUNTER++
000010B0  4E75                      77                  RTS                        go back
000010B2                            78                  
000010B2  43F9 00001735             79  STARTLESSTHNEND LEA     STARTGTEND,A1      load the error 
000010B8  103C 000E                 80                  MOVE.B  #14,D0
000010BC  4E4F                      81                  TRAP    #15
000010BE  5293                      82                  ADD.L   #$00000001,(A3)    COUNTER++
000010C0  6000 FF68                 83                  BRA     IOLOOP             go back to the start
000010C4                            84  
000010C4                            85  
000010C4  4286                      86  TEST_ODD        CLR.L   D6           
000010C6  4285                      87                  CLR.L   D5
000010C8  7A02                      88                  MOVE.L  #$00000002,D5      divide by 2 to see remainder
000010CA  3C02                      89                  MOVE.W  D2,D6              create a copy of the input in D6
000010CC  8CC5                      90                  DIVU    D5,D6              divide the hex number by 2
000010CE                            91                  
000010CE  4846                      92                  SWAP    D6                 put the remainder on the far right
000010D0                            93                  
000010D0  BC3C 0001                 94                  CMP.B   #1,D6              see if the remainder is one
000010D4  6700 0008                 95                  BEQ     BAD_EVEN           branch to bad even
000010D8                            96              
000010D8  4286                      97                  CLR.L   D6
000010DA  4285                      98                  CLR.L   D5
000010DC                            99   
000010DC  4E75                     100                  RTS       
000010DE                           101                  
000010DE  4285                     102  BAD_EVEN        CLR.L   D5
000010E0  4286                     103                  CLR.L   D6
000010E2  43F9 000016AD            104                  LEA     FAIL_INPUT,A1      load bad input message  
000010E8  103C 000E                105                  MOVE.B  #14,D0          
000010EC  4E4F                     106                  TRAP    #15 
000010EE  5293                     107                  ADD.L   #$00000001,(A3)    COUNTER++
000010F0  6000 FF38                108                  BRA     IOLOOP             go back to the beginning
000010F4                           109                  
000010F4                           110  
000010F4  5244                     111  IOASCIItoHEX    ADDQ    #1,D4
000010F6  E98A                     112                  LSL.L   #4,D2              Scoot D2 a nybble
000010F8  1619                     113                  MOVE.B  (A1)+,D3           Move a Byte from A1's address to D3
000010FA  0403 0030                114                  SUB.B   #48,D3             Sub 48 to turn ASCII 0 into binary 0
000010FE  B63C 0009                115                  CMP.B   #9,D3              If our number is greater than 9..
00001102  6F02                     116                  BLE.S   IOORTAG            .. it must be a character; A-F: 
00001104  5F03                     117                  SUB.B   #7,D3              Sub 7 to turn A into 10
00001106  8403                     118  IOORTAG         OR.B    D3,D2              Store our nybble into D2
00001108  B204                     119                  CMP.B   D4,D1              See if we've read all the characters
0000110A  66E8                     120                  BNE.S   IOASCIItoHEX       Continue if we haven't
0000110C                           121              
0000110C                           122              
0000110C  23FC 00000000 000017B6   123                  MOVE.L  #0,StartAddress
00001116  23C2 000017B6            124                  MOVE.L  D2,StartAddress    Store our StartAddress
0000111C                           125                  
0000111C  4EB8 10C4                126                  JSR     TEST_ODD           test if the address is odd
00001120                           127                  
00001120  4281                     128                  CLR.L   D1
00001122  4282                     129                  CLR.L   D2
00001124                           130  
00001124                           131  
00001124  43F9 0000164F            132  ENDLOOP         LEA     HexEnd,A1          load the ending address prompt
0000112A  103C 000E                133                  MOVE.B  #14,D0
0000112E  4E4F                     134                  TRAP    #15  
00001130  5493                     135                  ADD.L   #$00000002,(A3)
00001132                           136                  
00001132  43F9 00000100            137                  LEA     IOStringLoc,A1     Store the string of our user input at StartAddress,A1 
00001138  103C 0002                138                  MOVE.B  #2,D0              uses Trap #15, Task 2
0000113C  4E4F                     139                  TRAP    #15              
0000113E                           140          
0000113E  4284                     141                  CLR.L   D4                 Ensure our counter (D4) is 0 
00001140                           142  
00001140  4EB8 1088                143                  JSR     LENGTH_CHECK       check to make sure the length is ok
00001144  BA3C 0001                144                  CMP.B   #1,D5              if 1 then it passed the tests         
00001148                           145  
00001148  6700 0004                146                  BEQ     IOASCIItoHEX2      convert to hex
0000114C  60D6                     147                  BRA     ENDLOOP
0000114E                           148                  
0000114E  5244                     149  IOASCIItoHEX2   ADDQ    #1,D4
00001150  E98A                     150                  LSL.L   #4,D2              Scoot D2 a nybble
00001152  1619                     151                  MOVE.B  (A1)+,D3           Move a Byte from A1's address to D3
00001154  0403 0030                152                  SUB.B   #48,D3             Sub 48 to turn ASCII 0 into binary 0
00001158  B63C 0009                153                  CMP.B   #9,D3              If our number is greater than 9..
0000115C  6F02                     154                  BLE.S   IOORTAG2           .. it must be a character; A-F: 
0000115E  5F03                     155                  SUB.B   #7,D3              Sub 7 to turn A into 10
00001160  8403                     156  IOORTAG2        OR.B    D3,D2              Store our nybble into D2
00001162  B204                     157                  CMP.B   D4,D1              See if we've read all the characters
00001164  66E8                     158                  BNE.S   IOASCIItoHEX2      Continue if we haven't
00001166                           159              
00001166                           160    
00001166  23FC 00000000 000017BA   161                  MOVE.L  #0,EndingAddress
00001170  23C2 000017BA            162                  MOVE.L  D2,EndingAddress   Store our EndingAddress
00001176                           163                  
00001176  4EB8 10C4                164                  JSR     TEST_ODD           tezt if the ending address is odd
0000117A                           165                  
0000117A  2479 000017B6            166                  MOVE.L  StartAddress,A2    Push our start address into A2
00001180                           167                  
00001180  B5F9 000017BA            168                  CMP.L   EndingAddress,A2   compare the ending address with the startingaddress
00001186  6E00 FF2A                169                  BGT     STARTLESSTHNEND    branch if the starting is greater than the ending
0000118A                           170                  
0000118A  4281                     171                  CLR.L   D1
0000118C                           172                  
0000118C  2479 000017B6            173                  MOVE.L  StartAddress,A2    Push our start address into A2 
00001192                           174                  
00001192                           175  
00001192  23FC 00000000 00000100   176  OUTPUTOPCODE    MOVE.L  #0,IOStringLoc     ********** Testing purposes ********** 
0000119C  4281                     177                  CLR.L   D1
0000119E                           178          
0000119E                           179  
0000119E  43F9 00000100            180                  LEA     IOStringLoc,A1     Load our IOStringLoc into A1 for string contruction purposes
000011A4                           181          
000011A4  2C0A                     182                  MOVE.L  A2,D6
000011A6  4244                     183                  CLR     D4
000011A8  4846                     184                  SWAP    D6
000011AA  4EB9 00002668            185                  JSR     EAHEXtoASCII
000011B0  4244                     186                  CLR     D4
000011B2  4846                     187                  SWAP    D6
000011B4  4EB9 00002668            188                  JSR     EAHEXtoASCII
000011BA  22FC 20202020            189                  MOVE.L  #'    ',(A1)+      Add a spacer into our IOStringLoc
000011C0  32FC 2020                190                  MOVE.W  #'  ',(A1)+      Add a spacer into our IOStringLoc
000011C4  5C41                     191                  ADDQ    #6,D1              We added 4 bytes, aka 4 spaces
000011C6                           192          
000011C6  4EB9 000017C2            193                  JSR OPGETCODE              Get the OpCode pointed at by A2, it's string stored in IOStringLoc
000011CC                           194                  
000011CC  43F9 00000100            195                  LEA     IOStringLoc,A1     Now that we've populated the string, load it's beginning
000011D2  103C 0001                196                  MOVE.B  #1,D0              Trap task 1 prints a string at A1 with #D1 bytes.
000011D6  4E4F                     197                  TRAP    #15           
000011D8                           198          
000011D8  43F9 0000166B            199                  LEA     SPC,A1             Puts the space before the opCode
000011DE  103C 000D                200                  MOVE.B  #13,D0
000011E2  4E4F                     201                  TRAP    #15
000011E4                           202                  
000011E4  5293                     203                  ADD.L   #$00000001,(A3)    COUNTER++
000011E6  4EB8 1058                204                  JSR     CHECK31
000011EA                           205                  
000011EA  B5F9 000017BA            206                  CMP.L   EndingAddress,A2   compare the current address with the ending address
000011F0  6DA0                     207                  BLT     OUTPUTOPCODE       if the current is less than the ending keep looping
000011F2                           208  
000011F2                           209  
000011F2                           210                  ; The following outputs the input, converting what we've saved in HEX to ASCII
000011F2                           211                  ; We won't need this in the final version, but the below code should be handy
000011F2                           212                  ;  for print out EA values
000011F2  2439 000017B6            213                  MOVE.L  StartAddress,D2    Ensure our address is actually at D2
000011F8  7208                     214                  MOVEQ   #8,D1              There are 8 characters in the hex of our address
000011FA  4284                     215                  CLR.L   D4                 Ensure our counter (D4) is 0
000011FC  43F9 00000100            216                  LEA     IOStringLoc,A1     Load our IO String location, to store our output at  
00001202                           217  
00001202                           218          
00001202  5244                     219  IOHEXtoASCII    ADDQ    #1,D4
00001204  E99A                     220                  ROL.L   #4,D2              Get the left-most nyblle to the front..
00001206  1602                     221                  MOVE.B  D2,D3              .. Put the front-most byte into D3    
00001208  C63C 000F                222                  AND.B   #$0F,D3            Distill D3 down to the original left-most nybble
0000120C  B63C 0009                223                  CMP.B   #9,D3              See if our number is greater than 9..
00001210  6F00 0004                224                  BLE     IODIGIT            If it is 9 or less, it's a digit..
00001214  5E03                     225                  ADD.B   #7,D3              Otherwise it is a digit, and needs an additional 7
00001216  0603 0030                226  IODIGIT         ADD.B   #48,D3             We now how the nybble's ASCII code
0000121A  12C3                     227                  MOVE.B  D3,(A1)+           Move the ASCII code into the output string at A1
0000121C  B204                     228                  CMP.B   D4,D1              See if we've read all the characters
0000121E  66E2                     229                  BNE.S   IOHEXtoASCII       Continue if we haven't
00001220                           230  
00001220  43F9 0000177F            231                  LEA     CONTINUE,A1        ask if the user wnats to exit
00001226  103C 000E                232                  MOVE.B  #14,D0
0000122A  4E4F                     233                  TRAP    #15
0000122C                           234                  
0000122C  123C 0000                235                  MOVE.B  #0,D1              clear D1
00001230  103C 0005                236                  MOVE.B  #5,D0              keybaord echo trap task
00001234  4E4F                     237                  TRAP    #15
00001236                           238                  
00001236  43F9 000017B2            239                  LEA     SPACER,A1          println
0000123C  103C 000E                240                  MOVE.B  #14,D0
00001240  4E4F                     241                  TRAP    #15
00001242                           242                  
00001242  B23C 0071                243                  CMP.B   #$71,D1            compare with lowercase q
00001246  6700 0006                244                  BEQ     IODONE             if equal then go to the end
0000124A                           245  
0000124A  6000 FDDE                246                  BRA     IOLOOP             not equal so go to the beginning
0000124E                           247          
0000124E                           248        
0000124E  43F9 0000167B            249  IODONE          LEA     OUTRO,A1           Display the ending message 
00001254  103C 000E                250                  MOVE.B  #14,D0
00001258  4E4F                     251                  TRAP    #15
0000125A  103C 0009                252                  MOVE.B  #9,D0
0000125E  4E4F                     253                  TRAP    #15                Halt Simulator
00001260                           254          
00001260  FFFF FFFF                255                  SIMHALT
00001264                           256          
00001264  =0000000D                257  CR              EQU     $0D         
00001264  =0000000A                258  LF              EQU     $0A 
00001264  =00000100                259  IOStringLoc     EQU     $0100              This is where we will store the string of the user input, and other strings
00001264                           260  
00001264                           261  
00001264= 20 20 20 20 20 20 ...    262  IntroMsg        DC.B '                              -----------',CR,LF
0000128F= 20 20 20 20 20 20 ...    263                  DC.B '                            /             \',CR,LF
000012BC= 20 20 20 20 20 20 ...    264                  DC.B '                           /     TEAM      \',CR,LF
000012EA= 20 20 20 20 20 20 ...    265                  DC.B '                          /                 \',CR,LF
00001319= 20 20 20 20 20 20 ...    266                  DC.B '                         |                   |',CR,LF
00001349= 20 20 20 20 20 20 ...    267                  DC.B '                         |      CIRCLES      |',CR,LF
00001379= 20 20 20 20 20 20 ...    268                  DC.B '                         |                   |',CR,LF
000013A9= 20 20 20 20 20 20 ...    269                  DC.B '                          \                 /',CR,LF
000013D8= 20 20 20 20 20 20 ...    270                  DC.B '                           \ DISSASSEMBLER /',CR,LF
00001406= 20 20 20 20 20 20 ...    271                  DC.B '                            \             /',CR,LF
00001433= 20 20 20 20 20 20 ...    272                  DC.B '                              -----------',CR,LF,CR,LF,0
00001461                           273                  
00001461= 54 68 69 73 20 70 ...    274  Intro2          DC.B    'This program will dissassemble machine code into readable code',CR,LF
000014A1= 49 74 20 77 69 6C ...    275                  DC.B    'It will ask for a starting and ending address',CR,LF
000014D0= 50 6C 65 61 73 65 ...    276                  DC.B    'Please type both in hex, with a length of 8 or less',CR,LF
00001505= 41 6E 64 20 6E 6F ...    277                  DC.B    'And not ending in an odd number',CR,LF
00001526= 49 66 20 61 6E 20 ...    278                  DC.B    'If an address is input that does not meet the criteria',CR,LF
0000155E= 54 68 65 20 70 72 ...    279                  DC.B    'The program will start over at the starting address prompt',CR,LF
0000159A= 57 68 65 6E 20 74 ...    280                  DC.B    'When the program has reached the ending address',CR,LF
000015CB= 49 74 20 77 69 6C ...    281                  DC.B    'It will ask if you want to try again with different addresses',CR,LF
0000160A= 57 68 65 6E 20 74 ...    282                  DC.B    'When this happens press "q" to exit.',CR,LF,CR,0
00001632                           283                  
00001632= 0D 0A 45 6E 74 65 ...    284  HexStart        DC.B    CR,LF,'Enter a starting address: ',0 Prompt for the user
0000164F= 0D 0A 45 6E 74 65 ...    285  HexEnd          DC.B    CR,LF,'Enter an ending address: ',0 Prompt for the user
0000166B= 20 20 20 20 20 00        286  SPC             DC.B    '     ',0                                tab
00001671= 3C 45 41 3E 2C 3C ...    287  UnkEA           DC.B    '<EA>,<EA>',0                            Interim message for unkown EAs.
0000167B= 0D 0A 54 68 61 6E ...    288  OUTRO           DC.B    CR,LF,'Thank you for using Team Circles Dissassembler!',0                            Outro message
000016AD= 49 20 61 6D 20 73 ...    289  FAIL_INPUT      DC.B    'I am sorry, but you typed an address that did not meet the criteria',CR,LF,0 
000016F3= 54 68 65 20 73 63 ...    290  ENTERPROMPT     DC.B    'The screen limit has been reached, please press enter to continue',0
00001735= 54 68 65 20 65 6E ...    291  STARTGTEND      DC.B    'The ending address was less than the starting address, please try again',CR,LF,0
0000177F= 0D 0A 50 72 65 73 ...    292  CONTINUE        DC.B    CR,LF,'Press "q" to quit or anything else to continue: ',0 ask to exit
000017B2= 0D 0A 00                 293  SPACER          DC.B    CR,LF,0 put the new line after the keyboard input
000017B5                           294  
000017B5                           295  
000017B6                           296  StartAddress    DS.L    1
000017BA                           297  EndingAddress   DS.L    1
000017BE                           298  COUNTER         DS.L    1 keep track of the lines on the screen
000017C2                           299  
000017C2                           300  
000017C2                           301  
000017C2                           302  
000017C2                           303  
000017C2                           304  
000017C2                           305  
000017C2                           306  
000017C2                           307  
000017C2                           308  
000017C2                           309  
000017C2                           310  
000017C2                           311  
000017C2                           312  
000017C2                           313  
000017C2                           314  
000017C2                           315  
000017C2                           316  
000017C2                           317  
000017C2                           318  
000017C2                           319  
000017C2                           320  
000017C2                           321  
000017C2                           322  
000017C2                           323  -------------------- end include --------------------
000017C2                           324      INCLUDE "OpCode.X68"    ; Handles determining OpCodes
000017C2                           325  
000017C2                           326  
000017C2                           327  ; Here we assume that A2 contains the address pointing to our OpCode, and
000017C2                           328  ;  we assume that A1 contains the address pointing to our IOStringLoc
000017C2  3A1A                     329  OPGETCODE   MOVE.W  (A2)+,D5    ; Push our OpCode into D5
000017C4  2C05                     330              MOVE.L  D5,D6       ; Also store the OpCode in D6
000017C6  E09E                     331              ROR.L   #8,D6       ; Rotate our OpCode to right-most nybble
000017C8  E89E                     332              ROR.L   #4,D6       ; 
000017CA  0206 000F                333              ANDI.B  #$0F,D6     ; Isolate our opcode nybble
000017CE  BC3C 0000                334              CMP.B   #$00,D6
000017D2  6700 0066                335              BEQ     ADDI        ; ADDI 
000017D6  BC3C 0001                336              CMP.B   #$01,D6     
000017DA  6700 0194                337              BEQ     MOVE        ; MOVE.B
000017DE  BC3C 0003                338              CMP.B   #$03,D6     
000017E2  6700 018C                339              BEQ     MOVE        ; MOVE.W
000017E6  BC3C 0002                340              CMP.B   #$02,D6
000017EA  6700 0184                341              BEQ     MOVE        ; MOVE.L
000017EE  BC3C 0004                342              CMP.B   #$04,D6
000017F2  6700 0232                343              BEQ     CNRJML      ; CLR or NOP or RTS or JSR or MOVEM or LEA
000017F6  BC3C 0006                344              CMP.B   #$06,D6
000017FA  6700 0522                345              BEQ     Bcc         ; Bcc (BCC, BGT, BLE) 
000017FE  BC3C 0007                346              CMP.B   #$07,D6
00001802  6700 0626                347              BEQ     MOVEQ       ; MOVEQ 
00001806  BC3C 0008                348              CMP.B   #$08,D6
0000180A  6700 0670                349              BEQ     DIVU        ; DIVU
0000180E  BC3C 0009                350              CMP.B   #$09,D6
00001812  6700 06BA                351              BEQ     SUB         ; SUB
00001816  BC3C 000B                352              CMP.B   #$0B,D6
0000181A  6700 0798                353              BEQ     CMP         ; CMP 
0000181E  BC3C 000C                354              CMP.B   #$0C,D6
00001822  6700 0834                355              BEQ     MULSAND     ; MULS or AND opcodes
00001826  BC3C 000D                356              CMP.B   #$0D,D6
0000182A  6700 09C8                357              BEQ     ADDADDA     ; ADD or ADDA
0000182E  BC3C 000E                358              CMP.B   #$0E,D6 
00001832  6700 0B14                359              BEQ     ASLSRO      ; ASd (ASR) or LSd (LSL) or ROd (ROL)
00001836  6000 0CB2                360              BRA     UNKNOWN  
0000183A                           361              
0000183A                           362  ;  Here we assume the first left-most 4 bits have been confirmed: 0000
0000183A  2C05                     363  ADDI        MOVE.L  D5,D6               ; Push D5 into D6
0000183C  E09E                     364              ROR.L   #8,D6               ; Rotate left-most middle nybble to the right-most nybble
0000183E  0206 000F                365              ANDI.B  #$0F,D6             ; Isolate opcode nybble
00001842  BC3C 0006                366              CMP.B   #$06,D6             ; If it matches ADDI's left-most middle nybble, branch
00001846  6700 0006                367              BEQ     ADDI8               ; First 8 left-most bits of ADDI confirmed 
0000184A  6000 0C9E                368              BRA     UNKNOWN             ; else unknown                       
0000184E                           369  
0000184E                           370  ;  Here we assume the first left-most 8 bits have been confirmed: 0000 0110            
0000184E                           371  ADDI8                                  ; Two consecutive tests for illegal Src EA Modes
0000184E  2C05                     372              MOVE.L  D5,D6              ; Push D5 into D6 
00001850  0286 0000003F            373              ANDI.L  #$003F,D6          ; Isolate the Src EA bits
00001856  BCBC 0000003C            374              CMP.L   #$003C,D6          ; Compare with illegal EA mode #<data>
0000185C  6700 0C8C                375              BEQ     UNKNOWN
00001860                           376              
00001860  E69E                     377              ROR.L   #3,D6              ; Roll 3 bits right
00001862  0286 00000007            378              ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
00001868  BCBC 00000001            379              CMP.L   #$0001, D6         ; Compare with illegal mode An
0000186E  6700 0C7A                380              BEQ     UNKNOWN
00001872                           381              *--------------
00001872                           382                                  
00001872  2C05                     383              MOVE.L  D5,D6              ; Push D5 into D6 
00001874  EC8E                     384              LSR.L   #6,D6              ; Shift six bits to the right
00001876  0286 00000003            385              ANDI.L  #$0003,D6          ; Isolate the size bits
0000187C                           386                         
0000187C  BCBC 00000000            387              CMP.L   #$0000,D6          ; See if the size is '00'..
00001882  6700 001A                388              BEQ     ADDIB              ; ..If so, it's ANDI.B
00001886  BCBC 00000001            389              CMP.L   #$0001,D6          ; See if the size is '01'..
0000188C  6700 0054                390              BEQ     ADDIW              ; ..If so, it's ANDI.W
00001890  BCBC 00000002            391              CMP.L   #$0002,D6          ; See if the size is '10'..
00001896  6700 008A                392              BEQ     ADDIL              ; ..If so, it's ANDI.L
0000189A                           393              
0000189A  6000 0C4E                394              BRA     UNKNOWN            ; If it isn't any, then it's Unknown
0000189E                           395  
0000189E  22FC 41444449            396  ADDIB       MOVE.L  #'ADDI',(A1)+
000018A4  32FC 2E42                397              MOVE.W  #'.B',(A1)+
000018A8  22FC 20202020            398              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
000018AE  5041                     399              ADDQ    #8,D1              ; We added 10 bytes, aka 4 spaces 6 characters
000018B0  5441                     400              ADDQ    #2,D1
000018B2                           401              
000018B2  32FC 2324                402              MOVE.W  #'#$',(A1)+
000018B6  5441                     403              ADDQ    #2,D1
000018B8                           404              
000018B8  4246                     405              CLR     D6
000018BA  4244                     406              CLR     D4
000018BC  3C1A                     407              MOVE.W  (A2)+,D6
000018BE  0246 00FF                408              ANDI.W  #$FF,D6
000018C2  4EB9 00002668            409              JSR     EAHEXtoASCII
000018C8                           410                          
000018C8  12FC 002C                411              MOVE.B #',',(A1)+      ; Add a spacer into our IOStringLoc
000018CC  5241                     412              ADDQ    #1,D1              ; We added 4 bytes, aka 4 spaces
000018CE                           413              
000018CE  2C05                     414              MOVE.L  D5,D6              ; Push D5 into D6
000018D0  0286 0000003F            415              ANDI.L  #$003F,D6          ; Isolate the Dst EA bits 
000018D6  103C 0001                416              MOVE.B  #1,D0              ; Push 3 into D0 to indicate bytesize
000018DA  4EB9 0000250E            417              JSR EAGETSRCEA             ; Find and print the code stored in D6 
000018E0                           418              
000018E0  4E75                     419              RTS
000018E2                           420              
000018E2  22FC 41444449            421  ADDIW       MOVE.L  #'ADDI',(A1)+
000018E8  32FC 2E57                422              MOVE.W  #'.W',(A1)+
000018EC  22FC 20202020            423              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
000018F2  5041                     424              ADDQ    #8,D1              ; We added 10 bytes, aka 4 spaces 6 characters
000018F4  5441                     425              ADDQ    #2,D1
000018F6                           426              
000018F6  32FC 2324                427              MOVE.W  #'#$',(A1)+
000018FA  5441                     428              ADDQ    #2,D1
000018FC                           429              
000018FC  4246                     430              CLR     D6
000018FE  4244                     431              CLR     D4
00001900  3C1A                     432              MOVE.W  (A2)+,D6
00001902  4EB9 00002668            433              JSR     EAHEXtoASCII
00001908                           434                          
00001908  12FC 002C                435              MOVE.B  #',',(A1)+      ; Add a spacer into our IOStringLoc
0000190C  5241                     436              ADDQ    #1,D1              ; We added 4 bytes, aka 4 spaces
0000190E                           437              
0000190E  2C05                     438              MOVE.L  D5,D6              ; Push D5 into D6
00001910  0286 0000003F            439              ANDI.L  #$003F,D6          ; Isolate the Dst EA bits 
00001916  103C 0002                440              MOVE.B  #2,D0              ; Push 3 into D0 to indicate wordsize
0000191A  4EB9 0000250E            441              JSR EAGETSRCEA             ; Find and print the code stored in D6 
00001920                           442              
00001920  4E75                     443              RTS
00001922                           444              
00001922  22FC 41444449            445  ADDIL       MOVE.L  #'ADDI',(A1)+
00001928  32FC 2E4C                446              MOVE.W  #'.L',(A1)+
0000192C  22FC 20202020            447              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
00001932  5041                     448              ADDQ    #8,D1              ; We added 10 bytes, aka 4 spaces 6 characters
00001934  5441                     449              ADDQ    #2,D1
00001936                           450              
00001936  32FC 2324                451              MOVE.W  #'#$',(A1)+
0000193A  5441                     452              ADDQ    #2,D1
0000193C                           453              
0000193C  4246                     454              CLR     D6
0000193E  4244                     455              CLR     D4
00001940  2C1A                     456              MOVE.L  (A2)+,D6
00001942  4846                     457              SWAP    D6
00001944  4EB9 00002668            458              JSR     EAHEXtoASCII
0000194A  4244                     459              CLR     D4
0000194C  4246                     460              CLR     D6
0000194E  4846                     461              SWAP    D6
00001950  4EB9 00002668            462              JSR     EAHEXtoASCII
00001956                           463                          
00001956  12FC 002C                464              MOVE.B  #',',(A1)+      ; Add a spacer into our IOStringLoc
0000195A  5241                     465              ADDQ    #1,D1              ; We added 4 bytes, aka 4 spaces
0000195C                           466              
0000195C  2C05                     467              MOVE.L  D5,D6              ; Push D5 into D6
0000195E  0286 0000003F            468              ANDI.L  #$003F,D6          ; Isolate the Dst EA bits 
00001964  103C 0003                469              MOVE.B  #3,D0              ; Push 3 into D0 to indicate longsize
00001968  4EB9 0000250E            470              JSR EAGETSRCEA             ; Find and print the code stored in D6 
0000196E                           471              
0000196E  4E75                     472              RTS
00001970                           473                
00001970                           474  ;  Here we assume the first left-most 4 bits are: 0001, 0011, or 0010
00001970                           475  MOVE                                   ; Two consecutive tests for illegal Dst EA Modes
00001970  2C05                     476              MOVE.L  D5,D6              ; Push D5 into D6
00001972  EC9E                     477              ROR.L   #6,D6              ; Roll 6 bits right 
00001974  0286 0000003F            478              ANDI.L  #$003F,D6          ; Isolate the Dst EA bits
0000197A  BCBC 00000027            479              CMP.L   #$0027, D6         ; Compare with illegal EA mode #<data>
00001980  6700 0B68                480              BEQ     UNKNOWN
00001984                           481              
00001984  0286 00000007            482              ANDI.L  #$0007,D6          ; Isolate the 3 Dst (Mode) bits
0000198A  BCBC 00000001            483              CMP.L   #$0001, D6         ; Compare with illegal mode An
00001990  6700 0B58                484              BEQ     UNKNOWN
00001994                           485              *----------------                   
00001994  2C05                     486              MOVE.L  D5,D6              ; Push D5 into D6 
00001996  EC8E                     487              LSR.L   #6,D6              ; Shift six bits to the right
00001998  EC8E                     488              LSR.L   #6,D6              ; Shift six bits to the right
0000199A  0286 00000003            489              ANDI.L  #$0003,D6          ; Isolate the size bits
000019A0                           490                         
000019A0  BCBC 00000001            491              CMP.L   #$0001,D6          ; See if the size is '01'..
000019A6  6700 001A                492              BEQ     MOVEB              ; ..If so, it's MOVE.B
000019AA  BCBC 00000003            493              CMP.L   #$0003,D6          ; See if the size is '11'..
000019B0  6700 0022                494              BEQ     MOVEW              ; ..If so, it's MOVE.W
000019B4  BCBC 00000002            495              CMP.L   #$0002,D6          ; See if the size is '10'..
000019BA  6700 002A                496              BEQ     MOVEL              ; ..If so, it's MOVE.L
000019BE                           497              
000019BE  6000 0B2A                498              BRA     UNKNOWN            ; If it isn't any, then it's Unknown
000019C2                           499              
000019C2                           500  
000019C2                           501  
000019C2  22FC 4D4F5645            502  MOVEB       MOVE.L  #'MOVE',(A1)+
000019C8  32FC 2E42                503              MOVE.W  #'.B',(A1)+
000019CC  5C41                     504              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
000019CE                           505              
000019CE  7001                     506              MOVE.L  #1,D0               ; Put 1 into D0 to indicate it's a bytesize
000019D0                           507              
000019D0  6000 0026                508              BRA MOVEOP
000019D4                           509              
000019D4  22FC 4D4F5645            510  MOVEW       MOVE.L  #'MOVE',(A1)+
000019DA  32FC 2E57                511              MOVE.W  #'.W',(A1)+
000019DE  5C41                     512              ADDQ    #6,D1               ; We added 6 new characters to our IOStringLoc 
000019E0                           513              
000019E0  7002                     514              MOVE.L  #2,D0               ; Put 2 into D0 to indicate it's a wordsize
000019E2                           515              
000019E2  6000 0014                516              BRA MOVEOP
000019E6                           517              
000019E6  22FC 4D4F5645            518  MOVEL       MOVE.L  #'MOVE',(A1)+
000019EC  32FC 2E4C                519              MOVE.W  #'.L',(A1)+
000019F0  5C41                     520              ADDQ    #6,D1               ; We added 6 new characters to our IOStringLoc 
000019F2                           521              
000019F2  7003                     522              MOVE.L  #3,D0               ; Put 3 into D0 to indicate it's a longsize
000019F4                           523              
000019F4  6000 0002                524              BRA MOVEOP
000019F8                           525              
000019F8  22FC 20202020            526  MOVEOP      MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
000019FE  5841                     527              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
00001A00                           528              
00001A00  2C05                     529              MOVE.L  D5,D6               ; Push D5 into D6
00001A02  0286 0000003F            530              ANDI.L  #$003F,D6           ; Isolate the Src EA bits 
00001A08  4EB9 0000250E            531              JSR EAGETSRCEA              ; Find and print the code stored in D6
00001A0E                           532              
00001A0E  12FC 002C                533              MOVE.B  #',',(A1)+
00001A12  5241                     534              ADDQ    #1,D1
00001A14                           535              
00001A14  2C05                     536              MOVE.L  D5,D6               ; Push D5 into D6
00001A16  EC8E                     537              LSR.L   #6,D6               ; Shift six bits to the right
00001A18  0286 0000003F            538              ANDI.L  #$003F,D6           ; Isolate the Dst EA bits
00001A1E  4EB9 0000254E            539              JSR EAGETDSTEA
00001A24  4E75                     540              RTS
00001A26                           541              
00001A26                           542  ; This label determines if the code is either CLR or NOP or RTS or JSR or MOVEM or LEA
00001A26                           543  ; Here we assume that the first left-most four bits equal 0100            
00001A26                           544  CNRJML      
00001A26  2C05                     545              MOVE.L  D5,D6              ; Push D5 into D6 (Copy OPcode over isolated nybble)
00001A28                           546              
00001A28                           547              *NOP & RTS's machine code is uniquely hardcoded, check first
00001A28  BCBC 00004E71            548              CMP.L   #$4E71,D6          ; See if the OPcode matches NOP's hardcode
00001A2E  6700 010A                549              BEQ     NOP
00001A32  BCBC 00004E75            550              CMP.L   #$4E75,D6          ; See if the OPcode matches RTS's hardcode
00001A38  6700 011A                551              BEQ     RTS
00001A3C                           552                                         ; CLR's middle most left nybble is unique (0010)
00001A3C  E09E                     553              ROR.L   #8,D6              ; Rotate our OpCode to right-most nybble
00001A3E  0206 000F                554              ANDI.B  #$0F,D6            ; Isolate our opcode nybble
00001A42  BC3C 0002                555              CMP.B   #$02,D6            ; See if matches nybble
00001A46  6700 0042                556              BEQ     CLR               
00001A4A                           557              
00001A4A                           558                                         ; LEA's left-most 10 bits are 0100 --- (111)
00001A4A  2C05                     559              MOVE.L  D5,D6              ; Push D5 into D6
00001A4C  EC8E                     560              LSR.L   #6,D6              ; Shift 6 bits to the right 
00001A4E  0286 00000007            561              ANDI.L  #$0007,D6          ; Isolate 3 right-most bits
00001A54  BCBC 00000007            562              CMP.L   #$0007,D6          ; See if matches 111
00001A5A  6700 023E                563              BEQ     LEA                ; If equals, branch to LEA     
00001A5E                           564              
00001A5E                           565                                         ; JSR's left-most 10 bits are 0100 (111 010)
00001A5E  2C05                     566              MOVE.L  D5,D6              ; Push D5 into D6
00001A60  EC8E                     567              LSR.L   #6,D6              ; Shift 6 bits to the right
00001A62  0286 0000003F            568              ANDI.L  #$003F,D6          ; Isolate 6 right-most bit
00001A68  BCBC 0000003A            569              CMP.L   #$003A,D6          ; See if matches 11 1010
00001A6E  6700 00FE                570              BEQ     JSR                ; If equals, branch JSR
00001A72                           571                 
00001A72                           572                                         ; MOVEM's left-most 9 bits are 0100 1- (001)
00001A72  2C05                     573              MOVE.L  D5,D6              ; Push D5 into D6
00001A74  EE8E                     574              LSR.L   #7,D6              ; Shift 7 bits to the right
00001A76  0286 00000007            575              ANDI.L  #$0007,D6          ; Isolate 3 right-most bit
00001A7C  BCBC 00000001            576              CMP.L   #$0001,D6          ; See if matches 001
00001A82  6700 0156                577              BEQ     MOVEM              ; If equals, branch MOVEM
00001A86                           578        
00001A86  6000 0A62                579              BRA     UNKNOWN            ; If it doesnt any match, then it's Unknown
00001A8A                           580  
00001A8A                           581  
00001A8A                           582  ;  Here we assume the first left-most 8 bits have been confirmed: 0100 0010
00001A8A                           583  CLR                                    ; Two consecutive tests for illegal Src EA Modes
00001A8A  2C05                     584              MOVE.L  D5,D6              ; Push D5 into D6 
00001A8C  0286 0000003F            585              ANDI.L  #$003F,D6          ; Isolate the Src EA bits
00001A92  BCBC 0000003C            586              CMP.L   #$003C, D6         ; Compare with illegal EA mode #<data>
00001A98  6700 0A50                587              BEQ     UNKNOWN
00001A9C                           588              
00001A9C  E69E                     589              ROR.L   #3,D6              ; Roll 3 bits right
00001A9E  0286 00000007            590              ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
00001AA4  BCBC 00000001            591              CMP.L   #$0001,D6          ; Compare with illegal mode An
00001AAA  6700 0A3E                592              BEQ     UNKNOWN
00001AAE                           593              *----------------
00001AAE                           594              
00001AAE  2C05                     595              MOVE.L  D5,D6              ; Push D5 into D6
00001AB0  EC8E                     596              LSR.L   #6,D6              ; Shift six bits to the right
00001AB2  0286 00000003            597              ANDI.L  #$0003,D6          ; Isolate the two size bits
00001AB8                           598                         
00001AB8  BCBC 00000000            599              CMP.L   #$0000,D6          ; See if the size is '00'..
00001ABE  6700 001A                600              BEQ     CLRB               ; ..If so, it's CLR.B
00001AC2  BCBC 00000001            601              CMP.L   #$0001,D6          ; See if the size is '01'..
00001AC8  6700 0026                602              BEQ     CLRW               ; ..If so, it's CLR.W
00001ACC  BCBC 00000002            603              CMP.L   #$0002,D6          ; See if the size is '10'..
00001AD2  6700 0032                604              BEQ     CLRL               ; ..If so, it's CLR.L
00001AD6                           605              
00001AD6  6000 0A12                606              BRA     UNKNOWN            ; If it isn't any, then it's Unknown
00001ADA                           607              
00001ADA  32FC 434C                608  CLRB        MOVE.W  #'CL',(A1)+
00001ADE  12FC 0052                609              MOVE.B  #'R',(A1)+
00001AE2  12FC 002E                610              MOVE.B  #'.',(A1)+
00001AE6  12FC 0042                611              MOVE.B  #'B',(A1)+
00001AEA  5A41                     612              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
00001AEC  6000 002E                613              BRA     CLROP
00001AF0                           614              
00001AF0  32FC 434C                615  CLRW        MOVE.W  #'CL',(A1)+
00001AF4  12FC 0052                616              MOVE.B  #'R',(A1)+
00001AF8  12FC 002E                617              MOVE.B  #'.',(A1)+
00001AFC  12FC 0057                618              MOVE.B  #'W',(A1)+
00001B00  5A41                     619              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
00001B02  6000 0018                620              BRA     CLROP
00001B06                           621  
00001B06  32FC 434C                622  CLRL        MOVE.W  #'CL',(A1)+
00001B0A  12FC 0052                623              MOVE.B  #'R',(A1)+
00001B0E  12FC 002E                624              MOVE.B  #'.',(A1)+
00001B12  12FC 004C                625              MOVE.B  #'L',(A1)+
00001B16  5A41                     626              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
00001B18  6000 0002                627              BRA     CLROP
00001B1C                           628              
00001B1C  12FC 0020                629  CLROP       MOVE.B  #' ',(A1)+
00001B20  32FC 2020                630              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
00001B24  32FC 2020                631              MOVE.W  #'  ',(A1)+
00001B28  5A41                     632              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces
00001B2A                           633              
00001B2A  2C05                     634              MOVE.L  D5,D6              ; Push D5 into D6
00001B2C  0286 0000003F            635              ANDI.L  #$003F,D6          ; Isolate the Src EA bits 
00001B32  4EB9 0000250E            636              JSR EAGETSRCEA             ; Find and print the code stored in D6
00001B38                           637  
00001B38  4E75                     638              RTS
00001B3A                           639              
00001B3A                           640  ;  Here we assume that all 16 bits have been confirmed 
00001B3A                           641  NOP
00001B3A  32FC 4E4F                642              MOVE.W  #'NO',(A1)+
00001B3E  12FC 0050                643              MOVE.B  #'P',(A1)+
00001B42  5641                     644              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
00001B44                           645              
00001B44  12FC 0020                646              MOVE.B  #' ',(A1)+       ; Add a spacer into our IOStringLoc
00001B48  32FC 2020                647              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
00001B4C  32FC 2020                648              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
00001B50  5A41                     649              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces        
00001B52  4E75                     650              RTS
00001B54                           651  
00001B54                           652  ;  Here we assume that all 16 bits have been confirmed            
00001B54                           653  RTS         
00001B54  32FC 5254                654              MOVE.W  #'RT',(A1)+
00001B58  12FC 0053                655              MOVE.B  #'S',(A1)+
00001B5C  5641                     656              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
00001B5E                           657              
00001B5E  12FC 0020                658              MOVE.B  #' ',(A1)+       ; Add a spacer into our IOStringLoc
00001B62  32FC 2020                659              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
00001B66  32FC 2020                660              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
00001B6A  5A41                     661              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces        
00001B6C  4E75                     662              RTS
00001B6E                           663              
00001B6E                           664  
00001B6E                           665  ;  Here we assume the first left-most 10 bits have been confirmed: 0100 1110 10 
00001B6E                           666  JSR                                    ; Five consecutive tests for illegal Src EA Modes
00001B6E  2C05                     667              MOVE.L  D5,D6              ; Push D5 into D6 
00001B70  0286 0000003F            668              ANDI.L  #$003F,D6          ; Isolate the Src EA bits
00001B76  BCBC 0000003C            669              CMP.L   #$003C, D6         ; Compare with illegal EA mode #<data>
00001B7C  6700 096C                670              BEQ     UNKNOWN
00001B80                           671              
00001B80  E69E                     672              ROR.L   #3,D6              ; Roll 3 bits right
00001B82  0286 00000007            673              ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
00001B88  BCBC 00000000            674              CMP.L   #$0000,D6          ; Compare with illegal mode Dn
00001B8E  6700 095A                675              BEQ     UNKNOWN
00001B92  BCBC 00000001            676              CMP.L   #$0001,D6          ; Compare with illegal mode An
00001B98  6700 0950                677              BEQ     UNKNOWN
00001B9C  BCBC 00000003            678              CMP.L   #$0003,D6          ; Compare with illegal mode (An)+
00001BA2  6700 0946                679              BEQ     UNKNOWN
00001BA6  BCBC 00000004            680              CMP.L   #$0004,D6          ; Compare with illegal mode -(An)
00001BAC  6700 093C                681              BEQ     UNKNOWN
00001BB0                           682              *----------------
00001BB0                           683  
00001BB0  32FC 4A53                684              MOVE.W  #'JS',(A1)+
00001BB4  12FC 0052                685              MOVE.B  #'R',(A1)+
00001BB8  5641                     686              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
00001BBA                           687              
00001BBA  12FC 0020                688              MOVE.B  #' ',(A1)+
00001BBE  32FC 2020                689              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
00001BC2  22FC 20202020            690              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
00001BC8  5E41                     691              ADDQ    #7,D1              ; We added 4 bytes, aka 4 spaces
00001BCA  2C05                     692              MOVE.L  D5,D6              ; Push D5 into D6
00001BCC                           693              
00001BCC  0286 0000003F            694              ANDI.L  #$003F,D6          ; Isolate the Src EA bits 
00001BD2  4EB9 0000250E            695              JSR EAGETSRCEA             ; Find and print the code stored in D6 
00001BD8  4E75                     696              RTS
00001BDA                           697              
00001BDA                           698  
00001BDA                           699  ;  Here we assume that these left-most bits have been confirmed, where - have not been confirmed: 0100 -- 001
00001BDA                           700  MOVEM                                  ; Four consecutive tests for illegal Src EA Modes
00001BDA  2C05                     701              MOVE.L  D5,D6              ; Push D5 into D6 
00001BDC  0286 0000003F            702              ANDI.L  #$003F,D6          ; Isolate the Src EA bits
00001BE2  BCBC 0000003C            703              CMP.L   #$003C, D6         ; Compare with illegal EA mode #<data>
00001BE8  6700 0900                704              BEQ     UNKNOWN
00001BEC                           705              
00001BEC  E69E                     706              ROR.L   #3,D6              ; Roll 3 bits right
00001BEE  0286 00000007            707              ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
00001BF4  BCBC 00000000            708              CMP.L   #$0000,D6          ; Compare with illegal mode Dn
00001BFA  6700 08EE                709              BEQ     UNKNOWN
00001BFE  BCBC 00000001            710              CMP.L   #$0001,D6          ; Compare with illegal mode An
00001C04  6700 08E4                711              BEQ     UNKNOWN
00001C08                           712              
00001C08  2C05                     713              MOVE.L  D5,D6              ; Copy D5 into D6
00001C0A  0246 0438                714              ANDI.W  #$0438,D6          ; Isolate our direction and EA mode bits
00001C0E  BC7C 0018                715              CMP.W   #$0018,D6          ; If it equals $0018..
00001C12  6700 08D6                716              BEQ     UNKNOWN            ; Dr 0, (An)+ case..
00001C16  BC7C 0420                717              CMP.W   #$0420,D6          ; If it equals $0420..
00001C1A  6700 08CE                718              BEQ     UNKNOWN            ; Dr 1, -(An) case..
00001C1E                           719              *----------------
00001C1E                           720  
00001C1E  22FC 4D4F5645            721              MOVE.L  #'MOVE',(A1)+
00001C24  32FC 4D2E                722              MOVE.W  #'M.',(A1)+
00001C28  5C41                     723              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
00001C2A                           724              
00001C2A  2C05                     725              MOVE.L  D5,D6              ; Copy our OpCode
00001C2C  EC8E                     726              LSR.L   #6,D6              ; Shift it 6 bits to the right
00001C2E  0806 0000                727              BTST    #$00,D6            ; If our size bit is 0..
00001C32  6700 0006                728              BEQ     MOVEMW             ; .. Its a MOVEM of size W
00001C36  6000 000C                729              BRA     MOVEML             ; .. Otherwise it's of size L
00001C3A                           730  
00001C3A  12FC 0057                731  MOVEMW      MOVE.B  #'W',(A1)+
00001C3E  5241                     732              ADDQ    #1,D1              ; We've added another character into IOStringLoc
00001C40  6000 0008                733              BRA     MOVEMOP            ; MovemOp label, to skip MovemL label
00001C44                           734              
00001C44  12FC 004C                735  MOVEML      MOVE.B  #'L',(A1)+
00001C48  5241                     736              ADDQ    #1,D1              ; We've added another character into IOStringLoc
00001C4A                           737              
00001C4A  12FC 0020                738  MOVEMOP     MOVE.B  #' ',(A1)+         ; Add a spacer into our IOStringLoc
00001C4E  32FC 2020                739              MOVE.W  #'  ',(A1)+        ;
00001C52  5641                     740              ADDQ    #3,D1              ; We added 4 bytes, aka 4 spaces 
00001C54                           741              
00001C54  E88E                     742              LSR.L   #4,D6              ; Shift our OpCode 4 bits to the left of Size (going to the right)
00001C56  0806 0000                743              BTST    #$00,D6            ; Check our Direction bit
00001C5A  6700 0006                744              BEQ     MOVEMPRED          ; If it's 0, our direction is Pre Decrement (eg. Move TO the stack)
00001C5E  6000 001E                745              BRA     MOVEMPOSTI         ; Otherwise, it's Post Increment (eg. Move FROM the stack)
00001C62                           746              
00001C62                           747  MOVEMPRED   ; This part is where we get the gross A0-A6/D0-D7 part
00001C62  4EB9 000027A2            748              JSR     EAMOVEMPRED  
00001C68                           749              
00001C68  12FC 002C                750              MOVE.B  #',',(A1)+
00001C6C  5241                     751              ADDQ    #1,D1
00001C6E                           752              
00001C6E  2C05                     753              MOVE.L  D5,D6              ; Copy our OpCode to D6
00001C70  0286 0000003F            754              ANDI.L  #$3F,D6            ; Isolate our EA src bits
00001C76                           755              
00001C76  4EB9 0000250E            756              JSR EAGETSRCEA  
00001C7C                           757            
00001C7C  4E75                     758              RTS
00001C7E                           759  
00001C7E  2C05                     760  MOVEMPOSTI  MOVE.L  D5,D6              ; Copy our OpCode to D6
00001C80  0286 0000003F            761              ANDI.L  #$3F,D6            ; Isolate our EA src bits
00001C86                           762              
00001C86  4EB9 0000250E            763              JSR EAGETSRCEA  
00001C8C                           764              
00001C8C  12FC 002C                765              MOVE.B  #',',(A1)+
00001C90  5241                     766              ADDQ    #1,D1
00001C92                           767              
00001C92                           768              ; This part is where we get the gross A0-A6/D0-D7 part
00001C92  4EB9 0000268C            769              JSR     EAMOVEMPOSTI
00001C98                           770              
00001C98  4E75                     771              RTS
00001C9A                           772              
00001C9A                           773  
00001C9A                           774  ;  Here we assume that these left-most bits have been confirmed, where - have not been confirmed: 0100 --- 111            
00001C9A                           775  LEA                                    ; Five consecutive tests for illegal Src EA Modes
00001C9A  2C05                     776              MOVE.L  D5,D6              ; Push D5 into D6 
00001C9C  0286 0000003F            777              ANDI.L  #$003F,D6          ; Isolate the Src EA bits
00001CA2  BCBC 0000003C            778              CMP.L   #$003C, D6         ; Compare with illegal EA mode #<data>
00001CA8  6700 0840                779              BEQ     UNKNOWN
00001CAC                           780              
00001CAC  E69E                     781              ROR.L   #3,D6              ; Roll 3 bits right
00001CAE  0286 00000007            782              ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
00001CB4  BCBC 00000000            783              CMP.L   #$0000,D6          ; Compare with illegal mode Dn
00001CBA  6700 082E                784              BEQ     UNKNOWN
00001CBE  BCBC 00000001            785              CMP.L   #$0001,D6          ; Compare with illegal mode An
00001CC4  6700 0824                786              BEQ     UNKNOWN
00001CC8  BCBC 00000003            787              CMP.L   #$0003,D6          ; Compare with illegal mode (An)+
00001CCE  6700 081A                788              BEQ     UNKNOWN
00001CD2  BCBC 00000004            789              CMP.L   #$0004,D6          ; Compare with illegal mode -(An)
00001CD8  6700 0810                790              BEQ     UNKNOWN
00001CDC                           791              *----------------
00001CDC                           792              
00001CDC  32FC 4C45                793              MOVE.W  #'LE',(A1)+
00001CE0  12FC 0041                794              MOVE.B  #'A',(A1)+
00001CE4  5641                     795              ADDQ    #3,D1               ; We added 3 new characters to our IOStringLoc 
00001CE6                           796               
00001CE6  12FC 0020                797              MOVE.B  #' ',(A1)+          ; Added an extra space here, due to only 3 character OpCode
00001CEA  22FC 20202020            798              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
00001CF0  32FC 2020                799              MOVE.W  #'  ',(A1)+ 
00001CF4  5E41                     800              ADDQ    #7,D1               ; We added 4 bytes, aka 4 spaces
00001CF6                           801              
00001CF6  2C05                     802              MOVE.L  D5,D6               ; Copy D5 into D6
00001CF8  0286 0000003F            803              ANDI.L  #$003F,D6           ; Isolate the Src EA bits
00001CFE  4EB9 0000250E            804              JSR EAGETSRCEA
00001D04                           805              
00001D04  12FC 002C                806              MOVE.B  #',',(A1)+
00001D08  5241                     807              ADDQ    #1,D1
00001D0A                           808              
00001D0A  2C05                     809              MOVE.L  D5,D6               ; Copy D5 into D6
00001D0C  E09E                     810              ROR.L   #8,D6               ; Rotate 9 bits to the right (An Dst bits)
00001D0E  E29E                     811              ROR.L   #1,D6               ; 
00001D10  0286 00000007            812              ANDI.L  #$0007,D6           ; Isolate the An Destination bits
00001D16  4EF9 00002598            813              JMP EAAN
00001D1C  4E75                     814              RTS      
00001D1E                           815              
00001D1E  2C05                     816  Bcc         MOVE.L  D5,D6               ; Copy our OpCode into D6
00001D20  E15E                     817              ROL.W   #8,D6               ; Rotate our condition bit into place
00001D22  0206 000F                818              ANDI.B  #$0F,D6             ; Isolate the right-most nybble (condition)
00001D26                           819              
00001D26  BC3C 0004                820              CMP.B   #%0100,D6           ; See if our Condition is '0100'
00001D2A  6700 0016                821              BEQ     BCCOP               ; If it is, we have a BCC operation
00001D2E  BC3C 000E                822              CMP.B   #%1110,D6           ; See if our Condition is '1110'
00001D32  6700 001C                823              BEQ     BGTOP               ; If it is, we have a BGT operation
00001D36  BC3C 000F                824              CMP.B   #%1111,D6           ; See if our Condition is '1111'
00001D3A  6700 0022                825              BEQ     BLEOP               ; If it is, we have a BLE operation
00001D3E                           826              
00001D3E  6000 07AA                827              BRA     UNKNOWN             ; Otherwise we don't know what kind of operation we have
00001D42                           828              
00001D42  32FC 4243                829  BCCOP       MOVE.W  #'BC',(A1)+
00001D46  12FC 0043                830              MOVE.B  #'C',(A1)+
00001D4A  5641                     831              ADDQ    #3,D1               ; We've added three characters into our IOStringLoc
00001D4C  6000 001E                832              BRA     BccSIZE             ; Branch to find our Bcc Op's Size
00001D50                           833              
00001D50  32FC 4247                834  BGTOP       MOVE.W  #'BG',(A1)+
00001D54  12FC 0054                835              MOVE.B  #'T',(A1)+
00001D58  5641                     836              ADDQ    #3,D1               ; We've added three characters into our IOStringLoc
00001D5A  6000 0010                837              BRA     BccSIZE             ; Branch to find our Bcc Op's Size
00001D5E                           838              
00001D5E  32FC 424C                839  BLEOP       MOVE.W  #'BL',(A1)+
00001D62  12FC 0045                840              MOVE.B  #'E',(A1)+
00001D66  5641                     841              ADDQ    #3,D1               ; We've added three characters into our IOStringLoc
00001D68  6000 0002                842              BRA     BccSIZE             ; Branch to find our Bcc Op's Size
00001D6C                           843  
00001D6C                           844  BccSIZE     ; Find Displacement value
00001D6C                           845              ; Branch to proper displacement value label
00001D6C                           846              ; Store the value of A2 into D7
00001D6C                           847              ; Get our total displacement into D6
00001D6C                           848              ; Print the new address as D7 +/- D6
00001D6C                           849              
00001D6C  12FC 0020                850              MOVE.B  #' ',(A1)+       ; Add a spacer into our IOStringLoc
00001D70  32FC 2020                851              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
00001D74  32FC 2020                852              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
00001D78  32FC 2020                853              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
00001D7C  5E41                     854              ADDQ    #7,D1              ; We added 4 bytes, aka 4 spaces   
00001D7E                           855              
00001D7E  12FC 0024                856              MOVE.B  #'$',(A1)+
00001D82  5241                     857              ADDQ    #1,D1
00001D84                           858              
00001D84  2C05                     859              MOVE.L  D5,D6
00001D86  0286 000000FF            860              ANDI.L  #$FF,D6             ; Isolate our Size bits
00001D8C  BC3C 0000                861              CMP.B   #$00,D6             ; If it's equal to $00..
00001D90  6700 0032                862              BEQ     Bcc16               ; .. It has a 16 bit displacement
00001D94  0286 000000FF            863              ANDI.L  #$FF,D6             ; If it's equal to $FF..
00001D9A  6700 0050                864              BEQ     Bcc32               ; .. It has a 32 bit displacement
00001D9E                           865              ; Otherwise, it's an 8 bit displacement
00001D9E                           866              
00001D9E  2E0A                     867              MOVE.L  A2,D7               ; Get our initial address
00001DA0  4A06                     868              TST.B   D6                  ; Is D6 negative?
00001DA2  6B00 0010                869              BMI     Bcc8NEG             ; Branch to Negative
00001DA6                           870              
00001DA6  DE46                     871              ADD.W   D6,D7               ; Otherwise, Add what we have to D7
00001DA8                           872              
00001DA8  2C07                     873              MOVE.L  D7,D6               ; Push our expected address into D6 to print
00001DAA  4244                     874              CLR     D4                  ; Clear counter
00001DAC  4EB9 00002668            875              JSR     EAHEXtoASCII        ; Print
00001DB2                           876              
00001DB2  4E75                     877              RTS 
00001DB4                           878              
00001DB4  4406                     879  Bcc8NEG     NEG.B   D6 
00001DB6  9E46                     880              SUB.W   D6,D7
00001DB8                           881              
00001DB8  2C07                     882              MOVE.L  D7,D6               ; Push our expected address into D6 to print
00001DBA  4244                     883              CLR     D4                  ; Clear counter
00001DBC  4EB9 00002668            884              JSR     EAHEXtoASCII        ; Print
00001DC2                           885              
00001DC2  4E75                     886              RTS  
00001DC4                           887           
00001DC4  2E0A                     888  Bcc16       MOVE.L  A2,D7               ; Get our initial address
00001DC6  3C1A                     889              MOVE.W  (A2)+,D6
00001DC8  4A46                     890              TST.W   D6                  ; Is D6 negative?
00001DCA  6B00 0010                891              BMI     Bcc16NEG             ; Branch to Negative
00001DCE                           892              
00001DCE  DE86                     893              ADD.L   D6,D7               ; Otherwise, Add what we have to D7
00001DD0                           894              
00001DD0  2C07                     895              MOVE.L  D7,D6               ; Push our expected address into D6 to print
00001DD2  4244                     896              CLR     D4                  ; Clear counter
00001DD4  4EB9 00002668            897              JSR     EAHEXtoASCII        ; Print
00001DDA                           898              
00001DDA  4E75                     899              RTS 
00001DDC  4446                     900  Bcc16NEG    NEG.W   D6 
00001DDE  9E86                     901              SUB.L   D6,D7
00001DE0                           902              
00001DE0  2C07                     903              MOVE.L  D7,D6               ; Push our expected address into D6 to print
00001DE2  4244                     904              CLR     D4                  ; Clear counter
00001DE4  4EB9 00002668            905              JSR     EAHEXtoASCII        ; Print
00001DEA                           906              
00001DEA  4E75                     907              RTS  
00001DEC                           908  
00001DEC                           909  
00001DEC  2E0A                     910  Bcc32       MOVE.L  A2,D7               ; Get our initial address
00001DEE  2C1A                     911              MOVE.L  (A2)+,D6
00001DF0  4A86                     912              TST.L   D6                  ; Is D6 negative?
00001DF2  6BE8                     913              BMI     Bcc16NEG            ; Branch to Negative
00001DF4                           914              
00001DF4  DE86                     915              ADD.L   D6,D7               ; Otherwise, Add what we have to D7
00001DF6                           916              
00001DF6  2C07                     917              MOVE.L  D7,D6               ; Push our expected address into D6 to print
00001DF8  4244                     918              CLR     D4                  ; Clear counter
00001DFA  4846                     919              SWAP    D6
00001DFC  4EB9 00002668            920              JSR     EAHEXtoASCII        ; Print
00001E02  4244                     921              CLR     D4                  ; Clear counter
00001E04  4846                     922              SWAP    D6
00001E06  4EB9 00002668            923              JSR     EAHEXtoASCII        ; Print
00001E0C                           924              
00001E0C  4E75                     925              RTS 
00001E0E                           926  
00001E0E  4486                     927  Bcc32NEG    NEG.L   D6 
00001E10  9E86                     928              SUB.L   D6,D7
00001E12                           929              
00001E12  2C07                     930              MOVE.L  D7,D6               ; Push our expected address into D6 to print
00001E14  4244                     931              CLR     D4                  ; Clear counter
00001E16  4846                     932              SWAP    D6
00001E18  4EB9 00002668            933              JSR     EAHEXtoASCII        ; Print
00001E1E  4244                     934              CLR     D4                  ; Clear counter
00001E20  4846                     935              SWAP    D6
00001E22  4EB9 00002668            936              JSR     EAHEXtoASCII        ; Print
00001E28                           937      
00001E28  4E75                     938              RTS           
00001E2A                           939  MOVEQ
00001E2A  22FC 4D4F5645            940              MOVE.L  #'MOVE',(A1)+
00001E30  12FC 0051                941              MOVE.B  #'Q',(A1)+
00001E34  5A41                     942              ADDQ    #5,D1               ; We added 4 new characters to our IOStringLoc
00001E36                           943              
00001E36  12FC 0020                944              MOVE.B  #' ',(A1)+
00001E3A  32FC 2020                945              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
00001E3E  32FC 2020                946              MOVE.W  #'  ',(A1)+
00001E42  5841                     947              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
00001E44                           948              
00001E44  2C05                     949              MOVE.L  D5,D6               ; Copy D5 into D6
00001E46  0286 000000FF            950              ANDI.L  #$00FF,D6           ; Isolate the Src EA bits
00001E4C                           951              
00001E4C  12FC 0023                952              MOVE.B  #'#',(A1)+
00001E50  12FC 0024                953              MOVE.B  #'$',(A1)+
00001E54  5241                     954              ADDQ    #1,D1               ; We added 4 bytes, aka 4 spaces
00001E56  183C 0002                955              MOVE.B  #2,D4               ; "Start" at 2 characters
00001E5A  E19E                     956              ROL.L   #$8,D6
00001E5C  4EB9 00002668            957              JSR     EAHEXtoASCII
00001E62                           958              
00001E62  12FC 002C                959              MOVE.B  #',',(A1)+
00001E66  5241                     960              ADDQ    #1,D1
00001E68                           961              
00001E68  2C05                     962              MOVE.L  D5,D6               ; Copy D5 into D6
00001E6A  E09E                     963              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00001E6C  E29E                     964              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00001E6E  0286 00000007            965              ANDI.L  #$0007,D6           ; Isolate the Dn Destination bits
00001E74  4EF9 0000258A            966              JMP EADN
00001E7A                           967              
00001E7A  4E75                     968              RTS 
00001E7C                           969              
00001E7C                           970  DIVU 
00001E7C                           971                                         ; One test for illegal Src EA Mode
00001E7C  2C05                     972              MOVE.L  D5,D6              ; Push D5 into D6   
00001E7E  E69E                     973              ROR.L   #3,D6              ; Roll 3 bits right
00001E80  0286 00000007            974              ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
00001E86  BCBC 00000001            975              CMP.L   #$0001,D6          ; Compare with illegal mode An
00001E8C  6700 065C                976              BEQ     UNKNOWN
00001E90                           977              *----------------       
00001E90  22FC 44495655            978              MOVE.L  #'DIVU',(A1)+
00001E96  5841                     979              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001E98                           980              
00001E98  22FC 20202020            981              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
00001E9E  32FC 2020                982              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
00001EA2  5C41                     983              ADDQ    #6,D1               ; We added 4 bytes, aka 4 spaces
00001EA4                           984              
00001EA4  2C05                     985              MOVE.L  D5,D6               ; Copy D5 into D6
00001EA6  0286 0000003F            986              ANDI.L  #$003F,D6           ; Isolate the Src EA bits
00001EAC  7002                     987              MOVE.L  #2,D0               ; Put 2 into D0 to indicate it's a wordsize
00001EAE  4EB9 0000250E            988              JSR EAGETSRCEA
00001EB4                           989              
00001EB4  12FC 002C                990              MOVE.B  #',',(A1)+
00001EB8  5241                     991              ADDQ    #1,D1
00001EBA                           992              
00001EBA  2C05                     993              MOVE.L  D5,D6               ; Copy D5 into D6
00001EBC  E09E                     994              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00001EBE  E29E                     995              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00001EC0  0286 00000007            996              ANDI.L  #$0007,D6           ; Isolate the Dn Destination bits
00001EC6  4EF9 0000258A            997              JMP EADN
00001ECC                           998              
00001ECC  4E75                     999              RTS
00001ECE                          1000  
00001ECE                          1001              
00001ECE  2C05                    1002  SUB         MOVE.L  D5,D6               ; Copy D5 into D6
00001ED0  EC8E                    1003              LSR.L   #6,D6               ; Shift the size bits to the far right
00001ED2  0206 0004               1004              ANDI.B  #$4,D6              ; Isolate the size bits    
00001ED6                          1005                   
00001ED6  BC3C 0004               1006              CMP.B   #%0100,D6           ; See if D6 is size "%100" through "%110"..
00001EDA  6700 0026               1007              BEQ     SUBEA              ; If it is, our OpCode is in the format of..
00001EDE                          1008              
00001EDE  2C05                    1009              MOVE.L  D5,D6               ; Copy D5 into D6
00001EE0  EC8E                    1010              LSR.L   #6,D6               ; Shift the size bits to the far right
00001EE2  0206 0007               1011              ANDI.B  #$7,D6              ; Isolate the size bits    
00001EE6                          1012              
00001EE6  BC3C 0002               1013              CMP.B   #%10,D6             ; See if D6 is size "%000" through "%010"..
00001EEA  6700 0092               1014              BEQ     SUBLDN              ; If it is, our OpCode is in the format of..
00001EEE  BC3C 0001               1015              CMP.B   #%01,D6             ; .. <EA> ~ Dn --> Dn
00001EF2  6700 009C               1016              BEQ     SUBWDN
00001EF6  BC3C 0000               1017              CMP.B   #%00,D6
00001EFA  6700 00A6               1018              BEQ     SUBBDN              ; == 000 at this point
00001EFE                          1019              
00001EFE  6000 05EA               1020              BRA     UNKNOWN
00001F02                          1021              
00001F02  2C05                    1022  SUBEA       MOVE.L  D5,D6               ; Copy D5 into D6
00001F04  CC3C 003F               1023              AND.B   #$3F,D6             ; Isolate our EA Src bits
00001F08  BC3C 0039               1024              CMP.B   #$39,D6             ; Check for Illegal #$ mode
00001F0C  6700 05DC               1025              BEQ     UNKNOWN
00001F10  CC3C 0038               1026              AND.B   #$38,D6             ; Isolate our EA Src Mode bits
00001F14  BC3C 0008               1027              CMP.B   #$08,D6             ; Check for Illegal mode An
00001F18  6700 05D0               1028              BEQ     UNKNOWN
00001F1C  BC3C 0000               1029              CMP.B   #$00,D6             ; Check for Illegal mode Dn 
00001F20  6700 05C8               1030              BEQ     UNKNOWN
00001F24                          1031              
00001F24  2C05                    1032              MOVE.L  D5,D6               ; Copy D5 into D6
00001F26  EC8E                    1033              LSR.L   #6,D6               ; Shift the size bits to the far right
00001F28  0206 0007               1034              ANDI.B  #$7,D6              ; Isolate the size bits    
00001F2C                          1035                   
00001F2C  BC3C 0006               1036              CMP.B   #%0110,D6           ; See if D6 is size "%100" through "%110"..
00001F30  6700 0016               1037              BEQ     SUBLEA              ; If it is, our OpCode is in the format of..
00001F34  BC3C 0005               1038              CMP.B   #%101,D6            ; .. Dn ~ <EA> --> <EA>
00001F38  6700 0020               1039              BEQ     SUBWEA
00001F3C  BC3C 0004               1040              CMP.B   #%100,D6
00001F40  6700 002A               1041              BEQ     SUBBEA
00001F44                          1042              
00001F44  6000 05A4               1043              BRA     UNKNOWN
00001F48                          1044  
00001F48  22FC 5355422E           1045  SUBLEA      MOVE.L  #'SUB.',(A1)+
00001F4E  5841                    1046              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001F50  12FC 004C               1047              MOVE.B  #'L',(A1)+
00001F54  5241                    1048              ADDQ    #1,D1               ; We added 1 byte into D1
00001F56  6000 0202               1049              BRA     ANDEA
00001F5A                          1050              
00001F5A  22FC 5355422E           1051  SUBWEA      MOVE.L  #'SUB.',(A1)+
00001F60  5841                    1052              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001F62  12FC 0057               1053              MOVE.B  #'W',(A1)+
00001F66  5241                    1054              ADDQ    #1,D1               ; We added 1 byte into D1
00001F68  6000 01F0               1055              BRA     ANDEA
00001F6C                          1056  
00001F6C  22FC 5355422E           1057  SUBBEA      MOVE.L  #'SUB.',(A1)+
00001F72  5841                    1058              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001F74  12FC 0042               1059              MOVE.B  #'B',(A1)+
00001F78  5241                    1060              ADDQ    #1,D1               ; We added 1 byte into D1
00001F7A  6000 01DE               1061              BRA     ANDEA
00001F7E                          1062  
00001F7E  22FC 5355422E           1063  SUBLDN      MOVE.L  #'SUB.',(A1)+
00001F84  5841                    1064              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001F86  12FC 004C               1065              MOVE.B  #'L',(A1)+
00001F8A  5241                    1066              ADDQ    #1,D1               ; We added 1 byte into D1
00001F8C  6000 0238               1067              BRA ANDDN
00001F90                          1068              
00001F90  22FC 5355422E           1069  SUBWDN      MOVE.L  #'SUB.',(A1)+
00001F96  5841                    1070              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001F98  12FC 0057               1071              MOVE.B  #'W',(A1)+
00001F9C  5241                    1072              ADDQ    #1,D1               ; We added 1 byte into D1
00001F9E  6000 0226               1073              BRA ANDDN
00001FA2                          1074  
00001FA2  22FC 5355422E           1075  SUBBDN      MOVE.L  #'SUB.',(A1)+
00001FA8  5841                    1076              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001FAA  12FC 0042               1077              MOVE.B  #'B',(A1)+
00001FAE  5241                    1078              ADDQ    #1,D1               ; We added 1 byte into D1
00001FB0  6000 0214               1079              BRA ANDDN  
00001FB4                          1080  
00001FB4                          1081  ;  Here we assume that these left-most nybble has been confirmed: 1011  
00001FB4                          1082  CMP        
00001FB4  2C05                    1083              MOVE.L  D5,D6               ; Push D5 into D6
00001FB6  EC9E                    1084              ROR.L   #6,D6               ; Rotate 6 bits to the right
00001FB8  E38E                    1085              LSL.L   #1,D6               ; Add 0 to right most bit
00001FBA  0206 000F               1086              ANDI.B  #$0F,D6             ; Isolate right-most nybble
00001FBE                          1087              
00001FBE  BC3C 0000               1088              CMP.B   #$00,D6             ; If it matches CMP.B's size bit + 0 added to right
00001FC2  6700 0016               1089              BEQ     CMPB                ; First 4 left-most bits plus size of CMP confirmed
00001FC6                          1090  
00001FC6  BC3C 0002               1091              CMP.B   #$02,D6             ; If it matches CMP.W's size bit + 0 added to right
00001FCA  6700 0026               1092              BEQ     CMPW                ; First 4 left-most bits plus size of CMP confirmed 
00001FCE                          1093  
00001FCE  BC3C 0004               1094              CMP.B   #$04,D6             ; If it matches CMP.B's size bit + 0 added to right
00001FD2  6700 0036               1095              BEQ     CMPL                ; First 4 left-most bits plus size of CMP confirmed 
00001FD6                          1096   
00001FD6  6000 0512               1097              BRA     UNKNOWN             ; else unknown 
00001FDA                          1098  
00001FDA                          1099  ;  Here we assume that confirming these bits, 1011 --- 000 --- ---, is enough to identify CMP.B 
00001FDA  32FC 434D               1100  CMPB        MOVE.W  #'CM',(A1)+
00001FDE  12FC 0050               1101              MOVE.B  #'P',(A1)+
00001FE2  12FC 002E               1102              MOVE.B  #'.',(A1)+
00001FE6  12FC 0042               1103              MOVE.B  #'B',(A1)+
00001FEA  5A41                    1104              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
00001FEC  7001                    1105              MOVE.L  #1,D0               ; Put 1 into D0 to indicate it's a bytesize
00001FEE  6000 0032               1106              BRA     CMPOP
00001FF2                          1107  
00001FF2                          1108  ;  Here we assume that confirming these bits, 1011 --- 001 --- ---, is enough to identify CMP.W   
00001FF2  32FC 434D               1109  CMPW        MOVE.W  #'CM',(A1)+
00001FF6  12FC 0050               1110              MOVE.B  #'P',(A1)+
00001FFA  12FC 002E               1111              MOVE.B  #'.',(A1)+
00001FFE  12FC 0057               1112              MOVE.B  #'W',(A1)+
00002002  5A41                    1113              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
00002004  7002                    1114              MOVE.L  #2,D0               ; Put 2 into D0 to indicate it's a wordsize
00002006  6000 001A               1115              BRA     CMPOP
0000200A                          1116              
0000200A                          1117  ;  Here we assume that confirming these bits, 1011 --- 010 --- ---, is enough to identify CMP.L
0000200A  32FC 434D               1118  CMPL        MOVE.W  #'CM',(A1)+
0000200E  12FC 0050               1119              MOVE.B  #'P',(A1)+
00002012  12FC 002E               1120              MOVE.B  #'.',(A1)+
00002016  12FC 004C               1121              MOVE.B  #'L',(A1)+
0000201A  5A41                    1122              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
0000201C  7003                    1123              MOVE.L  #3,D0               ; Put 3 into D0 to indicate it's a longsize
0000201E  6000 0002               1124              BRA     CMPOP
00002022                          1125              
00002022  12FC 0020               1126  CMPOP       MOVE.B  #' ',(A1)+
00002026  32FC 2020               1127              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
0000202A  32FC 2020               1128              MOVE.W  #'  ',(A1)+
0000202E  5A41                    1129              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces
00002030                          1130              
00002030  2C05                    1131              MOVE.L  D5,D6               ; Push D5 into D6
00002032  0286 0000003F           1132              ANDI.L  #$003F,D6           ; Isolate the Src EA bits 
00002038  4EB9 0000250E           1133              JSR EAGETSRCEA              ; Find and print the code stored in D6
0000203E                          1134              
0000203E  12FC 002C               1135              MOVE.B  #',',(A1)+
00002042  5241                    1136              ADDQ    #1,D1
00002044                          1137              
00002044  2C05                    1138              MOVE.L  D5,D6               ; Copy D5 into D6
00002046  E09E                    1139              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00002048  E29E                    1140              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
0000204A  0286 00000007           1141              ANDI.L  #$0007,D6           ; Isolate the Dn Destination bits
00002050  4EF9 0000258A           1142              JMP EADN
00002056                          1143              
00002056  4E75                    1144              RTS          
00002058                          1145          
00002058                          1146  ; This label determines if the code is either MULS or AND, by looking at it's size bits     
00002058  2C05                    1147  MULSAND     MOVE.L  D5,D6               ; Copy D5 into D6
0000205A  CC3C 0038               1148              AND.B   #$38,D6             ; Check if the Src is of mode An
0000205E  BC3C 0008               1149              CMP.B   #$08,D6
00002062  6700 0486               1150              BEQ     UNKNOWN             ; An is Invalid, branch to Unknown  
00002066  2C05                    1151              MOVE.L  D5,D6               ; Copy D5 into D6 
00002068  EC8E                    1152              LSR.L   #6,D6               ; Shift the size bits to the far right
0000206A  0206 0007               1153              ANDI.B  #$7,D6              ; Isolate the size bits
0000206E  BC3C 0007               1154              CMP.B   #7,D6               ; See if the size is '111'..
00002072  6704                    1155              BEQ.S   MULS                ; ..If so, it's a MULS opcode
00002074  6000 003E               1156              BRA     AND                 ; Otherwise, it's an AND code
00002078                          1157          
00002078                          1158  MULS                                   ; One test for illegal Src EA Mode
00002078                          1159              *----------------
00002078  22FC 4D554C53           1160              MOVE.L  #'MULS',(A1)+
0000207E  5841                    1161              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00002080                          1162              
00002080  22FC 20202020           1163              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
00002086  32FC 2020               1164              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
0000208A  5C41                    1165              ADDQ    #6,D1               ; We added 4 bytes, aka 4 spaces
0000208C                          1166              
0000208C  7002                    1167              MOVE.L  #2,D0               ; Put 2 into D0 to indicate it's a wordsize
0000208E  2C05                    1168              MOVE.L  D5,D6               ; Copy D5 into D6
00002090                          1169              ;DC.L    0,0,0,0             ; Fault Bandaid
00002090  0286 0000003F           1170              ANDI.L  #$003F,D6           ; Isolate the Src EA bits
00002096  4EB9 0000250E           1171              JSR EAGETSRCEA
0000209C                          1172              
0000209C  12FC 002C               1173              MOVE.B  #',',(A1)+
000020A0  5241                    1174              ADDQ    #1,D1
000020A2                          1175              
000020A2  2C05                    1176              MOVE.L  D5,D6               ; Copy D5 into D6
000020A4  EF5E                    1177              ROL.W   #7,D6               ; Rotate 9 bits to the right (Dn Dst bits)
000020A6  0286 00000007           1178              ANDI.L  #$0007,D6           ; Isolate the Dn Destination bits
000020AC  4EF9 0000258A           1179              JMP EADN
000020B2                          1180              
000020B2  4E75                    1181              RTS
000020B4                          1182              
000020B4                          1183  ; At this point, we know D6 is the size of our opcode
000020B4  CC3C 0004               1184  AND         AND.B   #$04,D6
000020B8  BC3C 0004               1185              CMP.B   #%0100,D6           ; See if D6 is size "%100" through "%110"..
000020BC  6700 0026               1186              BEQ     ANDEACH             ; .. Dn ~ <EA> --> <EA>
000020C0                          1187              
000020C0  2C05                    1188              MOVE.L  D5,D6               ; Copy D5 into D6
000020C2  EC8E                    1189              LSR.L   #6,D6               ; Shift the size bits to the far right
000020C4  0206 0007               1190              ANDI.B  #$7,D6              ; Isolate the size bits 
000020C8                          1191              
000020C8  BC3C 0002               1192              CMP.B   #%10,D6             ; See if D6 is size "%000" through "%010"..
000020CC  6700 00C2               1193              BEQ     ANDLDN              ; If it is, our OpCode is in the format of..
000020D0  BC3C 0001               1194              CMP.B   #%01,D6             ; .. <EA> ~ Dn --> Dn
000020D4  6700 00CC               1195              BEQ     ANDWDN
000020D8  BC3C 0000               1196              CMP.B   #%00,D6
000020DC  6700 00D6               1197              BEQ     ANDBDN              ; == 000 at this point
000020E0                          1198              
000020E0  6000 0408               1199              BRA     UNKNOWN
000020E4                          1200  
000020E4  2C05                    1201  ANDEACH     MOVE.L  D5,D6               ; Copy D5 into D6
000020E6  CC3C 003F               1202              AND.B   #$3F,D6             ; Isolate our EA Src bits
000020EA  BC3C 0039               1203              CMP.B   #$39,D6             ; Check for Illegal #$ mode
000020EE  6700 03FA               1204              BEQ     UNKNOWN
000020F2  CC3C 0038               1205              AND.B   #$38,D6             ; Isolate our EA Src Mode bits
000020F6  BC3C 0008               1206              CMP.B   #$08,D6             ; Check for Illegal mode An
000020FA  6700 03EE               1207              BEQ     UNKNOWN
000020FE  BC3C 0000               1208              CMP.B   #$00,D6             ; Check for Illegal mode Dn 
00002102  6700 03E6               1209              BEQ     UNKNOWN
00002106                          1210              
00002106  2C05                    1211              MOVE.L  D5,D6               ; Copy D5 into D6
00002108  EC8E                    1212              LSR.L   #6,D6               ; Shift the size bits to the far right
0000210A  0206 0007               1213              ANDI.B  #$7,D6              ; Isolate the size bits    
0000210E                          1214                   
0000210E  BC3C 0006               1215              CMP.B   #%0110,D6           ; See if D6 is size "%100" through "%110"..
00002112  6700 0016               1216              BEQ     ANDLEA              ; If it is, our OpCode is in the format of..
00002116  BC3C 0005               1217              CMP.B   #%101,D6            ; .. Dn ~ <EA> --> <EA>
0000211A  6700 001E               1218              BEQ     ANDWEA
0000211E  BC3C 0004               1219              CMP.B   #%100,D6
00002122  6700 0026               1220              BEQ     ANDBEA
00002126                          1221              
00002126  6000 03C2               1222              BRA     UNKNOWN
0000212A                          1223  
0000212A                          1224              
0000212A  22FC 414E442E           1225  ANDLEA      MOVE.L  #'AND.',(A1)+
00002130  12FC 004C               1226              MOVE.B  #'L',(A1)+
00002134  5A41                    1227              ADDQ    #5,D1               ; We added 5 byte into D1
00002136  6000 0022               1228              BRA     ANDEA
0000213A                          1229              
0000213A  22FC 414E442E           1230  ANDWEA      MOVE.L  #'AND.',(A1)+
00002140  12FC 0057               1231              MOVE.B  #'W',(A1)+
00002144  5A41                    1232              ADDQ    #5,D1               ; We added 5 byte into D1
00002146  6000 0012               1233              BRA     ANDEA
0000214A                          1234  
0000214A  22FC 414E442E           1235  ANDBEA      MOVE.L  #'AND.',(A1)+
00002150  12FC 0042               1236              MOVE.B  #'B',(A1)+
00002154  5A41                    1237              ADDQ    #5,D1               ; We added 5 byte into D1
00002156  6000 0002               1238              BRA     ANDEA
0000215A                          1239  
0000215A  12FC 0020               1240  ANDEA       MOVE.B  #' ',(A1)+          ; Add a spacer into our IOStringLoc
0000215E  32FC 2020               1241              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
00002162  32FC 2020               1242              MOVE.W  #'  ',(A1)+          ; Add a spacer into our IOStringLoc
00002166  5A41                    1243              ADDQ    #5,D1               ; We added 4 bytes, aka 4 spaces
00002168                          1244              
00002168  2C05                    1245              MOVE.L  D5,D6
0000216A  E08E                    1246              LSR.L   #8,D6               ; Shift our OpCode a total of 9 bits to the right
0000216C  E28E                    1247              LSR.L   #1,D6               ; 
0000216E  0286 00000007           1248              ANDI.L  #$07,D6             ; Isolate our data register
00002174                          1249              
00002174  4EB9 0000258A           1250              JSR EADN
0000217A                          1251              
0000217A  12FC 002C               1252              MOVE.B  #',',(A1)+
0000217E  5241                    1253              ADDQ    #1,D1
00002180                          1254              
00002180  2C05                    1255              MOVE.L  D5,D6               ; Copy our OpCode again
00002182  0286 0000003F           1256              ANDI.L  #$3F,D6             ; Isolate our EA bits
00002188                          1257              
00002188  4EB9 0000250E           1258              JSR EAGETSRCEA  
0000218E                          1259              
0000218E  4E75                    1260              RTS
00002190                          1261              
00002190  22FC 414E442E           1262  ANDLDN      MOVE.L  #'AND.',(A1)+
00002196  5841                    1263              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00002198  12FC 004C               1264              MOVE.B  #'L',(A1)+
0000219C  5241                    1265              ADDQ    #1,D1               ; We added 1 byte into D1
0000219E  6000 0026               1266              BRA ANDDN
000021A2                          1267              
000021A2  22FC 414E442E           1268  ANDWDN      MOVE.L  #'AND.',(A1)+
000021A8  5841                    1269              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000021AA  12FC 0057               1270              MOVE.B  #'W',(A1)+
000021AE  5241                    1271              ADDQ    #1,D1               ; We added 1 byte into D1
000021B0  6000 0014               1272              BRA ANDDN
000021B4                          1273  
000021B4  22FC 414E442E           1274  ANDBDN      MOVE.L  #'AND.',(A1)+
000021BA  5841                    1275              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000021BC  12FC 0042               1276              MOVE.B  #'B',(A1)+
000021C0  5241                    1277              ADDQ    #1,D1               ; We added 1 byte into D1
000021C2  6000 0002               1278              BRA ANDDN  
000021C6                          1279  
000021C6                          1280  ANDDN
000021C6  12FC 0009               1281              MOVE.B  #$09,(A1)+          ; Add a spacer into our IOStringLoc
000021CA  5241                    1282              ADDQ    #1,D1               ; We added 4 bytes, aka 4 spaces
000021CC                          1283              
000021CC  2C05                    1284              MOVE.L  D5,D6               ; Copy our OpCode again
000021CE  0286 0000003F           1285              ANDI.L  #$3F,D6             ; Isolate our EA bits
000021D4                          1286              
000021D4  4EB9 0000250E           1287              JSR EAGETSRCEA              
000021DA                          1288              
000021DA  12FC 002C               1289              MOVE.B  #',',(A1)+
000021DE  5241                    1290              ADDQ    #1,D1
000021E0                          1291              
000021E0  2C05                    1292              MOVE.L  D5,D6
000021E2  E08E                    1293              LSR.L   #8,D6               ; Shift our OpCode a total of 9 bits to the right
000021E4  E28E                    1294              LSR.L   #1,D6               ; 
000021E6  0286 00000007           1295              ANDI.L  #$07,D6             ; Isolate our data register
000021EC                          1296              
000021EC  4EB9 0000258A           1297              JSR EADN
000021F2                          1298              
000021F2  4E75                    1299              RTS
000021F4                          1300  
000021F4                          1301  ; This label determines if the code is either ADD or ADDA           
000021F4  2C05                    1302  ADDADDA     MOVE.L  D5,D6               ; Copy D5 into D6
000021F6  EC8E                    1303              LSR.L   #6,D6               ; Shift the size bits to the far right
000021F8  0206 0007               1304              ANDI.B  #$7,D6              ; Isolate the size bits
000021FC                          1305              
000021FC  BC3C 0003               1306              CMP.B   #%011,D6            ; ADDA Word Operation <EA> -> An 
00002200  6700 00EE               1307              BEQ     ADDAW
00002204  BC3C 0007               1308              CMP.B   #%111,D6            ; ADDA Word Operation <EA> -> An  
00002208  6700 00FA               1309              BEQ     ADDAL
0000220C                          1310              
0000220C  0206 0004               1311              ANDI.B  #$4,D6              ; Isolate the size bits
00002210                          1312              
00002210  BC3C 0004               1313              CMP.B   #%0100,D6           ; See if D6 is size "%100" through "%110"..
00002214  6700 005C               1314              BEQ     ADDEA              ; .. Dn ~ <EA> --> <EA>
00002218                          1315              
00002218  2C05                    1316              MOVE.L  D5,D6               ; Copy D5 into D6
0000221A  EC8E                    1317              LSR.L   #6,D6               ; Shift the size bits to the far right
0000221C  0206 0007               1318              ANDI.B  #$7,D6              ; Isolate the size bits
00002220                          1319  
00002220                          1320              
00002220  BC3C 0002               1321              CMP.B   #%10,D6             ; See if D6 is size "%000" through "%010"..
00002224  6700 0016               1322              BEQ     ADDLDN              ; If it is, our OpCode is in the format of..
00002228  BC3C 0001               1323              CMP.B   #%01,D6             ; .. <EA> ~ Dn --> Dn
0000222C  6700 0020               1324              BEQ     ADDWDN
00002230  BC3C 0000               1325              CMP.B   #%00,D6
00002234  6700 002A               1326              BEQ     ADDBDN              ; == 000 at this point
00002238                          1327              
00002238  6000 02B0               1328              BRA     UNKNOWN
0000223C                          1329              
0000223C  22FC 4144442E           1330  ADDLDN      MOVE.L  #'ADD.',(A1)+
00002242  5841                    1331              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00002244  12FC 004C               1332              MOVE.B  #'L',(A1)+
00002248  5241                    1333              ADDQ    #1,D1               ; We added 1 byte into D1
0000224A  6000 FF7A               1334              BRA ANDDN
0000224E                          1335              
0000224E  22FC 4144442E           1336  ADDWDN      MOVE.L  #'ADD.',(A1)+
00002254  5841                    1337              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00002256  12FC 0057               1338              MOVE.B  #'W',(A1)+
0000225A  5241                    1339              ADDQ    #1,D1               ; We added 1 byte into D1
0000225C  6000 FF68               1340              BRA ANDDN
00002260                          1341  
00002260  22FC 4144442E           1342  ADDBDN      MOVE.L  #'ADD.',(A1)+
00002266  5841                    1343              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00002268  12FC 0042               1344              MOVE.B  #'B',(A1)+
0000226C  5241                    1345              ADDQ    #1,D1               ; We added 1 byte into D1
0000226E  6000 FF56               1346              BRA ANDDN  
00002272                          1347  
00002272  2C05                    1348  ADDEA       MOVE.L  D5,D6               ; Copy D5 into D6
00002274  CC3C 003F               1349              AND.B   #$3F,D6             ; Isolate our EA Src bits
00002278  BC3C 0039               1350              CMP.B   #$39,D6             ; Check for Illegal #$ mode
0000227C  6700 026C               1351              BEQ     UNKNOWN
00002280  CC3C 0038               1352              AND.B   #$38,D6             ; Isolate our EA Src Mode bits
00002284  BC3C 0008               1353              CMP.B   #$08,D6             ; Check for Illegal mode An
00002288  6700 0260               1354              BEQ     UNKNOWN
0000228C  BC3C 0000               1355              CMP.B   #$00,D6             ; Check for Illegal mode Dn 
00002290  6700 0258               1356              BEQ     UNKNOWN
00002294                          1357              
00002294  2C05                    1358              MOVE.L  D5,D6               ; Copy D5 into D6
00002296  EC8E                    1359              LSR.L   #6,D6               ; Shift the size bits to the far right
00002298  0206 0007               1360              ANDI.B  #$7,D6              ; Isolate the size bits    
0000229C                          1361                   
0000229C  BC3C 0006               1362              CMP.B   #%0110,D6           ; See if D6 is size "%100" through "%110"..
000022A0  6700 0016               1363              BEQ     ADDLEA              ; If it is, our OpCode is in the format of..
000022A4  BC3C 0005               1364              CMP.B   #%101,D6            ; .. Dn ~ <EA> --> <EA>
000022A8  6700 0020               1365              BEQ     ADDWEA
000022AC  BC3C 0004               1366              CMP.B   #%100,D6
000022B0  6700 002A               1367              BEQ     ADDBEA
000022B4                          1368              
000022B4  6000 0234               1369              BRA     UNKNOWN
000022B8                          1370  
000022B8                          1371              
000022B8  22FC 4144442E           1372  ADDLEA      MOVE.L  #'ADD.',(A1)+
000022BE  5841                    1373              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000022C0  12FC 004C               1374              MOVE.B  #'L',(A1)+
000022C4  5241                    1375              ADDQ    #1,D1               ; We added 1 byte into D1
000022C6  6000 FE92               1376              BRA     ANDEA
000022CA                          1377              
000022CA  22FC 4144442E           1378  ADDWEA      MOVE.L  #'ADD.',(A1)+
000022D0  5841                    1379              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000022D2  12FC 0057               1380              MOVE.B  #'W',(A1)+
000022D6  5241                    1381              ADDQ    #1,D1               ; We added 1 byte into D1
000022D8  6000 FE80               1382              BRA     ANDEA
000022DC                          1383  
000022DC  22FC 4144442E           1384  ADDBEA      MOVE.L  #'ADD.',(A1)+
000022E2  5841                    1385              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000022E4  12FC 0042               1386              MOVE.B  #'B',(A1)+
000022E8  5241                    1387              ADDQ    #1,D1               ; We added 1 byte into D1
000022EA  7001                    1388              MOVE.L  #1,D0               ; Move 1 into D0 to indicate bytesize
000022EC  6000 FE6C               1389              BRA     ANDEA
000022F0                          1390              
000022F0  22FC 41444441           1391  ADDAW       MOVE.L  #'ADDA',(A1)+
000022F6  5841                    1392              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000022F8  32FC 2E57               1393              MOVE.W  #'.W',(A1)+
000022FC  5441                    1394              ADDQ    #2,D1               ; We added 1 byte into D1
000022FE  7002                    1395              MOVE.L  #2,D0               ; Move 2 into D0 to indicate wordsize
00002300  6000 0016               1396              BRA     ADDAN
00002304                          1397              
00002304  22FC 41444441           1398  ADDAL       MOVE.L  #'ADDA',(A1)+
0000230A  5841                    1399              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
0000230C  32FC 2E4C               1400              MOVE.W  #'.L',(A1)+
00002310  5441                    1401              ADDQ    #2,D1               ; We added 1 byte into D1
00002312  7003                    1402              MOVE.L  #3,D0               ; Move 3 into D0 to indicate longsize
00002314  6000 0002               1403              BRA     ADDAN
00002318                          1404         
00002318                          1405  ADDAN
00002318  22FC 20202020           1406              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
0000231E                          1407              
0000231E  5841                    1408              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
00002320                          1409              
00002320  2C05                    1410              MOVE.L  D5,D6               ; Copy our OpCode again
00002322  0286 0000003F           1411              ANDI.L  #$3F,D6             ; Isolate our EA bits
00002328                          1412              
00002328  4EB9 0000250E           1413              JSR EAGETSRCEA              
0000232E                          1414              
0000232E  12FC 002C               1415              MOVE.B  #',',(A1)+
00002332  5241                    1416              ADDQ    #1,D1
00002334                          1417              
00002334  2C05                    1418              MOVE.L  D5,D6
00002336  E08E                    1419              LSR.L   #8,D6               ; Shift our OpCode a total of 9 bits to the right
00002338  E28E                    1420              LSR.L   #1,D6               ; 
0000233A  0286 00000007           1421              ANDI.L  #$07,D6             ; Isolate our data register
00002340                          1422              
00002340  4EB9 00002598           1423              JSR EAAN
00002346                          1424              
00002346  4E75                    1425              RTS
00002348                          1426  ; This label determines if the code is either ASd (ASR) or LSd (LSL) or ROd (ROL) 
00002348                          1427  ASLSRO
00002348  2C05                    1428              MOVE.L  D5,D6               ; Copy our OpCode
0000234A  EC4E                    1429              LSR.W   #6,D6               ; Shift our size bits into place
0000234C  0206 0003               1430              ANDI.B  #$03,D6             ; Isolate our size bits
00002350  BC3C 0003               1431              CMP.B   #%11,D6             ; If our size is '11'..
00002354  6700 00E2               1432              BEQ     AASLSRO             ; ..this is an address ASLSRO
00002358                          1433              
00002358  2C05                    1434              MOVE.L  D5,D6               ; Copy our OpCode
0000235A  E64E                    1435              LSR.W   #3,D6               ; Shift our identification bits over
0000235C  0206 0003               1436              ANDI.B  #03,D6              ;  and isolate them
00002360                          1437              
00002360  BC3C 0000               1438              CMP.B   #%00,D6             ; If '00', this is a ASd op
00002364  6700 0016               1439              BEQ     ASD
00002368  BC3C 0001               1440              CMP.B   #%01,D6             ; If '01', this is a LSd op
0000236C  6700 0018               1441              BEQ     LSD
00002370  BC3C 0003               1442              CMP.B   #%11,D6             ; If '11', this is a ROd op
00002374  6700 001A               1443              BEQ     ROD
00002378                          1444              
00002378  6000 0170               1445              BRA     UNKNOWN             ; This catches for ROX, non-required op
0000237C                          1446  
0000237C  32FC 4153               1447  ASD         MOVE.W  #'AS',(A1)+
00002380  5441                    1448              ADDQ    #2,D1
00002382  6000 0016               1449              BRA     ASLSRODR
00002386                          1450              
00002386  32FC 4C53               1451  LSD         MOVE.W  #'LS',(A1)+
0000238A  5441                    1452              ADDQ    #2,D1
0000238C  6000 000C               1453              BRA     ASLSRODR
00002390                          1454              
00002390  32FC 524F               1455  ROD         MOVE.W  #'RO',(A1)+
00002394  5441                    1456              ADDQ    #2,D1
00002396  6000 0002               1457              BRA     ASLSRODR
0000239A                          1458              
0000239A                          1459  ; This section checks our ASd/LSd/ROd direction, and defaults to Right 
0000239A  2C05                    1460  ASLSRODR    MOVE.L  D5,D6               ; Copy our OpCode
0000239C  E09E                    1461              ROR.L   #8,D6               ; Shift our direction bit into place
0000239E  0806 0000               1462              BTST    #$00,D6             ; Check our right-most bit 
000023A2  6600 0010               1463              BNE     ASLSRODL            ; If it's '1', our direction is left
000023A6                          1464              
000023A6  12FC 0052               1465              MOVE.B  #'R',(A1)+          ; Otherwise it's right
000023AA  12FC 002E               1466              MOVE.B  #'.',(A1)+
000023AE  5441                    1467              ADDQ    #2,D1
000023B0                          1468              
000023B0  6000 000C               1469              BRA ASLSROSIZE
000023B4                          1470              
000023B4                          1471  ; This section is our ASd/LSd/ROd left direction
000023B4  12FC 004C               1472  ASLSRODL    MOVE.B  #'L',(A1)+          ; L for Left
000023B8  12FC 002E               1473              MOVE.B  #'.',(A1)+
000023BC  5441                    1474              ADDQ    #2,D1
000023BE                          1475              ; Carry into our Size determiner
000023BE                          1476  ; Determines what size our ASd/LSd/ROd is
000023BE                          1477  ;  Our previous operations on D6 leave our size bits
000023BE                          1478  ;  just our of range, so we shift them in
000023BE                          1479  ASLSROSIZE  
000023BE  E59E                    1480              ROL.L   #2,D6               ; Shift our size bits in
000023C0  0206 0003               1481              ANDI.B  #$03,D6             ; Isolate our size bits
000023C4  BC3C 0000               1482              CMP.B   #%00,D6             ; If our size is '00'..
000023C8  6700 0012               1483              BEQ     ASLSROB             ; ..Then it's a byte op
000023CC  BC3C 0001               1484              CMP.B   #%01,D6             ; If our size is '01'..
000023D0  6700 0012               1485              BEQ     ASLSROW             ; ..Then it's a word op
000023D4                          1486              ; Otherwise it's a long op, because we accounted for '11' earlier
000023D4                          1487              
000023D4  12FC 004C               1488              MOVE.B  #'L',(A1)+          ; Add L for Long
000023D8  6000 000E               1489              BRA     ASLSROIR            ; Complete the rest of the ASLSRO Op
000023DC                          1490              
000023DC  12FC 0042               1491  ASLSROB     MOVE.B  #'B',(A1)+          ; Add B for Byte
000023E0  6000 0006               1492              BRA     ASLSROIR            ; Complete the rest of the ASLSRO Op
000023E4                          1493              
000023E4  12FC 0057               1494  ASLSROW     MOVE.B  #'W',(A1)+          ; Add W for Word
000023E8                          1495              ; Carry through to complete the rest of the ASLSRO Op  
000023E8                          1496       
000023E8                          1497  ; This section determines if our ASLSRO is an Immediate or Dn shfit, and defaults to Immediate
000023E8  12FC 0020               1498  ASLSROIR    MOVE.B  #' ',(A1)+
000023EC  32FC 2020               1499              MOVE.W  #'  ',(A1)+
000023F0  32FC 2020               1500              MOVE.W  #'  ',(A1)+
000023F4  5C41                    1501              ADDQ    #6,D1               ; We've added 5 new characters (Size char, plus spaces)
000023F6                          1502              
000023F6                          1503              ;MOVE.L  D5,D6
000023F6  E39E                    1504              ROL.L   #1,D6               ; Get our Immediate / Register bit out front
000023F8  0806 0000               1505              BTST.L  #$00,D6
000023FC  6600 000C               1506              BNE     ASLSROIRDN          ; If it's '1', we have a Dn ASLSRO
00002400                          1507              ; Otherwise, assume immediate ASLSRO
00002400  12FC 0023               1508              MOVE.B  #'#',(A1)+
00002404  5241                    1509              ADDQ    #1,D1
00002406  6000 0008               1510              BRA     ASLSROOP            ; Branch to our ASLSRO Op finish
0000240A                          1511  ; An ASLSRO of Dn Register type   
0000240A  12FC 0044               1512  ASLSROIRDN  MOVE.B  #'D',(A1)+
0000240E  5241                    1513              ADDQ    #1,D1
00002410                          1514              ; Continue through to our ASLSRO Op finish
00002410                          1515  ; Finishes the ASLSRO Op
00002410                          1516  ASLSROOP
00002410  2C05                    1517              MOVE.L  D5,D6               ; Copy our OpCode into D6
00002412  E09E                    1518              ROR.L   #8,D6               ; Shift our Count/Reg bits into place
00002414  E29E                    1519              ROR.L   #1,D6               ;
00002416  0206 0007               1520              ANDI.B  #$07,D6             ; Isolate the Count/Reg bits
0000241A                          1521              
0000241A  0606 0030               1522              ADDI.B  #48,D6 
0000241E  12C6                    1523              MOVE.B  D6,(A1)+            ; Push our number to the IOStringLoc
00002420  5241                    1524              ADDQ    #1,D1
00002422                          1525              
00002422  12FC 002C               1526              MOVE.B  #',',(A1)+
00002426  5241                    1527              ADDQ    #1,D1
00002428                          1528              
00002428  2C05                    1529              MOVE.L  D5,D6               ; Isolate our Dn affected num bits
0000242A  0286 00000007           1530              ANDI.L  #$07,D6             ;
00002430  4EB9 0000258A           1531              JSR     EADN
00002436                          1532              
00002436  4E75                    1533              RTS
00002438                          1534  ; Start of the Effective Address version of ASLSRO
00002438  2C05                    1535  AASLSRO     MOVE.L  D5,D6               ; Copy our OpCode into D6
0000243A  CCBC 0000003F           1536              AND.L   #$3F,D6             ; Isolate the EA Srcs bits
00002440  BC3C 0039               1537              CMP.B   #$39,D6             ; Check for illegal #$ mode
00002444  6700 00A4               1538              BEQ     UNKNOWN
00002448  CCBC 00000038           1539              AND.L   #$38,D6             ; Isolate the EA src mode bits
0000244E  BC3C 0008               1540              CMP.B   #$08,D6             ; Check for illegal An Mode
00002452  6700 0096               1541              BEQ     UNKNOWN
00002456  BC3C 0000               1542              CMP.B   #$00,D6             ; Check for illegal Dn mode
0000245A  6700 008E               1543              BEQ     UNKNOWN
0000245E                          1544              
0000245E                          1545  
0000245E  2C05                    1546              MOVE.L  D5,D6               ; Copy our OpCode into D6
00002460  EF5E                    1547              ROL.W   #7,D6               ; Shift our determination bits to the far right
00002462  0206 0007               1548              ANDI.B  #$07,D6             ; Isolate the determination bits   
00002466                          1549              
00002466  BC3C 0001               1550              CMP.B   #$01,D6             ; If our determination is '001'..
0000246A  6700 0020               1551              BEQ     ALSD                ; It's a Logical Shift
0000246E  BC3C 0003               1552              CMP.B   #$03,D6             ; If it's '011'
00002472  6700 0022               1553              BEQ     AROD                ; It's a Rotation 
00002476  BC3C 0000               1554              CMP.B   #$00,D6             ; If it's '000'
0000247A  6700 0006               1555              BEQ     AASD                ; It's an Arithmetic Shift
0000247E                          1556              
0000247E  6000 006A               1557              BRA     UNKNOWN              ; Otherwise it's data
00002482                          1558  
00002482  32FC 4153               1559  AASD        MOVE.W  #'AS',(A1)+
00002486  5441                    1560              ADDQ    #2,D1
00002488  6000 0016               1561              BRA     AASLSRODR
0000248C                          1562              
0000248C  32FC 4C53               1563  ALSD        MOVE.W  #'LS',(A1)+
00002490  5441                    1564              ADDQ    #2,D1
00002492  6000 000C               1565              BRA     AASLSRODR
00002496                          1566              
00002496  32FC 524F               1567  AROD        MOVE.W  #'RO',(A1)+
0000249A  5441                    1568              ADDQ    #2,D1
0000249C  6000 0002               1569              BRA     AASLSRODR
000024A0                          1570              
000024A0                          1571  ; This section checks our ASd/LSd/ROd direction, and defaults to Right 
000024A0  2C05                    1572  AASLSRODR   MOVE.L  D5,D6              ; Copy our OpCode
000024A2  E09E                    1573              ROR.L   #8,D6               ; Shift our direction bit into place
000024A4  0806 0000               1574              BTST    #$00,D6             ; Check our right-most bit 
000024A8  6600 000C               1575              BNE     AASLSRODL           ; If it's '1', our direction is left
000024AC                          1576              
000024AC  12FC 0052               1577              MOVE.B  #'R',(A1)+          ; Otherwise it's right
000024B0  5241                    1578              ADDQ    #1,D1
000024B2                          1579              
000024B2  6000 0008               1580              BRA AASLSROOP
000024B6                          1581              
000024B6                          1582  ; This section is our ASd/LSd/ROd left direction
000024B6  12FC 004C               1583  AASLSRODL   MOVE.B  #'L',(A1)+          ; L for Left
000024BA  5241                    1584              ADDQ    #1,D1
000024BC                          1585              ; Carry into finishing AASLSRO op
000024BC                          1586  
000024BC                          1587  ; This section finishes off our Effective Address ASLSRO Op
000024BC  2C05                    1588  AASLSROOP   MOVE.L  D5,D6               ; Copy our OpCode
000024BE  0286 0000003F           1589              ANDI.L  #$3F,D6             ; Isolate our EA bits
000024C4                          1590              
000024C4  12FC 002E               1591              MOVE.B  #'.',(A1)+
000024C8  12FC 0057               1592              MOVE.B  #'W',(A1)+
000024CC  12FC 0020               1593              MOVE.B  #' ',(A1)+
000024D0  12FC 0020               1594              MOVE.B  #' ',(A1)+
000024D4  12FC 0020               1595              MOVE.B  #' ',(A1)+
000024D8  12FC 0020               1596              MOVE.B  #' ',(A1)+
000024DC  12FC 0020               1597              MOVE.B  #' ',(A1)+
000024E0  5E41                    1598              ADDQ    #7,D1
000024E2                          1599              
000024E2  4EB9 0000250E           1600              JSR EAGETSRCEA
000024E8                          1601              
000024E8  4E75                    1602              RTS
000024EA                          1603  UNKNOWN
000024EA  22FC 44415441           1604              MOVE.L  #'DATA',(A1)+
000024F0  5841                    1605              ADDQ    #4,D1           ; We added 4 new characters to our IOStringLoc 
000024F2                          1606              
000024F2  22FC 20202020           1607              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
000024F8  32FC 2020               1608              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
000024FC  5C41                    1609              ADDQ    #6,D1               ; We added 6 bytes, aka 6 spaces
000024FE                          1610              
000024FE  12FC 0024               1611              MOVE.B  #'$',(A1)+
00002502  5241                    1612              ADDQ    #1,D1
00002504                          1613              
00002504  2C05                    1614              MOVE.L  D5,D6
00002506  4EB9 00002668           1615              JSR     EAHEXtoASCII
0000250C                          1616              
0000250C  4E75                    1617              RTS
0000250E                          1618  
0000250E                          1619  
0000250E                          1620  
0000250E                          1621  
0000250E                          1622  
0000250E                          1623  
0000250E                          1624  
0000250E                          1625  
0000250E                          1626  
0000250E                          1627  
0000250E                          1628  
0000250E                          1629  
0000250E                          1630  
0000250E                          1631  
0000250E                          1632  
0000250E                          1633  
0000250E                          1634  
0000250E                          1635  -------------------- end include --------------------
0000250E                          1636      INCLUDE "EA.X68"        ; Handles EA types
0000250E                          1637  
0000250E                          1638  
0000250E                          1639  ; It is assumed that D6 contains the bits for the EA, algined to the far right. D5 contains
0000250E                          1640  ;  the original full op-code being reffered to. We assume that A2 contains the address 
0000250E                          1641  ;  pointing to the start of our EA address (if applicable), and we assume that A1 contains
0000250E                          1642  ;  the address pointing to our IOStringLoc. D1 contains the current length to be printed from A1
0000250E                          1643  
0000250E                          1644  ; For this method, D6 is in the format of: <3 bits Src Mode><3 bits Src Reg> 
0000250E                          1645  EAGETSRCEA  
0000250E  E69E                    1646      ROR.L   #3,D6       ; Rotate our bits 3 to the right
00002510  1E06                    1647      MOVE.B  D6,D7       ; Store the mode of the EA in D7
00002512  E79E                    1648      ROL.L   #3,D6       ; Rotate our 3 bits back
00002514  0286 00000007           1649      ANDI.L  #$0007,D6   ; Isolate the 3 rightmost bits as 'Reg'
0000251A  BE3C 0000               1650      CMP.B   #0,D7       ; See if the mode == '000'
0000251E  6700 006A               1651      BEQ     EADN
00002522                          1652  
00002522  BE3C 0001               1653      CMP.B   #1,D7       ; See if the mode == '001'
00002526  6700 0070               1654      BEQ     EAAN        ; Address Register Direct
0000252A                          1655      
0000252A  BE3C 0002               1656      CMP.B   #2,D7       ; See if the mode == '010'
0000252E  6700 0076               1657      BEQ     EAANI       ; Address Register Indirect
00002532                          1658      
00002532  BE3C 0003               1659      CMP.B   #3,D7       ; See if the mode == '011'
00002536  6700 0084               1660      BEQ     EAAPOST     ; Address Register Indirect with Post increment
0000253A                          1661      
0000253A  BE3C 0004               1662      CMP.B   #4,D7       ; See if the mode == '100'
0000253E  6700 0096               1663      BEQ     EAAPRE      ; Address Register Indirect with Pre increment
00002542                          1664      
00002542  BE3C 0007               1665      CMP.B   #7,D7       ; See if the mode == '111' 
00002546  6700 010A               1666      BEQ     EA111       ; Determine if (Immediate Data, Aboslute Word or Long Address)
0000254A                          1667  
0000254A  6000 0360               1668      BRA     EAUNKN
0000254E                          1669  
0000254E                          1670  ; For this method, D6 is in the format of: <3 bits Dst Reg><3 bits Dst Mode> 
0000254E                          1671  EAGETDSTEA  
0000254E  1E06                    1672      MOVE.B  D6,D7       ; Store the right-most byte into D7
00002550  CE3C 0007               1673      AND.B   #$07,D7     ; Isolate 3 rightmost bits as 'Mode'
00002554  E68E                    1674      LSR.L   #3,D6       ; Shift D6 to the right 3 bits (D6 Byte = 'Reg')
00002556  BE3C 0000               1675      CMP.B   #0,D7       ; See if the mode == '000'
0000255A  6700 002E               1676      BEQ     EADN
0000255E                          1677  
0000255E  BE3C 0001               1678      CMP.B   #1,D7       ; See if the mode == '001'
00002562  6700 0034               1679      BEQ     EAAN        ; Address Register Direct
00002566                          1680      
00002566  BE3C 0002               1681      CMP.B   #2,D7       ; See if the mode == '010'
0000256A  6700 003A               1682      BEQ     EAANI       ; Address Register Indirect
0000256E                          1683      
0000256E  BE3C 0003               1684      CMP.B   #3,D7       ; See if the mode == '011'
00002572  6700 0048               1685      BEQ     EAAPOST     ; Address Register Indirect with Post increment
00002576                          1686      
00002576  BE3C 0004               1687      CMP.B   #4,D7       ; See if the mode == '100'
0000257A  6700 005A               1688      BEQ     EAAPRE      ; Address Register Indirect with Pre increment
0000257E                          1689      
0000257E  BE3C 0007               1690      CMP.B   #7,D7       ; See if the mode == '111' 
00002582  6700 00CE               1691      BEQ     EA111       ; Determine if (Immediate Data, Aboslute Word or Long Address)
00002586                          1692  
00002586  6000 0324               1693      BRA     EAUNKN
0000258A                          1694           
0000258A                          1695  ;If the EA is a Dn EA    
0000258A                          1696  ;This method assume D6 contains the Reg for Dn  
0000258A                          1697  EADN
0000258A  12FC 0044               1698      MOVE.B  #'D',(A1)+
0000258E  0606 0030               1699      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
00002592  12C6                    1700      MOVE.B  D6,(A1)+
00002594  5441                    1701      ADDQ    #2,D1
00002596  4E75                    1702      RTS
00002598                          1703  ;If the EA is a An EA    
00002598                          1704  ;This method assume D6 contains the Reg for An  
00002598                          1705  EAAN
00002598  12FC 0041               1706      MOVE.B  #'A',(A1)+
0000259C  0606 0030               1707      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
000025A0  12C6                    1708      MOVE.B  D6,(A1)+
000025A2  5441                    1709      ADDQ    #2,D1
000025A4  4E75                    1710      RTS
000025A6                          1711  
000025A6                          1712  ;If the EA is a (An) EA    
000025A6                          1713  ;This method assume D6 contains the Reg for (An)  
000025A6                          1714  EAANI
000025A6  12FC 0028               1715      MOVE.B  #'(',(A1)+
000025AA  12FC 0041               1716      MOVE.B  #'A',(A1)+
000025AE  0606 0030               1717      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
000025B2  12C6                    1718      MOVE.B  D6,(A1)+
000025B4  12FC 0029               1719      MOVE.B  #')',(A1)+
000025B8  5841                    1720      ADDQ    #4,D1
000025BA  4E75                    1721      RTS
000025BC                          1722  ;If the EA is a (An)+ EA    
000025BC                          1723  ;This method assume D6 contains the Reg for (An)+  
000025BC                          1724  EAAPOST
000025BC  12FC 0028               1725      MOVE.B  #'(',(A1)+
000025C0  12FC 0041               1726      MOVE.B  #'A',(A1)+
000025C4  0606 0030               1727      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
000025C8  12C6                    1728      MOVE.B  D6,(A1)+
000025CA  12FC 0029               1729      MOVE.B  #')',(A1)+
000025CE  12FC 002B               1730      MOVE.B  #'+',(A1)+
000025D2  5A41                    1731      ADDQ    #5,D1
000025D4  4E75                    1732      RTS
000025D6                          1733  ;If the EA is a -(An) EA    
000025D6                          1734  ;This method assume D6 contains the Reg for -(An) 
000025D6                          1735  EAAPRE
000025D6  12FC 002D               1736      MOVE.B  #'-',(A1)+
000025DA  12FC 0028               1737      MOVE.B  #'(',(A1)+
000025DE  12FC 0041               1738      MOVE.B  #'A',(A1)+
000025E2  0606 0030               1739      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
000025E6  12C6                    1740      MOVE.B  D6,(A1)+
000025E8  12FC 0029               1741      MOVE.B  #')',(A1)+
000025EC  5A41                    1742      ADDQ    #5,D1
000025EE  4E75                    1743      RTS 
000025F0                          1744  ;If the EA is a #<data> EA    
000025F0                          1745  ;This method assume D6 contains the Reg for #<data>  
000025F0                          1746  EAID
000025F0  32FC 2324               1747      MOVE.W  #'#$',(A1)+
000025F4  5441                    1748      ADDQ    #2,D1
000025F6  B03C 0002               1749      CMP.B   #2,D0
000025FA  6E00 000E               1750      BGT     EAIDL
000025FE  3C1A                    1751      MOVE.W  (A2)+,D6
00002600  4244                    1752      CLR     D4
00002602  4EB9 00002668           1753      JSR     EAHEXtoASCII
00002608  4E75                    1754      RTS
0000260A                          1755      
0000260A                          1756  ;If the EA is a #<data> EA    
0000260A                          1757  ;This method assume D6 contains the Reg for #<data> of size Long
0000260A                          1758  EAIDL
0000260A  2C1A                    1759      MOVE.L  (A2)+,D6
0000260C  4244                    1760      CLR     D4
0000260E  4846                    1761      SWAP    D6
00002610  4EB9 00002668           1762      JSR     EAHEXtoASCII
00002616  4846                    1763      SWAP    D6
00002618  4244                    1764      CLR     D4
0000261A  4EB9 00002668           1765      JSR     EAHEXtoASCII
00002620  4E75                    1766      RTS
00002622                          1767  
00002622                          1768  ;If the EA is a (xxx).W EA    
00002622                          1769  ;This method assume D6 contains the Reg for (xxx).W  
00002622                          1770  EAAWA
00002622  12FC 0024               1771      MOVE.B  #'$',(A1)+
00002626  5241                    1772      ADDQ    #1,D1
00002628  3C1A                    1773      MOVE.W  (A2)+,D6   ; Push our next Word value into D6
0000262A                          1774      ; Push the ASCII equivlent characters of D6-- only the
0000262A                          1775      ;   first Word's worth (our entire Word we just acquired)
0000262A  4244                    1776      CLR     D4
0000262C  4EB9 00002668           1777      JSR     EAHEXtoASCII
00002632                          1778      
00002632  4E75                    1779      RTS
00002634                          1780  ;If the EA is a (xxx).L EA    
00002634                          1781  ;This method assume D6 contains the Reg for (xxx).L  
00002634                          1782  EAALA
00002634  12FC 0024               1783      MOVE.B  #'$',(A1)+
00002638  5241                    1784      ADDQ    #1,D1
0000263A  2C1A                    1785      MOVE.L  (A2)+,D6   ; Push our next Long value into D6
0000263C                          1786      ; Push the ASCII equivlent characters of D6-- only the
0000263C                          1787      ;   first Word's worth of our Long
0000263C  4244                    1788      CLR     D4         ; Clear our counter
0000263E  4846                    1789      SWAP    D6         ; Flip the high-order Word with the Low-order
00002640  4EB9 00002668           1790      JSR     EAHEXtoASCII
00002646  4846                    1791      SWAP    D6         ; Flip the high-order Word with the Low-order
00002648                          1792      ; Print the second half of the Long, too
00002648  4244                    1793      CLR     D4
0000264A  4EB9 00002668           1794      JSR     EAHEXtoASCII
00002650                          1795      
00002650  4E75                    1796      RTS
00002652                          1797  ;If the EA Mode = 111, Determine EA    
00002652                          1798  ;This method assume D6 contains the Reg for EA  
00002652                          1799  EA111
00002652  BC3C 0000               1800      CMP.B #0,D6
00002656  67CA                    1801      BEQ     EAAWA       ; Absolute Word Address 
00002658  BC3C 0001               1802      CMP.B #1,D6
0000265C  67D6                    1803      BEQ     EAALA       ; Absolute Long Address 
0000265E  BC3C 0004               1804      CMP.B #4,D6
00002662  678C                    1805      BEQ     EAID        ; Immediate Data 
00002664                          1806      *-----------------------------------------------let fall through? it shouldn't RTS right?
00002664  6000 0246               1807      BRA     EAUNKN
00002668                          1808      
00002668                          1809  ; Uses D6 as a storage, D3 as a go-between, and D4 as a counter..
00002668                          1810  ;  This operates on the low-order word of D6, and pushes exactly 4 
00002668                          1811  ;  characters into IOStringLoc, converted from HEX of D6's nybble,
00002668                          1812  ;  to ASCII in IOStringLoc
00002668  5244                    1813  EAHEXtoASCII    ADDQ    #1,D4
0000266A  E95E                    1814                  ROL.W   #4,D6              Get the left-most nyblle to the front..
0000266C  1606                    1815                  MOVE.B  D6,D3              .. Put the front-most byte into D3    
0000266E  C63C 000F               1816                  AND.B   #$0F,D3            Distill D3 down to the original left-most nybble
00002672  B63C 0009               1817                  CMP.B   #9,D3              See if our number is greater than 9..
00002676  6F00 0004               1818                  BLE     EADIGIT            If it is 9 or less, it's a digit..
0000267A  5E03                    1819                  ADD.B   #7,D3              Otherwise it is a digit, and needs an additional 7
0000267C  0603 0030               1820  EADIGIT         ADD.B   #48,D3             We now have the nybble's ASCII code
00002680  12C3                    1821                  MOVE.B  D3,(A1)+           Move the ASCII code into the output string at A1
00002682  B83C 0004               1822                  CMP.B   #4,D4              See if we've read all the characters
00002686  66E0                    1823                  BNE.S   EAHEXtoASCII       Continue if we haven't
00002688                          1824                  
00002688  5841                    1825                  ADDQ    #4,D1
0000268A  4E75                    1826                  RTS
0000268C                          1827      
0000268C                          1828  
0000268C                          1829  ; MOVEM's (A7)+,A0-A6,D0-D7 format
0000268C                          1830  ; Gets the follow-up WORD in order to process it
0000268C                          1831  EAMOVEMPOSTI ; Initilize variables for An and MOVEM
0000268C  3A1A                    1832      MOVE.W  (A2)+,D5
0000268E  2C05                    1833      MOVE.L  D5,D6
00002690  EE9E                    1834      ROR.L   #7,D6                   ; Rotate our A bits to the front
00002692  4240                    1835      CLR     D0
00002694  4247                    1836      CLR     D7
00002696  2E3C 000000FF           1837      MOVE.L  #$FF,D7                 ; Initlize our D7 to -1 
0000269C                          1838  EAMOVEMPOSTIAN
0000269C  4EB9 00002766           1839      JSR     EAMOVEMPOSTILOOPSTART   ; Find our starting An
000026A2  BE7C 0008               1840      CMP     #8,D7
000026A6  6C00 0052               1841      BGE     EAMOVEMPOSTIANEND       ; If A8, branch to AnEnd
000026AA  4EB9 00002790           1842      JSR     EAMOVEMSLASH            ; Add a slash, if we need to
000026B0                          1843      
000026B0  12FC 0041               1844      MOVE.B  #'A',(A1)+
000026B4  0647 0030               1845      ADD.W   #48,D7                  ; Convert D7 to ASCII equivlent
000026B8  12C7                    1846      MOVE.B  D7,(A1)+
000026BA  5441                    1847      ADDQ    #2,D1                   ; Add our number into IOStringLoc
000026BC  0447 002F               1848      SUB     #47,D7                  ; Equilize D7
000026C0                          1849      
000026C0                          1850      ; Check immediately next number to see if there is an ending
000026C0  103C 0001               1851      MOVE.B  #1,D0                   ; Set our slash equal to TRUE
000026C4  BE7C 0008               1852      CMP     #8,D7
000026C8  6C00 0030               1853      BGE     EAMOVEMPOSTIANEND       ; If A8, branch to AnEnd
000026CC  E29E                    1854      ROR.L   #1,D6                   ; See if our next bit is set
000026CE  0806 0000               1855      BTST    #$00,D6                 ; If it isn't set, we have no '-An'..
000026D2  67C8                    1856      BEQ     EAMOVEMPOSTIAN          ; .. Look for our next /An
000026D4                          1857      
000026D4  4EB9 0000277A           1858      JSR     EAMOVEMPOSTILOOPEND
000026DA  BE7C 0008               1859      CMP     #8,D7
000026DE  6C00 001A               1860      BGE     EAMOVEMPOSTIANEND       ; If A8, branch to AnEnd
000026E2  12FC 002D               1861      MOVE.B  #'-',(A1)+
000026E6  12FC 0041               1862      MOVE.B  #'A',(A1)+
000026EA  0647 0030               1863      ADD.W    #48,D7                  ; Convert D7 to ASCII equivlent
000026EE  12C7                    1864      MOVE.B  D7,(A1)+
000026F0  5641                    1865      ADDQ    #3,D1                   ; Add our number into IOStringLoc
000026F2  0447 0030               1866      SUB     #48,D7                  ; Equilize D7
000026F6                          1867      
000026F6  5247                    1868      ADDQ    #1,D7                   ; Account for our extra rotation in LoopEnd
000026F8  60A2                    1869      BRA     EAMOVEMPOSTIAN
000026FA                          1870      
000026FA                          1871  EAMOVEMPOSTIANEND ; Initilize variables for Dn
000026FA  2C05                    1872      MOVE.L  D5,D6
000026FC  4247                    1873      CLR     D7
000026FE  2E3C 000000FF           1874      MOVE.L  #$FF,D7                 ; Initlize our D7 to -1 
00002704  E39E                    1875      ROL.L   #1,D6                   ; Initlize our mask to -1
00002706                          1876  EAMOVEMPOSTIDN
00002706  4EB9 00002766           1877      JSR     EAMOVEMPOSTILOOPSTART   ; Find our starting Dn
0000270C  BE7C 0008               1878      CMP     #8,D7
00002710  6C00 0052               1879      BGE     EAMOVEMPOSTIEND         ; If D8, branch to End
00002714  4EB9 00002790           1880      JSR     EAMOVEMSLASH            ; Add a slash, if we need to
0000271A                          1881      
0000271A  12FC 0044               1882      MOVE.B  #'D',(A1)+
0000271E  0647 0030               1883      ADD.W   #48,D7                  ; Convert D7 to ASCII equivlent
00002722  12C7                    1884      MOVE.B  D7,(A1)+
00002724  5441                    1885      ADDQ    #2,D1                   ; Add our number into IOStringLoc
00002726  0447 002F               1886      SUB     #47,D7                  ; Equilize D7
0000272A                          1887      
0000272A                          1888      ; Check immediately next number to see if there is an ending
0000272A  103C 0001               1889      MOVE.B  #1,D0                   ; Set our slash equal to TRUE
0000272E  BE7C 0008               1890      CMP     #8,D7
00002732  6C00 0030               1891      BGE     EAMOVEMPOSTIEND         ; If D8, branch to End
00002736  E29E                    1892      ROR.L   #1,D6                   ; See if our next bit is set
00002738  0806 0000               1893      BTST    #$00,D6                 ; If it isn't set, we have no '-Dn'..
0000273C  67C8                    1894      BEQ     EAMOVEMPOSTIDN          ; .. Look for our next /Dn
0000273E                          1895      
0000273E  4EB9 0000277A           1896      JSR     EAMOVEMPOSTILOOPEND
00002744  BE7C 0008               1897      CMP     #8,D7
00002748  6C00 001A               1898      BGE     EAMOVEMPOSTIEND         ; If D8, branch to End
0000274C  12FC 002D               1899      MOVE.B  #'-',(A1)+
00002750  12FC 0044               1900      MOVE.B  #'D',(A1)+
00002754  0647 0030               1901      ADD.W    #48,D7                  ; Convert D7 to ASCII equivlent
00002758  12C7                    1902      MOVE.B  D7,(A1)+
0000275A  5641                    1903      ADDQ    #3,D1                   ; Add our number into IOStringLoc
0000275C  0447 0030               1904      SUB     #48,D7                  ; Equilize D7
00002760                          1905      
00002760  5247                    1906      ADDQ    #1,D7                   ; Account for our extra rotation in LoopEnd
00002762  60A2                    1907      BRA     EAMOVEMPOSTIDN
00002764                          1908  
00002764                          1909  EAMOVEMPOSTIEND
00002764  4E75                    1910      RTS
00002766                          1911      
00002766                          1912  EAMOVEMPOSTILOOPSTART
00002766  5207                    1913      ADDQ.B  #1,D7       ; Itterate D7
00002768  E29E                    1914      ROR.L   #1,D6       ; Rotate one bit to the right  
0000276A  BE3C 0008               1915      CMP.B   #8,D7       ; Check if we've hit A8
0000276E  6C00 0030               1916      BGE     EAMOVEMSLASHEND      ; If we have, break the loop
00002772  0806 0000               1917      BTST    #$00,D6     ; Check the far right bit
00002776  67EE                    1918      BEQ     EAMOVEMPOSTILOOPSTART       ; If it is 0, continue checking 
00002778  4E75                    1919      RTS
0000277A                          1920      
0000277A                          1921  EAMOVEMPOSTILOOPEND
0000277A  5207                    1922      ADDQ.B  #1,D7       ; Itterate D7
0000277C  E29E                    1923      ROR.L   #1,D6       ; Rotate one bit to the right  
0000277E  BE3C 0009               1924      CMP.B   #9,D7       ; Check if we've hit A8
00002782  6C00 001C               1925      BGE     EAMOVEMSLASHEND      ; If we have, break the loop
00002786  0806 0000               1926      BTST    #$00,D6     ; Check the far right bit
0000278A  66EE                    1927      BNE     EAMOVEMPOSTILOOPEND       ; If it isn't 0, continue checking 
0000278C  5347                    1928      SUBQ    #1,D7
0000278E  4E75                    1929      RTS
00002790                          1930      
00002790                          1931  EAMOVEMSLASH
00002790  B07C 0001               1932      CMP     #1,D0       ; If D0 != 1
00002794  6600 000A               1933      BNE     EAMOVEMSLASHEND  ; RTS
00002798  4240                    1934      CLR     D0          ; Reset our slash
0000279A  12FC 002F               1935      MOVE.B  #'/',(A1)+  ; Otherwise Add a slash
0000279E  5241                    1936      ADDQ    #1,D1  
000027A0                          1937  EAMOVEMSLASHEND     
000027A0  4E75                    1938      RTS
000027A2                          1939      
000027A2                          1940  ; MOVEM's A0-A6,D0-D7,-(An) format
000027A2                          1941  ; Gets the follow-up WORD in order to process it
000027A2                          1942  EAMOVEMPRED ; Initilize variables for An and MOVEM
000027A2  48E7 0400               1943      MOVEM.L D5,-(SP)                ; Save our original OpCode for later
000027A6  3A1A                    1944      MOVE.W  (A2)+,D5
000027A8  2C05                    1945      MOVE.L  D5,D6
000027AA  E09E                    1946      ROR.L   #8,D6                   ; Rotate our A bits to the front
000027AC  4240                    1947      CLR     D0
000027AE  4247                    1948      CLR     D7
000027B0  2E3C 000000FF           1949      MOVE.L  #$FF,D7                 ; Initlize our D7 to -1 
000027B6                          1950  EAMOVEMPREDAN
000027B6  4EB9 00002882           1951      JSR     EAMOVEMPREDLOOPSTART    ; Find our starting An
000027BC  BE7C 0008               1952      CMP     #8,D7
000027C0  6C00 0050               1953      BGE     EAMOVEMPREDANEND        ; If A8, branch to AnEnd
000027C4  4EB8 2790               1954      JSR     EAMOVEMSLASH            ; Add a slash, if we need to
000027C8                          1955      
000027C8  12FC 0041               1956      MOVE.B  #'A',(A1)+
000027CC  0647 0030               1957      ADD.W   #48,D7                  ; Convert D7 to ASCII equivlent
000027D0  12C7                    1958      MOVE.B  D7,(A1)+
000027D2  5441                    1959      ADDQ    #2,D1                   ; Add our number into IOStringLoc
000027D4  0447 002F               1960      SUB     #47,D7                  ; Equilize D7
000027D8                          1961      
000027D8                          1962      ; Check immediately next number to see if there is an ending
000027D8  103C 0001               1963      MOVE.B  #1,D0                   ; Set our slash equal to TRUE
000027DC  BE7C 0008               1964      CMP     #8,D7
000027E0  6C00 0030               1965      BGE     EAMOVEMPREDANEND        ; If A8, branch to AnEnd
000027E4  E39E                    1966      ROL.L   #1,D6                   ; See if our next bit is set
000027E6  0806 0000               1967      BTST    #$00,D6                 ; If it isn't set, we have no '-An'..
000027EA  67CA                    1968      BEQ     EAMOVEMPREDAN           ; .. Look for our next /An
000027EC                          1969      
000027EC  4EB9 00002896           1970      JSR     EAMOVEMPREDLOOPEND
000027F2  BE7C 0008               1971      CMP     #8,D7
000027F6  6C00 001A               1972      BGE     EAMOVEMPREDANEND        ; If A8, branch to AnEnd
000027FA  12FC 002D               1973      MOVE.B  #'-',(A1)+
000027FE  12FC 0041               1974      MOVE.B  #'A',(A1)+
00002802  0647 0030               1975      ADD.W    #48,D7                 ; Convert D7 to ASCII equivlent
00002806  12C7                    1976      MOVE.B  D7,(A1)+
00002808  5641                    1977      ADDQ    #3,D1                   ; Add our number into IOStringLoc
0000280A  0447 0030               1978      SUB     #48,D7                  ; Equilize D7
0000280E                          1979      
0000280E  5247                    1980      ADDQ    #1,D7                   ; Account for our extra rotation in LoopEnd
00002810  60A4                    1981      BRA     EAMOVEMPREDAN
00002812                          1982      
00002812                          1983  EAMOVEMPREDANEND ; Initilize variables for Dn
00002812  2C05                    1984      MOVE.L  D5,D6
00002814  4247                    1985      CLR     D7
00002816  2E3C 000000FF           1986      MOVE.L  #$FF,D7                 ; Initlize our D7 to -1 
0000281C  E19E                    1987      ROL.L   #8,D6                   ; Initlize our mask to -1
0000281E  E19E                    1988      ROL.L   #8,D6                   ;
00002820                          1989  EAMOVEMPREDDN
00002820  4EB9 00002882           1990      JSR     EAMOVEMPREDLOOPSTART   ; Find our starting Dn
00002826  BE7C 0008               1991      CMP     #8,D7
0000282A  6C00 0050               1992      BGE     EAMOVEMPREDEND          ; If D8, branch to End
0000282E  4EB8 2790               1993      JSR     EAMOVEMSLASH            ; Add a slash, if we need to
00002832                          1994      
00002832  12FC 0044               1995      MOVE.B  #'D',(A1)+
00002836  0647 0030               1996      ADD.W   #48,D7                  ; Convert D7 to ASCII equivlent
0000283A  12C7                    1997      MOVE.B  D7,(A1)+
0000283C  5441                    1998      ADDQ    #2,D1                   ; Add our number into IOStringLoc
0000283E  0447 002F               1999      SUB     #47,D7                  ; Equilize D7
00002842                          2000      
00002842                          2001      ; Check immediately next number to see if there is an ending
00002842  103C 0001               2002      MOVE.B  #1,D0                   ; Set our slash equal to TRUE
00002846  BE7C 0008               2003      CMP     #8,D7
0000284A  6C00 0030               2004      BGE     EAMOVEMPREDEND          ; If D8, branch to End
0000284E  E39E                    2005      ROL.L   #1,D6                   ; See if our next bit is set
00002850  0806 0000               2006      BTST    #$00,D6                 ; If it isn't set, we have no '-Dn'..
00002854  67CA                    2007      BEQ     EAMOVEMPREDDN           ; .. Look for our next /Dn
00002856                          2008      
00002856  4EB9 00002896           2009      JSR     EAMOVEMPREDLOOPEND
0000285C  BE7C 0008               2010      CMP     #8,D7
00002860  6C00 001A               2011      BGE     EAMOVEMPREDEND          ; If D8, branch to End
00002864  12FC 002D               2012      MOVE.B  #'-',(A1)+
00002868  12FC 0044               2013      MOVE.B  #'D',(A1)+
0000286C  0647 0030               2014      ADD.W   #48,D7                  ; Convert D7 to ASCII equivlent
00002870  12C7                    2015      MOVE.B  D7,(A1)+
00002872  5641                    2016      ADDQ    #3,D1                   ; Add our number into IOStringLoc
00002874  0447 0030               2017      SUB     #48,D7                  ; Equilize D7
00002878                          2018      
00002878  5247                    2019      ADDQ    #1,D7                   ; Account for our extra rotation in LoopEnd
0000287A  60A4                    2020      BRA     EAMOVEMPREDDN
0000287C                          2021  
0000287C                          2022  EAMOVEMPREDEND
0000287C  4CDF 0020               2023      MOVEM.L (SP)+,D5
00002880  4E75                    2024      RTS
00002882                          2025      
00002882                          2026  EAMOVEMPREDLOOPSTART
00002882  5207                    2027      ADDQ.B  #1,D7       ; Itterate D7
00002884  E39E                    2028      ROL.L   #1,D6       ; Rotate one bit to the right  
00002886  BE3C 0008               2029      CMP.B   #8,D7       ; Check if we've hit A8
0000288A  6C00 FF14               2030      BGE     EAMOVEMSLASHEND      ; If we have, break the loop
0000288E  0806 0000               2031      BTST    #$00,D6     ; Check the far right bit
00002892  67EE                    2032      BEQ     EAMOVEMPREDLOOPSTART       ; If it is 0, continue checking 
00002894  4E75                    2033      RTS
00002896                          2034      
00002896                          2035  EAMOVEMPREDLOOPEND
00002896  5207                    2036      ADDQ.B  #1,D7       ; Itterate D7
00002898  E39E                    2037      ROL.L   #1,D6       ; Rotate one bit to the right  
0000289A  BE3C 0009               2038      CMP.B   #9,D7       ; Check if we've hit A8
0000289E  6C00 FF00               2039      BGE     EAMOVEMSLASHEND      ; If we have, break the loop
000028A2  0806 0000               2040      BTST    #$00,D6     ; Check the far right bit
000028A6  66EE                    2041      BNE     EAMOVEMPREDLOOPEND       ; If it isn't 0, continue checking 
000028A8  5347                    2042      SUBQ    #1,D7
000028AA  4E75                    2043      RTS
000028AC                          2044      
000028AC                          2045  ; If the EA is unknown
000028AC                          2046  EAUNKN
000028AC  12FC 003C               2047      MOVE.B  #'<',(A1)+  ; We did this byte-by-byte in case A1 is at an odd register
000028B0  12FC 0045               2048      MOVE.B  #'E',(A1)+
000028B4  12FC 0041               2049      MOVE.B  #'A',(A1)+
000028B8  12FC 003E               2050      MOVE.B  #'>',(A1)+
000028BC  5841                    2051      ADDQ    #4,D1
000028BE  4E75                    2052      RTS
000028C0                          2053  
000028C0                          2054  
000028C0                          2055  
000028C0                          2056  
000028C0                          2057  
000028C0                          2058  
000028C0                          2059  
000028C0                          2060  
000028C0                          2061  
000028C0                          2062  
000028C0                          2063  -------------------- end include --------------------
000028C0                          2064      
000028C0  FFFF FFFF               2065      SIMHALT             ; halt simulator
000028C4                          2066  
000028C4                          2067  * Put variables and constants here
000028C4                          2068  
000028C4                          2069      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AASD                2482
AASLSRO             2438
AASLSRODL           24B6
AASLSRODR           24A0
AASLSROOP           24BC
ADDADDA             21F4
ADDAL               2304
ADDAN               2318
ADDAW               22F0
ADDBDN              2260
ADDBEA              22DC
ADDEA               2272
ADDI                183A
ADDI8               184E
ADDIB               189E
ADDIL               1922
ADDIW               18E2
ADDLDN              223C
ADDLEA              22B8
ADDWDN              224E
ADDWEA              22CA
ALSD                248C
AND                 20B4
ANDBDN              21B4
ANDBEA              214A
ANDDN               21C6
ANDEA               215A
ANDEACH             20E4
ANDLDN              2190
ANDLEA              212A
ANDWDN              21A2
ANDWEA              213A
AROD                2496
ASD                 237C
ASLSRO              2348
ASLSROB             23DC
ASLSRODL            23B4
ASLSRODR            239A
ASLSROIR            23E8
ASLSROIRDN          240A
ASLSROOP            2410
ASLSROSIZE          23BE
ASLSROW             23E4
BAD_EVEN            10DE
BAD_LENGTH          10A0
BCC                 1D1E
BCC16               1DC4
BCC16NEG            1DDC
BCC32               1DEC
BCC32NEG            1E0E
BCC8NEG             1DB4
BCCOP               1D42
BCCSIZE             1D6C
BGTOP               1D50
BLEOP               1D5E
CHECK31             1058
CLR                 1A8A
CLRB                1ADA
CLRL                1B06
CLROP               1B1C
CLRW                1AF0
CMP                 1FB4
CMPB                1FDA
CMPL                200A
CMPOP               2022
CMPW                1FF2
CNRJML              1A26
CONTINUE            177F
COUNTER             17BE
CR                  D
DIVU                1E7C
EA111               2652
EAALA               2634
EAAN                2598
EAANI               25A6
EAAPOST             25BC
EAAPRE              25D6
EAAWA               2622
EADIGIT             267C
EADN                258A
EAGETDSTEA          254E
EAGETSRCEA          250E
EAHEXTOASCII        2668
EAID                25F0
EAIDL               260A
EAMOVEMPOSTI        268C
EAMOVEMPOSTIAN      269C
EAMOVEMPOSTIANEND   26FA
EAMOVEMPOSTIDN      2706
EAMOVEMPOSTIEND     2764
EAMOVEMPOSTILOOPEND  277A
EAMOVEMPOSTILOOPSTART  2766
EAMOVEMPRED         27A2
EAMOVEMPREDAN       27B6
EAMOVEMPREDANEND    2812
EAMOVEMPREDDN       2820
EAMOVEMPREDEND      287C
EAMOVEMPREDLOOPEND  2896
EAMOVEMPREDLOOPSTART  2882
EAMOVEMSLASH        2790
EAMOVEMSLASHEND     27A0
EAUNKN              28AC
ENDINGADDRESS       17BA
ENDLOOP             1124
ENTERCHECK          1064
ENTERPROMPT         16F3
FAIL_INPUT          16AD
HEXEND              164F
HEXSTART            1632
INTRO2              1461
INTROMSG            1264
IOASCIITOHEX        10F4
IOASCIITOHEX2       114E
IODIGIT             1216
IODONE              124E
IOHEXTOASCII        1202
IOINTRO             100C
IOLOOP              102A
IOORTAG             1106
IOORTAG2            1160
IOSTRINGLOC         100
JSR                 1B6E
LEA                 1C9A
LENGTH_CHECK        1088
LF                  A
LSD                 2386
MOVE                1970
MOVEB               19C2
MOVEL               19E6
MOVEM               1BDA
MOVEML              1C44
MOVEMOP             1C4A
MOVEMPOSTI          1C7E
MOVEMPRED           1C62
MOVEMW              1C3A
MOVEOP              19F8
MOVEQ               1E2A
MOVEW               19D4
MULS                2078
MULSAND             2058
NOP                 1B3A
OPGETCODE           17C2
OUTPUTOPCODE        1192
OUTRO               167B
ROD                 2390
RTS                 1B54
SPACER              17B2
SPC                 166B
START               1000
STARTADDRESS        17B6
STARTGTEND          1735
STARTLESSTHNEND     10B2
SUB                 1ECE
SUBBDN              1FA2
SUBBEA              1F6C
SUBEA               1F02
SUBLDN              1F7E
SUBLEA              1F48
SUBWDN              1F90
SUBWEA              1F5A
TEST_ODD            10C4
UNKEA               1671
UNKNOWN             24EA
