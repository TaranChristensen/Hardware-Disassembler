00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 3/3/2016 3:40:23 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Master
00000000                             3  * Written by : Circles
00000000                             4  * Date       : ##/##/16
00000000                             5  * Description: Project Master File
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11      INCLUDE "IO.X68"        ; Handles our input and output, as well as which address to refer to
00001000                            12  
00001000  43F9 0000111C             13  IOINTRO LEA     IntroMsg,A1      Display the intro
00001006  103C 000E                 14          MOVE.B  #14, D0
0000100A  4E4F                      15          TRAP    #15
0000100C                            16  
0000100C  43F9 00001139             17  IOLOOP  LEA     HexStart,A1        Display the prompt and loop it
00001012  103C 000E                 18          MOVE.B  #14,D0          
00001016  4E4F                      19          TRAP    #15       
00001018                            20  
00001018  43F9 00000100             21          LEA  IOStringLoc,A1     ; Store the string of our user input at StartAddress,A1 
0000101E  103C 0002                 22          MOVE.B  #2,D0           ;   uses Trap #15, Task 2
00001022  4E4F                      23          TRAP    #15             ;
00001024                            24          
00001024  B2BC 00000001             25          CMP.L   #1,D1           ; Compares D1 to the number 1 (eg. String length of 1)
0000102A  6700 00DA                 26          BEQ     IODONE          ; Branch to DONE if they are equal
0000102E                            27          
0000102E  4284                      28          CLR.L   D4              ; Ensure our counter (D4) is 0      
00001030                            29              
00001030  5244                      30  IOASCIItoHEX    ADDQ    #1,D4
00001032  E98A                      31                  LSL.L   #4,D2           ; Scoot D2 a nybble
00001034  1619                      32                  MOVE.B  (A1)+,D3        ; Move a Byte from A1's address to D3
00001036  0403 0030                 33                  SUB.B   #48,D3          ; Sub 48 to turn ASCII 0 into binary 0
0000103A  B63C 0009                 34                  CMP.B   #9,D3           ; If our number is greater than 9..
0000103E  6F02                      35                  BLE.S   IOORTAG         ; .. it must be a character; A-F: 
00001040  5F03                      36                  SUB.B   #7,D3           ; Sub 7 to turn A into 10
00001042  8403                      37  IOORTAG         OR.B    D3,D2           ; Store our nybble into D2
00001044  B204                      38                  CMP.B   D4,D1           ; See if we've read all the characters
00001046  66E8                      39                  BNE.S   IOASCIItoHEX    ; Continue if we haven't
00001048                            40              
00001048  23FC 00000000 000011B2    41          MOVE.L  #0,StartAddress
00001052  23C2 000011B2             42          MOVE.L  D2,StartAddress     ; Store our StartAddress
00001058                            43          
00001058  4281                      44          CLR.L   D1
0000105A                            45          
0000105A                            46          ; ==== OUTPUT OPCODE ===    
0000105A  23FC 00000000 00000100    47          MOVE.L  #0,IOStringLoc      ; == Testing Purposes; not nessessary ==   
00001064                            48          
00001064                            49          ; <Testing section>        
00001064  2479 000011B2             50          MOVE.L  StartAddress,A2     ; Push our start address into A2 
0000106A  34FC C1C1                 51          MOVE.W  #$C1C1,(A2)+    ; Push OpCode for MULS D1,D0 into our start address
0000106E  34FC 3200                 52          MOVE.W  #$3200,(A2)+    ; Push OpCode for Move.W D0,D1 into our start address
00001072  34FC 2200                 53          MOVE.W  #$2200,(A2)+    ; Push OpCode for Move.L D0,D1 into our start address
00001076                            54          ; </Testing section>
00001076                            55          
00001076  2479 000011B2             56          MOVE.L  StartAddress,A2     ; Push our start address into A2 
0000107C  43F9 00000100             57          LEA     IOStringLoc,A1      ; Load our IOStringLoc into A1 for string contruction purposes
00001082                            58          
00001082                            59          ; Here we could loop all of the addresses of A2 until End, or something.
00001082  22FC 23232323             60          MOVE.L  #'####',(A1)+       ; Move our "OpCode location" into our IOStringLoc <---- THIS NEEDS TO BE HEX
00001088  5841                      61          ADDQ    #4,D1               ; We added 4 new characters                       <---- THIS NEEDS TO BE 8
0000108A  22FC 20202020             62          MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
00001090  5841                      63          ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
00001092                            64          
00001092  4EB9 000011B6             65          JSR OPGETCODE               ; Get the OpCode pointed at by A2, it's string stored in IOStringLoc
00001098                            66          
00001098  43F9 00000100             67          LEA     IOStringLoc,A1      ; Now that we've populated the string, load it's beginning
0000109E  103C 0001                 68          MOVE.B  #1,D0               ; Trap task 1 prints a string at A1 with #D1 bytes.
000010A2  4E4F                      69          TRAP    #15
000010A4                            70  
000010A4  43F9 00001197             71          LEA     SPC,A1              ; Puts the space before the opCode
000010AA  103C 000D                 72          MOVE.B  #13,D0
000010AE  4E4F                      73          TRAP    #15
000010B0                            74          ; ==== END OUTPUT OPCODE ====
000010B0                            75  
000010B0  43F9 00001189             76          LEA     RES,A1          ; Output the beginning of the message
000010B6  103C 000E                 77          MOVE.B  #14,D0  
000010BA  4E4F                      78          TRAP    #15
000010BC                            79  
000010BC                            80          ; ==== OUTPUT USER INPUT ====
000010BC                            81          ; The following outputs the input, converting what we've saved in HEX to ASCII
000010BC                            82          ; We won't need this in the final version, but the below code should be handy
000010BC                            83          ;  for print out EA values
000010BC  2439 000011B2             84          MOVE.L  StartAddress,D2 ; Ensure our address is actually at D2
000010C2  7208                      85          MOVEQ   #8,D1           ; There are 8 characters in the hex of our address
000010C4  4284                      86          CLR.L   D4              ; Ensure our counter (D4) is 0
000010C6  43F9 00000100             87          LEA     IOStringLoc,A1  ; Load our IO String location, to store our output at  
000010CC                            88          
000010CC  5244                      89  IOHEXtoASCII    ADDQ    #1,D4
000010CE  E99A                      90                  ROL.L   #4,D2           ; Get the left-most nyblle to the front..
000010D0  1602                      91                  MOVE.B  D2,D3           ; .. Put the front-most byte into D3    
000010D2  C63C 000F                 92                  AND.B   #$0F,D3         ; Distill D3 down to the original left-most nybble
000010D6  B63C 0009                 93                  CMP.B   #9,D3           ; See if our number is greater than 9..
000010DA  6F00 0004                 94                  BLE     IODIGIT         ; If it is 9 or less, it's a digit..
000010DE  5E03                      95                  ADD.B   #7,D3           ; Otherwise it is a digit, and needs an additional 7
000010E0  0603 0030                 96  IODIGIT         ADD.B   #48,D3          ; We now how the nybble's ASCII code
000010E4  12C3                      97                  MOVE.B  D3,(A1)+        ; Move the ASCII code into the output string at A1
000010E6  B204                      98                  CMP.B   D4,D1           ; See if we've read all the characters
000010E8  66E2                      99                  BNE.S   IOHEXtoASCII    ; Continue if we haven't
000010EA                           100          
000010EA  43F9 00000100            101          LEA     IOStringLoc,A1  ; Now that we've populated the string, load it's beginning
000010F0  103C 0001                102          MOVE.B  #1,D0           ; Trap task 1 prints a string at A1 with #D1 bytes.
000010F4  4E4F                     103          TRAP    #15
000010F6                           104          ; ==== END OUTPUT USER INPUT ====
000010F6                           105  
000010F6  43F9 00001197            106          LEA     SPC,A1          Puts the space after the number
000010FC  103C 000D                107          MOVE.B  #13,D0
00001100  4E4F                     108          TRAP    #15
00001102                           109  
00001102  6000 FF08                110          BRA     IOLOOP
00001106                           111          
00001106  43F9 000011A7            112  IODONE  LEA     OUTRO,A1        Display the ending message 
0000110C  103C 000E                113          MOVE.B  #14,D0
00001110  4E4F                     114          TRAP    #15
00001112  103C 0009                115          MOVE.B  #9,D0
00001116  4E4F                     116          TRAP    #15             Halt Simulator
00001118                           117          
00001118  FFFF FFFF                118          SIMHALT
0000111C                           119          
0000111C  =0000000D                120  CR              EQU     $0D         
0000111C  =0000000A                121  LF              EQU     $0A 
0000111C  =00000100                122  IOStringLoc     EQU     $0100   ; This is where we will store the string of the user input, and other strings
0000111C                           123  
0000111C= 54 65 61 6D 20 43 ...    124  IntroMsg        DC.B    'Team Circles Disassembler ',CR,LF,0     Intro
00001139= 50 6C 65 61 73 65 ...    125  HexStart        DC.B    'Please enter a full hexidecimal address to get started, or',CR,LF,'type in 0 to quit: ',0         Prompt for the user
00001189= 59 6F 75 20 74 79 ...    126  RES             DC.B    'You typed in ',0                        Response to the user
00001197= 20 20 20 20 20 00        127  SPC             DC.B    '     ',0                                tab
0000119D= 3C 45 41 3E 2C 3C ...    128  UnkEA           DC.B    '<EA>,<EA>',0                            Interim message for unkown EAs.
000011A7= 47 6F 6F 64 62 79 ...    129  OUTRO           DC.B    'Goodbye !',0                            Outro message
000011B2                           130  StartAddress    DS.L    1
000011B6                           131  
000011B6                           132  
000011B6                           133  
000011B6                           134  
000011B6                           135  
000011B6                           136  
000011B6                           137  
000011B6                           138  
000011B6                           139  -------------------- end include --------------------
000011B6                           140      INCLUDE "OpCode.X68"    ; Handles determining OpCodes
000011B6                           141  
000011B6                           142  
000011B6                           143  ; Here we assume that A2 contains the address pointing to our OpCode, and
000011B6                           144  ;  we assume that A1 contains the address pointing to our IOStringLoc
000011B6  3A1A                     145  OPGETCODE   MOVE.W  (A2)+,D5    ; Push our OpCode into D5
000011B8  2C05                     146              MOVE.L  D5,D6       ; Also store the OpCode in D6
000011BA  E09E                     147              ROR.L   #8,D6       ; Rotate our OpCode to right-most nybble
000011BC  E89E                     148              ROR.L   #4,D6       ; 
000011BE  0206 000F                149              ANDI.B  #$0F,D6     ; Isolate our opcode nybble
000011C2  BC3C 0001                150              CMP.B   #$01,D6     
000011C6  6700 001E                151              BEQ     MOVEB       ; MOVE.B
000011CA  BC3C 0003                152              CMP.B   #$03,D6     
000011CE  6700 0050                153              BEQ     MOVEW       ; MOVE.W
000011D2  BC3C 0002                154              CMP.B   #$02,D6
000011D6  6700 0082                155              BEQ     MOVEL       ; MOVE.L
000011DA  BC3C 000C                156              CMP.B   #$0C,D6
000011DE  6700 00B4                157              BEQ     MULSAND     ; MULS or AND opcodes
000011E2  6000 00FC                158              BRA     UNKNOWN
000011E6                           159              
000011E6                           160  MOVEB
000011E6  22FC 4D4F5645            161              MOVE.L  #'MOVE',(A1)+
000011EC  32FC 2E42                162              MOVE.W  #'.B',(A1)+
000011F0  5C41                     163              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
000011F2                           164              
000011F2  22FC 20202020            165              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
000011F8  5841                     166              ADDQ    #4,D1              ; We added 4 bytes, aka 4 spaces
000011FA                           167              
000011FA  2C05                     168              MOVE.L  D5,D6              ; Push D5 into D6
000011FC  0286 0000003F            169              ANDI.L  #$003F,D6          ; Isolate the Src EA bits 
00001202  4EB9 000012F8            170              JSR EAGETSRCEA             ; Find and print the code stored in D6
00001208                           171              
00001208  12FC 002C                172              MOVE.B  #',',(A1)+
0000120C  5241                     173              ADDQ    #1,D1
0000120E                           174              
0000120E  2C05                     175              MOVE.L  D5,D6              ; Push D5 into D6
00001210  EC8E                     176              LSR.L   #6,D6              ; Shift six bits to the right
00001212  0286 0000003F            177              ANDI.L  #$003F,D6          ; Isolate the Dst EA bits
00001218  4EB9 00001310            178              JSR EAGETDSTEA
0000121E                           179              
0000121E  4E75                     180              RTS
00001220                           181  MOVEW
00001220  22FC 4D4F5645            182              MOVE.L  #'MOVE',(A1)+
00001226  32FC 2E57                183              MOVE.W  #'.W',(A1)+
0000122A  5C41                     184              ADDQ    #6,D1               ; We added 6 new characters to our IOStringLoc 
0000122C                           185              
0000122C  22FC 20202020            186              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
00001232  5841                     187              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
00001234                           188              
00001234  2C05                     189              MOVE.L  D5,D6               ; Push D5 into D6
00001236  0286 0000003F            190              ANDI.L  #$003F,D6           ; Isolate the Src EA bits 
0000123C  4EB9 000012F8            191              JSR EAGETSRCEA              ; Find and print the code stored in D6
00001242                           192              
00001242  12FC 002C                193              MOVE.B  #',',(A1)+
00001246  5241                     194              ADDQ    #1,D1
00001248                           195              
00001248  2C05                     196              MOVE.L  D5,D6               ; Push D5 into D6
0000124A  EC8E                     197              LSR.L   #6,D6               ; Shift six bits to the right
0000124C  0286 0000003F            198              ANDI.L  #$003F,D6           ; Isolate the Dst EA bits
00001252  4EB9 00001310            199              JSR EAGETDSTEA
00001258                           200              
00001258  4E75                     201              RTS
0000125A                           202  MOVEL
0000125A  22FC 4D4F5645            203              MOVE.L  #'MOVE',(A1)+
00001260  32FC 2E4C                204              MOVE.W  #'.L',(A1)+
00001264  5C41                     205              ADDQ    #6,D1               ; We added 6 new characters to our IOStringLoc 
00001266                           206              
00001266  22FC 20202020            207              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
0000126C  5841                     208              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
0000126E                           209              
0000126E  2C05                     210              MOVE.L  D5,D6               ; Push D5 into D6
00001270  0286 0000003F            211              ANDI.L  #$003F,D6           ; Isolate the Src EA bits 
00001276  4EB9 000012F8            212              JSR EAGETSRCEA              ; Find and print the code stored in D6
0000127C                           213              
0000127C  12FC 002C                214              MOVE.B  #',',(A1)+
00001280  5241                     215              ADDQ    #1,D1
00001282                           216              
00001282  2C05                     217              MOVE.L  D5,D6               ; Push D5 into D6
00001284  EC8E                     218              LSR.L   #6,D6               ; Shift six bits to the right
00001286  0286 0000003F            219              ANDI.L  #$003F,D6           ; Isolate the Dst EA bits
0000128C  4EB9 00001310            220              JSR EAGETDSTEA
00001292                           221              
00001292  4E75                     222              RTS
00001294                           223         
00001294                           224  ; This label determines if the code is either MULS or AND, by looking at it's size bits     
00001294  2C05                     225  MULSAND     MOVE.L  D5,D6               ; Copy D5 into D6
00001296  EC8E                     226              LSR.L   #6,D6               ; Shift the size bits to the far right
00001298  0206 0003                227              ANDI.B  #$3,D6              ; Isolate the size bits
0000129C  BC3C 0003                228              CMP.B   #3,D6               ; See if the size is '11'..
000012A0  6704                     229              BEQ.S   MULS                ; ..If so, it's a MULS opcode
000012A2  6000 003A                230              BRA     AND                 ; Otherwise, it's an AND code
000012A6                           231          
000012A6  22FC 4D554C53            232  MULS        MOVE.L  #'MULS',(A1)+
000012AC  5841                     233              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000012AE                           234              
000012AE  22FC 20202020            235              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
000012B4  5841                     236              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
000012B6                           237              
000012B6  2C05                     238              MOVE.L  D5,D6               ; Copy D5 into D6
000012B8  0286 0000003F            239              ANDI.L  #$003F,D6           ; Isolate the Src EA bits
000012BE  4EB9 000012F8            240              JSR EAGETSRCEA
000012C4                           241              
000012C4  12FC 002C                242              MOVE.B  #',',(A1)+
000012C8  5241                     243              ADDQ    #1,D1
000012CA                           244              
000012CA  2C05                     245              MOVE.L  D5,D6               ; Copy D5 into D6
000012CC  E09E                     246              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
000012CE  E29E                     247              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
000012D0  0286 00000003            248              ANDI.L  #$0003,D6           ; Isolate the Dn Destination bits
000012D6  4EF9 00001324            249              JMP EADN
000012DC                           250              
000012DC  4E75                     251              RTS
000012DE                           252              
000012DE                           253  ; At this point, we know D6 is the size of our opcode
000012DE                           254  AND
000012DE                           255                   
000012DE  4E75                     256              RTS
000012E0                           257  UNKNOWN
000012E0  22FC 3F3F3F3F            258              MOVE.L  #'????',(A1)+
000012E6  5841                     259              ADDQ    #4,D1           ; We added 4 new characters to our IOStringLoc 
000012E8                           260              
000012E8  22FC 20202020            261              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
000012EE  5841                     262              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
000012F0  32FC 2020                263              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
000012F4  5441                     264              ADDQ    #2,D1               ; We added 2 bytes, aka 2 spaces
000012F6                           265          
000012F6  4E75                     266              RTS
000012F8                           267  
000012F8                           268  
000012F8                           269  
000012F8                           270  
000012F8                           271  
000012F8                           272  -------------------- end include --------------------
000012F8                           273      INCLUDE "EA.X68"        ; Handles EA types
000012F8                           274  
000012F8                           275  
000012F8                           276  ; It is assumed that D6 contains the bits for the EA, algined to the far right. D5 contains
000012F8                           277  ;  the original full op-code being reffered to. We assume that A2 contains the address 
000012F8                           278  ;  pointing to the start of our EA address (if applicable), and we assume that A1 contains
000012F8                           279  ;  the address pointing to our IOStringLoc. D1 contains the current length to be printed from A1
000012F8                           280  
000012F8                           281  ; For this method, D6 is in the format of: <3 bits Src Mode><3 bits Src Reg> 
000012F8                           282  EAGETSRCEA  
000012F8  E69E                     283      ROR.L   #3,D6       ; Rotate our bits 3 to the right
000012FA  1E06                     284      MOVE.B  D6,D7       ; Store the mode of the EA in D7
000012FC  E79E                     285      ROL.L   #3,D6       ; Rotate our 3 bits back
000012FE  0286 00000007            286      ANDI.L  #$0007,D6   ; Isolate the 3 rightmost bits as 'Reg'
00001304  BE3C 0000                287      CMP.B   #0,D7       ; See if the mode == '000'
00001308  6700 001A                288      BEQ     EADN
0000130C  6000 0024                289      BRA     EAUNKN
00001310                           290  
00001310                           291  ; For this method, D6 is in the format of: <3 bits Dst Reg><3 bits Dst Mode> 
00001310                           292  EAGETDSTEA  
00001310  1E06                     293      MOVE.B  D6,D7       ; Store the right-most byte into D7
00001312  CE3C 0007                294      AND.B   #$07,D7     ; Isolate 3 rightmost bits as 'Mode'
00001316  E68E                     295      LSR.L   #3,D6       ; Shift D6 to the right 3 bits (D6 Byte = 'Reg')
00001318  BE3C 0000                296      CMP.B   #0,D7       ; See if the mode == '000'
0000131C  6700 0006                297      BEQ     EADN
00001320  6000 0010                298      BRA     EAUNKN
00001324                           299           
00001324                           300  ;If the EA is a Dn EA    
00001324                           301  ;This method assume D6 contains the Reg for Dn  
00001324                           302  EADN
00001324  12FC 0044                303      MOVE.B  #'D',(A1)+
00001328  0606 0030                304      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
0000132C  12C6                     305      MOVE.B  D6,(A1)+
0000132E  5441                     306      ADDQ    #2,D1
00001330  4E75                     307      RTS
00001332                           308      
00001332                           309  ; If the EA is unknown
00001332                           310  EAUNKN
00001332  12FC 003C                311      MOVE.B  #'<',(A1)+  ; We did this byte-by-byte in case A1 is at an odd register
00001336  12FC 0045                312      MOVE.B  #'E',(A1)+
0000133A  12FC 0041                313      MOVE.B  #'A',(A1)+
0000133E  12FC 003E                314      MOVE.B  #'>',(A1)+
00001342  5841                     315      ADDQ    #4,D1
00001344  4E75                     316      RTS
00001346                           317  
00001346                           318  
00001346                           319  
00001346                           320  -------------------- end include --------------------
00001346                           321      
00001346  FFFF FFFF                322      SIMHALT             ; halt simulator
0000134A                           323  
0000134A                           324  * Put variables and constants here
0000134A                           325  
0000134A                           326      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AND                 12DE
CR                  D
EADN                1324
EAGETDSTEA          1310
EAGETSRCEA          12F8
EAUNKN              1332
HEXSTART            1139
INTROMSG            111C
IOASCIITOHEX        1030
IODIGIT             10E0
IODONE              1106
IOHEXTOASCII        10CC
IOINTRO             1000
IOLOOP              100C
IOORTAG             1042
IOSTRINGLOC         100
LF                  A
MOVEB               11E6
MOVEL               125A
MOVEW               1220
MULS                12A6
MULSAND             1294
OPGETCODE           11B6
OUTRO               11A7
RES                 1189
SPC                 1197
START               1000
STARTADDRESS        11B2
UNKEA               119D
UNKNOWN             12E0
