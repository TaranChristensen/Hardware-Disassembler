00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 3/9/2016 10:35:54 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Master
00000000                             3  * Written by : Circles
00000000                             4  * Date       : ##/##/16
00000000                             5  * Description: Project Master File
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * Put program code here
00001000                            11      INCLUDE "IO.X68"        ; Handles our input and output, as well as which address to refer to
00001000  47F9 00001404             12                  LEA     COUNTER,A3         initialize the COUNTER variable
00001006  26BC 00000000             13                  MOVE.L  #0,(A3)            clear the variable
0000100C                            14                  
0000100C                            15  
0000100C  5293                      16  IOINTRO         ADD.L   #$00000001,(A3)    COUNTER++
0000100E  43F9 00001238             17                  LEA     IntroMsg,A1        Display the intro
00001014  103C 000E                 18                  MOVE.B  #14, D0
00001018  4E4F                      19                  TRAP    #15
0000101A                            20  
0000101A  43F9 00001255             21  IOLOOP          LEA     HexStart,A1        Display the prompt and loop it
00001020  103C 000E                 22                  MOVE.B  #14,D0          
00001024  4E4F                      23                  TRAP    #15   
00001026  5493                      24                  ADD.L   #$00000002,(A3)    COUNTER++ COUNTER++
00001028                            25  
00001028                            26  
00001028  43F9 00000100             27                  LEA     IOStringLoc,A1     Store the string of our user input at StartAddress,A1 
0000102E  103C 0002                 28                  MOVE.B  #2,D0              uses Trap #15, Task 2
00001032  4E4F                      29                  TRAP    #15              
00001034                            30          
00001034  B2BC 00000001             31                  CMP.L   #1,D1              Compares D1 to the number 1 (eg. String length of 1)
0000103A  6700 01E6                 32                  BEQ     IODONE             Branch to DONE if they are equal
0000103E                            33          
0000103E  4284                      34                  CLR.L   D4                 Ensure our counter (D4) is 0 
00001040                            35  
00001040  4EB9 0000107C             36                  JSR     LENGTH_CHECK 
00001046  4282                      37                  CLR.L   D2  
00001048  BA3C 0001                 38                  CMP.B   #1,D5              if 1 then it passed the tests         
0000104C                            39                  
0000104C  6700 009A                 40                  BEQ     IOASCIItoHEX
00001050  60C8                      41                  BRA     IOLOOP
00001052                            42                  
00001052  0C93 0000001D             43  CHECK31         CMP.L   #$0000001D,(A3)    compare the counter to 29
00001058  6E00 0004                 44                  BGT     ENTERCHECK         counter is at at least 30
0000105C  4E75                      45                  RTS                        counter is still low
0000105E                            46  
0000105E  4280                      47  ENTERCHECK      CLR.L   D0
00001060  43F9 0000136E             48                  LEA     ENTERPROMPT,A1     display the enter prompt
00001066  103C 000E                 49                  MOVE.B  #14,D0
0000106A  4E4F                      50                  TRAP    #15
0000106C                            51                            
0000106C  103C 0002                 52                  MOVE.B  #2,D0              wait for the user to hit enter
00001070  4E4F                      53                  TRAP    #15
00001072                            54                  
00001072  26BC 00000000             55                  MOVE.L  #0,(A3)            clear the counter
00001078  5293                      56                  ADD.L   #$00000001,(A3)    COUNTER++
0000107A                            57               
0000107A  4E75                      58                  RTS
0000107C                            59                  
0000107C                            60  CLEARMEMORY     ***************************** a function to clear all data and address registers *****************************
0000107C                            61                  
0000107C  4285                      62  LENGTH_CHECK    CLR.L   D5                 store the result of the test
0000107E  7C00                      63                  MOVEQ   #$0,D6             make D6 0
00001080  B206                      64                  CMP.B   D6,D1              see if null
00001082  6700 0010                 65                  BEQ     BAD_LENGTH         if null then branch to bad input
00001086  0C41 0008                 66                  CMPI    #$8,D1             see if it is more than 8 characters long
0000108A  6E00 0008                 67                  BGT     BAD_LENGTH         if more than 8 branch to bad input
0000108E  1A3C 0001                 68                  MOVE.B  #$1,D5             passed the length checks so move 1
00001092  4E75                      69                  RTS                        go back
00001094                            70                  
00001094  7A00                      71  BAD_LENGTH      MOVEQ   #$0,D5             did not pass the test
00001096  43F9 00001328             72                  LEA     FAIL_INPUT,A1      load bad input message
0000109C  103C 000E                 73                  MOVE.B  #14,D0          
000010A0  4E4F                      74                  TRAP    #15 
000010A2  5293                      75                  ADD.L   #$00000001,(A3)    COUNTER++
000010A4  4E75                      76                  RTS                        go back
000010A6                            77                  
000010A6  43F9 000013B2             78  STARTLESSTHNEND LEA     STARTGTEND,A1      load the error 
000010AC  103C 000E                 79                  MOVE.B  #14,D0
000010B0  4E4F                      80                  TRAP    #15
000010B2  5293                      81                  ADD.L   #$00000001,(A3)    COUNTER++
000010B4  6000 FF64                 82                  BRA     IOLOOP             go back to the start
000010B8                            83  
000010B8                            84  
000010B8  4286                      85  TEST_ODD        CLR.L   D6           
000010BA  4285                      86                  CLR.L   D5
000010BC  7A02                      87                  MOVE.L  #$00000002,D5      divide by 2 to see remainder
000010BE  2C02                      88                  MOVE.L  D2,D6              create a copy of the input in D7
000010C0  8CC5                      89                  DIVU    D5,D6              divide the hex number by 2
000010C2  4846                      90                  SWAP    D6                 put the remainder on the far right
000010C4  BC3C 0001                 91                  CMP.B   #1,D6              see if the remainder is one
000010C8  6700 0008                 92                  BEQ     BAD_EVEN           branch to even
000010CC  4286                      93                  CLR.L   D6
000010CE  4285                      94                  CLR.L   D5
000010D0  4E75                      95                  RTS
000010D2                            96                  
000010D2                            97                  
000010D2  4285                      98  BAD_EVEN        CLR.L   D5
000010D4  4286                      99                  CLR.L   D6
000010D6  43F9 00001328            100                  LEA     FAIL_INPUT,A1      load bad input message  
000010DC  103C 000E                101                  MOVE.B  #14,D0          
000010E0  4E4F                     102                  TRAP    #15 
000010E2  5293                     103                  ADD.L   #$00000001,(A3)    COUNTER++
000010E4  6000 FF34                104                  BRA     IOLOOP             go back to the beginning
000010E8                           105                  
000010E8                           106  
000010E8  5244                     107  IOASCIItoHEX    ADDQ    #1,D4
000010EA  E98A                     108                  LSL.L   #4,D2              Scoot D2 a nybble
000010EC  1619                     109                  MOVE.B  (A1)+,D3           Move a Byte from A1's address to D3
000010EE  0403 0030                110                  SUB.B   #48,D3             Sub 48 to turn ASCII 0 into binary 0
000010F2  B63C 0009                111                  CMP.B   #9,D3              If our number is greater than 9..
000010F6  6F02                     112                  BLE.S   IOORTAG            .. it must be a character; A-F: 
000010F8  5F03                     113                  SUB.B   #7,D3              Sub 7 to turn A into 10
000010FA  8403                     114  IOORTAG         OR.B    D3,D2              Store our nybble into D2
000010FC  B204                     115                  CMP.B   D4,D1              See if we've read all the characters
000010FE  66E8                     116                  BNE.S   IOASCIItoHEX       Continue if we haven't
00001100                           117              
00001100                           118              
00001100  23FC 00000000 000013FC   119                  MOVE.L  #0,StartAddress
0000110A  23C2 000013FC            120                  MOVE.L  D2,StartAddress    Store our StartAddress
00001110                           121                  
00001110  4EB8 10B8                122                  JSR     TEST_ODD           test if the address is odd
00001114                           123                  
00001114  4281                     124                  CLR.L   D1
00001116  4282                     125                  CLR.L   D2
00001118                           126  
00001118                           127  
00001118  43F9 000012AB            128  ENDLOOP         LEA     HexEnd,A1          load the ending address prompt
0000111E  103C 000E                129                  MOVE.B  #14,D0
00001122  4E4F                     130                  TRAP    #15  
00001124  5493                     131                  ADD.L   #$00000002,(A3)
00001126                           132                  
00001126  43F9 00000100            133                  LEA     IOStringLoc,A1     Store the string of our user input at StartAddress,A1 
0000112C  103C 0002                134                  MOVE.B  #2,D0              uses Trap #15, Task 2
00001130  4E4F                     135                  TRAP    #15              
00001132                           136          
00001132  B2BC 00000001            137                  CMP.L   #1,D1              Compares D1 to the number 1 (eg. String length of 1)
00001138  6700 00E8                138                  BEQ     IODONE             Branch to DONE if they are equal
0000113C                           139          
0000113C  4284                     140                  CLR.L   D4                 Ensure our counter (D4) is 0 
0000113E                           141  
0000113E  4EB8 107C                142                  JSR     LENGTH_CHECK       check to make sure the length is ok
00001142  BA3C 0001                143                  CMP.B   #1,D5              if 1 then it passed the tests         
00001146                           144  
00001146  6700 0004                145                  BEQ     IOASCIItoHEX2      convert to hex
0000114A  60CC                     146                  BRA     ENDLOOP
0000114C                           147                  
0000114C  5244                     148  IOASCIItoHEX2   ADDQ    #1,D4
0000114E  E98A                     149                  LSL.L   #4,D2              Scoot D2 a nybble
00001150  1619                     150                  MOVE.B  (A1)+,D3           Move a Byte from A1's address to D3
00001152  0403 0030                151                  SUB.B   #48,D3             Sub 48 to turn ASCII 0 into binary 0
00001156  B63C 0009                152                  CMP.B   #9,D3              If our number is greater than 9..
0000115A  6F02                     153                  BLE.S   IOORTAG2           .. it must be a character; A-F: 
0000115C  5F03                     154                  SUB.B   #7,D3              Sub 7 to turn A into 10
0000115E  8403                     155  IOORTAG2        OR.B    D3,D2              Store our nybble into D2
00001160  B204                     156                  CMP.B   D4,D1              See if we've read all the characters
00001162  66E8                     157                  BNE.S   IOASCIItoHEX2      Continue if we haven't
00001164                           158              
00001164                           159    
00001164  23FC 00000000 00001400   160                  MOVE.L  #0,EndingAddress
0000116E  23C2 00001400            161                  MOVE.L  D2,EndingAddress   Store our EndingAddress
00001174                           162                  
00001174  4EB8 10B8                163                  JSR     TEST_ODD           tezt if the ending address is odd
00001178                           164                  
00001178  2479 000013FC            165                  MOVE.L  StartAddress,A2    Push our start address into A2
0000117E                           166                  
0000117E  B5F9 00001400            167                  CMP.L   EndingAddress,A2   compare the ending address with the startingaddress
00001184  6E00 FF20                168                  BGT     STARTLESSTHNEND    branch if the starting is greater than the ending
00001188                           169                  
00001188  4281                     170                  CLR.L   D1
0000118A                           171                  
0000118A  2479 000013FC            172                  MOVE.L  StartAddress,A2    Push our start address into A2 
00001190                           173                  
00001190                           174  
00001190  23FC 00000000 00000100   175  OUTPUTOPCODE    MOVE.L  #0,IOStringLoc     ********** Testing purposes ********** 
0000119A  4281                     176                  CLR.L   D1
0000119C                           177          
0000119C                           178  
0000119C  43F9 00000100            179                  LEA     IOStringLoc,A1     Load our IOStringLoc into A1 for string contruction purposes
000011A2                           180          
000011A2                           181                  ; Here we could loop all of the addresses of A2 until End, or something.
000011A2  2C0A                     182                  MOVE.L  A2,D6
000011A4  4244                     183                  CLR     D4
000011A6  4846                     184                  SWAP    D6
000011A8  4EB9 00001F02            185                  JSR     EAHEXtoASCII
000011AE  4244                     186                  CLR     D4
000011B0  4846                     187                  SWAP    D6
000011B2  4EB9 00001F02            188                  JSR     EAHEXtoASCII
000011B8  22FC 20202020            189                  MOVE.L  #'    ',(A1)+      Add a spacer into our IOStringLoc
000011BE  32FC 2020                190                  MOVE.W  #'  ',(A1)+      Add a spacer into our IOStringLoc
000011C2  5C41                     191                  ADDQ    #6,D1              We added 4 bytes, aka 4 spaces
000011C4                           192          
000011C4  4EB9 00001408            193                  JSR OPGETCODE              Get the OpCode pointed at by A2, it's string stored in IOStringLoc
000011CA                           194                  
000011CA  43F9 00000100            195                  LEA     IOStringLoc,A1     Now that we've populated the string, load it's beginning
000011D0  103C 0001                196                  MOVE.B  #1,D0              Trap task 1 prints a string at A1 with #D1 bytes.
000011D4  4E4F                     197                  TRAP    #15
000011D6                           198          
000011D6                           199                  ;LEA     UnkEA,A1          TEMPORARY Print "<EA>,<EA>"
000011D6                           200                  ;MOVE.B  #13,D0              
000011D6                           201                  ;TRAP    #15                 
000011D6                           202          
000011D6  43F9 0000130E            203                  LEA     SPC,A1             Puts the space before the opCode
000011DC  103C 000D                204                  MOVE.B  #13,D0
000011E0  4E4F                     205                  TRAP    #15
000011E2                           206                  
000011E2  5293                     207                  ADD.L   #$00000001,(A3)    COUNTER++
000011E4  4EB8 1052                208                  JSR     CHECK31
000011E8                           209                  
000011E8  B5F9 00001400            210                  CMP.L   EndingAddress,A2   compare the current address with the ending address
000011EE  6DA0                     211                  BLT     OUTPUTOPCODE       if the current is less than the ending keep looping
000011F0                           212                  
000011F0                           213  
000011F0                           214  
000011F0                           215  
000011F0                           216                  ; The following outputs the input, converting what we've saved in HEX to ASCII
000011F0                           217                  ; We won't need this in the final version, but the below code should be handy
000011F0                           218                  ;  for print out EA values
000011F0  2439 000013FC            219                  MOVE.L  StartAddress,D2    Ensure our address is actually at D2
000011F6  7208                     220                  MOVEQ   #8,D1              There are 8 characters in the hex of our address
000011F8  4284                     221                  CLR.L   D4                 Ensure our counter (D4) is 0
000011FA  43F9 00000100            222                  LEA     IOStringLoc,A1     Load our IO String location, to store our output at  
00001200                           223  
00001200                           224          
00001200  5244                     225  IOHEXtoASCII    ADDQ    #1,D4
00001202  E99A                     226                  ROL.L   #4,D2              Get the left-most nyblle to the front..
00001204  1602                     227                  MOVE.B  D2,D3              .. Put the front-most byte into D3    
00001206  C63C 000F                228                  AND.B   #$0F,D3            Distill D3 down to the original left-most nybble
0000120A  B63C 0009                229                  CMP.B   #9,D3              See if our number is greater than 9..
0000120E  6F00 0004                230                  BLE     IODIGIT            If it is 9 or less, it's a digit..
00001212  5E03                     231                  ADD.B   #7,D3              Otherwise it is a digit, and needs an additional 7
00001214  0603 0030                232  IODIGIT         ADD.B   #48,D3             We now how the nybble's ASCII code
00001218  12C3                     233                  MOVE.B  D3,(A1)+           Move the ASCII code into the output string at A1
0000121A  B204                     234                  CMP.B   D4,D1              See if we've read all the characters
0000121C  66E2                     235                  BNE.S   IOHEXtoASCII       Continue if we haven't
0000121E                           236          
0000121E                           237  
0000121E  6000 FDFA                238                  BRA     IOLOOP
00001222                           239          
00001222                           240        
00001222  43F9 0000131E            241  IODONE          LEA     OUTRO,A1           Display the ending message 
00001228  103C 000E                242                  MOVE.B  #14,D0
0000122C  4E4F                     243                  TRAP    #15
0000122E  103C 0009                244                  MOVE.B  #9,D0
00001232  4E4F                     245                  TRAP    #15                Halt Simulator
00001234                           246          
00001234  FFFF FFFF                247                  SIMHALT
00001238                           248          
00001238  =0000000D                249  CR              EQU     $0D         
00001238  =0000000A                250  LF              EQU     $0A 
00001238  =00000100                251  IOStringLoc     EQU     $0100              This is where we will store the string of the user input, and other strings
00001238                           252  
00001238                           253  
00001238= 54 65 61 6D 20 43 ...    254  IntroMsg        DC.B    'Team Circles Disassembler ',CR,LF,0     Intro
00001255= 45 6E 74 65 72 20 ...    255  HexStart        DC.B    'Enter a starting address in hex of length 8 or less and even, or',CR,LF,'type in 0 to quit: ',0 Prompt for the user
000012AB= 45 6E 74 65 72 20 ...    256  HexEnd          DC.B    'Enter an ending address in hex of length 8 or less and even, or',CR,LF,'type in 0 to quit: ',0 Prompt for the user
00001300= 59 6F 75 20 74 79 ...    257  RES             DC.B    'You typed in ',0                        Response to the user
0000130E= 20 20 20 20 20 00        258  SPC             DC.B    '     ',0                                tab
00001314= 3C 45 41 3E 2C 3C ...    259  UnkEA           DC.B    '<EA>,<EA>',0                            Interim message for unkown EAs.
0000131E= 47 6F 6F 64 62 79 ...    260  OUTRO           DC.B    'Goodbye !',0                            Outro message
00001328= 49 20 61 6D 20 73 ...    261  FAIL_INPUT      DC.B    'I am sorry, but you typed an address that did not meet the criteria',CR,LF,0 
0000136E= 54 68 65 20 73 63 ...    262  ENTERPROMPT     DC.B    'The screen limit has been reached, please press enter to continue',CR,LF,0
000013B2= 54 68 65 20 65 6E ...    263  STARTGTEND      DC.B    'The ending address was less than the starting address, please try again',CR,LF,0
000013FC                           264  
000013FC                           265  
000013FC                           266  StartAddress    DS.L    1
00001400                           267  EndingAddress   DS.L    1
00001404                           268  COUNTER         DS.L    1 keep track of the lines on the screen
00001408                           269  
00001408                           270  
00001408                           271  
00001408                           272  
00001408                           273  
00001408                           274  
00001408                           275  
00001408                           276  
00001408                           277  
00001408                           278  
00001408                           279  
00001408                           280  
00001408                           281  
00001408                           282  
00001408                           283  
00001408                           284  -------------------- end include --------------------
00001408                           285      INCLUDE "OpCode.X68"    ; Handles determining OpCodes
00001408                           286  
00001408                           287  
00001408                           288  ; Here we assume that A2 contains the address pointing to our OpCode, and
00001408                           289  ;  we assume that A1 contains the address pointing to our IOStringLoc
00001408  3A1A                     290  OPGETCODE   MOVE.W  (A2)+,D5    ; Push our OpCode into D5
0000140A  2C05                     291              MOVE.L  D5,D6       ; Also store the OpCode in D6
0000140C  E09E                     292              ROR.L   #8,D6       ; Rotate our OpCode to right-most nybble
0000140E  E89E                     293              ROR.L   #4,D6       ; 
00001410  0206 000F                294              ANDI.B  #$0F,D6     ; Isolate our opcode nybble
00001414  BC3C 0000                295              CMP.B   #$00,D6
00001418  6700 0066                296              BEQ     ADDI        ; ADDI 
0000141C  BC3C 0001                297              CMP.B   #$01,D6     
00001420  6700 010A                298              BEQ     MOVEB       ; MOVE.B
00001424  BC3C 0003                299              CMP.B   #$03,D6     
00001428  6700 0112                300              BEQ     MOVEW       ; MOVE.W
0000142C  BC3C 0002                301              CMP.B   #$02,D6
00001430  6700 011A                302              BEQ     MOVEL       ; MOVE.L
00001434  BC3C 0004                303              CMP.B   #$04,D6
00001438  6700 0150                304              BEQ     CNRJML      ; CLR or NOP or RTS or JSR or MOVEM or LEA
0000143C  BC3C 0006                305              CMP.B   #$06,D6
00001440  6700 0338                306              BEQ     Bcc         ; Bcc (BCC, BGT, BLE) 
00001444  BC3C 0007                307              CMP.B   #$07,D6
00001448  6700 03BE                308              BEQ     MOVEQ       ; MOVEQ 
0000144C  BC3C 0008                309              CMP.B   #$08,D6
00001450  6700 0408                310              BEQ     DIVU        ; DIVU
00001454  BC3C 0009                311              CMP.B   #$09,D6
00001458  6700 043C                312              BEQ     SUB         ; SUB
0000145C  BC3C 000B                313              CMP.B   #$0B,D6
00001460  6700 04DC                314              BEQ     CMP         ; CMP 
00001464  BC3C 000C                315              CMP.B   #$0C,D6
00001468  6700 0572                316              BEQ     MULSAND     ; MULS or AND opcodes
0000146C  BC3C 000D                317              CMP.B   #$0D,D6
00001470  6700 06B6                318              BEQ     ADDADDA     ; ADD or ADDA
00001474  BC3C 000E                319              CMP.B   #$0E,D6 
00001478  6700 07BA                320              BEQ     ASLSRO      ; ASd (ASR) or LSd (LSL) or ROd (ROL)
0000147C  6000 0926                321              BRA     UNKNOWN  
00001480                           322              
00001480                           323  ;  Here we assume the first left-most 4 bits have been confirmed: 0000
00001480  2C05                     324  ADDI        MOVE.L  D5,D6               ; Push D5 into D6
00001482  E09E                     325              ROR.L   #8,D6               ; Rotate left-most middle nybble to the right-most nybble
00001484  0206 000F                326              ANDI.B  #$0F,D6             ; Isolate opcode nybble
00001488  BC3C 0006                327              CMP.B   #$06,D6             ; If it matches ADDI's left-most middle nybble, branch
0000148C  6700 0006                328              BEQ     ADDI8               ; First 8 left-most bits of ADDI confirmed 
00001490  6000 0912                329              BRA     UNKNOWN             ; else unknown                       
00001494                           330  
00001494                           331  ;  Here we assume the first left-most 8 bits have been confirmed: 0000 0110            
00001494                           332  ADDI8                                  ; Two consecutive tests for illegal Src Modes
00001494  2C05                     333              MOVE.L  D5,D6              ; Push D5 into D6 
00001496  0286 0000003F            334              ANDI.L  #$003F,D6          ; Isolate the Src EA bits
0000149C  BCBC 0000003C            335              CMP.L   #$003C, D6         ; Compare with illegal mode #<data>
000014A2  6700 0900                336              BEQ     UNKNOWN
000014A6                           337              
000014A6  E69E                     338              ROR.L   #3,D6              ; Roll 3 bits right
000014A8  0286 00000007            339              ANDI.L  #$0007,D6          ; Isolate the 3 Src Mode bits
000014AE  BCBC 00000001            340              CMP.L   #$0001, D6         ; Compare with illegal mode An
000014B4  6700 08EE                341              BEQ     UNKNOWN
000014B8                           342              
000014B8                           343                                  
000014B8  2C05                     344              MOVE.L  D5,D6              ; Push D5 into D6 
000014BA  EC8E                     345              LSR.L   #6,D6              ; Shift six bits to the right
000014BC  0286 00000003            346              ANDI.L  #$0003,D6          ; Isolate the size bits
000014C2                           347                         
000014C2  BCBC 00000000            348              CMP.L   #$0000,D6          ; See if the size is '00'..
000014C8  6700 001A                349              BEQ     ADDIB              ; ..If so, it's ANDI.B
000014CC  BCBC 00000001            350              CMP.L   #$0001,D6          ; See if the size is '01'..
000014D2  6700 0020                351              BEQ     ADDIW              ; ..If so, it's ANDI.W
000014D6  BCBC 00000002            352              CMP.L   #$0002,D6          ; See if the size is '10'..
000014DC  6700 0026                353              BEQ     ADDIL              ; ..If so, it's ANDI.L
000014E0                           354              
000014E0  6000 08C2                355              BRA     UNKNOWN            ; If it isn't any, then it's Unknown
000014E4                           356              
000014E4                           357  ADDIB       
000014E4  22FC 41444449            358              MOVE.L  #'ADDI',(A1)+
000014EA  32FC 2E42                359              MOVE.W  #'.B',(A1)+
000014EE  5C41                     360              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc
000014F0  6000 0022                361              BRA     ADDIOP
000014F4                           362              
000014F4                           363  ADDIW       
000014F4  22FC 41444449            364              MOVE.L  #'ADDI',(A1)+
000014FA  32FC 2E57                365              MOVE.W  #'.W',(A1)+
000014FE  5C41                     366              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
00001500  6000 0012                367              BRA     ADDIOP
00001504                           368              
00001504                           369  ADDIL      
00001504  22FC 41444449            370              MOVE.L  #'ADDI',(A1)+
0000150A  32FC 2E4C                371              MOVE.W  #'.L',(A1)+
0000150E  5C41                     372              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
00001510  6000 0002                373              BRA     ADDIOP
00001514                           374  
00001514  22FC 20202020            375  ADDIOP      MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
0000151A  5841                     376              ADDQ    #4,D1              ; We added 4 bytes, aka 4 spaces
0000151C                           377              
0000151C  2C05                     378              MOVE.L  D5,D6              ; Push D5 into D6
0000151E  0286 0000003F            379              ANDI.L  #$003F,D6          ; Isolate the Src EA bits 
00001524  4EB9 00001DC8            380              JSR EAGETSRCEA             ; Find and print the code stored in D6 
0000152A  4E75                     381              RTS
0000152C                           382                
0000152C  22FC 4D4F5645            383  MOVEB       MOVE.L  #'MOVE',(A1)+
00001532  32FC 2E42                384              MOVE.W  #'.B',(A1)+
00001536  5C41                     385              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
00001538                           386              
00001538  6000 0022                387              BRA MOVEOP
0000153C                           388              
0000153C  22FC 4D4F5645            389  MOVEW       MOVE.L  #'MOVE',(A1)+
00001542  32FC 2E57                390              MOVE.W  #'.W',(A1)+
00001546  5C41                     391              ADDQ    #6,D1               ; We added 6 new characters to our IOStringLoc 
00001548                           392              
00001548  6000 0012                393              BRA MOVEOP
0000154C                           394              
0000154C  22FC 4D4F5645            395  MOVEL       MOVE.L  #'MOVE',(A1)+
00001552  32FC 2E4C                396              MOVE.W  #'.L',(A1)+
00001556  5C41                     397              ADDQ    #6,D1               ; We added 6 new characters to our IOStringLoc 
00001558                           398              
00001558  6000 0002                399              BRA MOVEOP
0000155C                           400              
0000155C  22FC 20202020            401  MOVEOP      MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
00001562  5841                     402              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
00001564                           403              
00001564  2C05                     404              MOVE.L  D5,D6               ; Push D5 into D6
00001566  0286 0000003F            405              ANDI.L  #$003F,D6           ; Isolate the Src EA bits 
0000156C  4EB9 00001DC8            406              JSR EAGETSRCEA              ; Find and print the code stored in D6
00001572                           407              
00001572  12FC 002C                408              MOVE.B  #',',(A1)+
00001576  5241                     409              ADDQ    #1,D1
00001578                           410              
00001578  2C05                     411              MOVE.L  D5,D6               ; Push D5 into D6
0000157A  EC8E                     412              LSR.L   #6,D6               ; Shift six bits to the right
0000157C  0286 0000003F            413              ANDI.L  #$003F,D6           ; Isolate the Dst EA bits
00001582  4EB9 00001E08            414              JSR EAGETDSTEA
00001588  4E75                     415              RTS
0000158A                           416              
0000158A                           417  ; This label determines if the code is either CLR or NOP or RTS or JSR or MOVEM or LEA
0000158A                           418  ; Here we assume that the first left-most four bits equal 0100            
0000158A                           419  CNRJML      
0000158A  2C05                     420              MOVE.L  D5,D6              ; Push D5 into D6 (Copy OPcode over isolated nybble)
0000158C                           421              
0000158C                           422              *NOP & RTS's machine code is uniquely hardcoded, check first
0000158C  BCBC 00004E71            423              CMP.L   #$4E71,D6          ; See if the OPcode matches NOP's hardcode
00001592  6700 00CA                424              BEQ     NOP
00001596  BCBC 00004E75            425              CMP.L   #$4E75,D6          ; See if the OPcode matches RTS's hardcode
0000159C  6700 00DA                426              BEQ     RTS
000015A0                           427                                         ; CLR's middle most left nybble is unique (0010)
000015A0  E09E                     428              ROR.L   #8,D6              ; Rotate our OpCode to right-most nybble
000015A2  0206 000F                429              ANDI.B  #$0F,D6            ; Isolate our opcode nybble
000015A6  BC3C 0002                430              CMP.B   #$02,D6            ; See if matches nybble
000015AA  6700 0026                431              BEQ     CLR               
000015AE                           432              
000015AE  2C05                     433              MOVE.L  D5,D6              ; Push D5 into D6
000015B0  E08E                     434              LSR.L   #8,D6              ; Shift 8 bits to the right
000015B2                           435              
000015B2  0806 0000                436              BTST    #$00,D6            ; See if our right-most bit is set
000015B6  6600 0180                437              BNE     LEA                ; If our bit is set, branch to LEA     
000015BA                           438              
000015BA  E28E                     439              LSR.L   #1,D6              ; Shift another bit
000015BC  0806 0000                440              BTST    #$00,D6            ; See if our right-most bit is set
000015C0  6600 00D0                441              BNE     JSR                ; If this one is set, branch to JSR
000015C4                           442                 
000015C4                           443                                         ; MOVEM's middle most left nybble is unique (1-00)
000015C4  E49E                     444              ROR.L   #2,D6              ; first bit must be 0, rotate 1 bit 
000015C6  0806 0000                445              BTST    #0,D6               ; Compare again for 00 match
000015CA  6600 00F0                446              BNE     MOVEM                           
000015CE                           447                                         
000015CE  6000 07D4                448              BRA     UNKNOWN            ; If it doesnt any match, then it's Unknown
000015D2                           449  
000015D2                           450  
000015D2                           451  ;  Here we assume the first left-most 8 bits have been confirmed: 0100 0010
000015D2                           452  CLR         
000015D2  2C05                     453              MOVE.L  D5,D6              ; Push D5 into D6
000015D4  EC8E                     454              LSR.L   #6,D6              ; Shift six bits to the right
000015D6  0286 00000003            455              ANDI.L  #$0003,D6          ; Isolate the two size bits
000015DC                           456                         
000015DC  BCBC 00000000            457              CMP.L   #$0000,D6          ; See if the size is '00'..
000015E2  6700 001A                458              BEQ     CLRB               ; ..If so, it's CLR.B
000015E6  BCBC 00000001            459              CMP.L   #$0001,D6          ; See if the size is '01'..
000015EC  6700 0026                460              BEQ     CLRW               ; ..If so, it's CLR.W
000015F0  BCBC 00000002            461              CMP.L   #$0002,D6          ; See if the size is '10'..
000015F6  6700 0032                462              BEQ     CLRL               ; ..If so, it's CLR.L
000015FA                           463              
000015FA  6000 07A8                464              BRA     UNKNOWN            ; If it isn't any, then it's Unknown
000015FE                           465              
000015FE  32FC 434C                466  CLRB        MOVE.W  #'CL',(A1)+
00001602  12FC 0052                467              MOVE.B  #'R',(A1)+
00001606  12FC 002E                468              MOVE.B  #'.',(A1)+
0000160A  12FC 0042                469              MOVE.B  #'B',(A1)+
0000160E  5A41                     470              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
00001610  6000 002E                471              BRA     CLROP
00001614                           472              
00001614  32FC 434C                473  CLRW        MOVE.W  #'CL',(A1)+
00001618  12FC 0052                474              MOVE.B  #'R',(A1)+
0000161C  12FC 002E                475              MOVE.B  #'.',(A1)+
00001620  12FC 0057                476              MOVE.B  #'W',(A1)+
00001624  5A41                     477              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
00001626  6000 0018                478              BRA     CLROP
0000162A                           479  
0000162A  32FC 434C                480  CLRL        MOVE.W  #'CL',(A1)+
0000162E  12FC 0052                481              MOVE.B  #'R',(A1)+
00001632  12FC 002E                482              MOVE.B  #'.',(A1)+
00001636  12FC 004C                483              MOVE.B  #'L',(A1)+
0000163A  5A41                     484              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
0000163C  6000 0002                485              BRA     CLROP
00001640                           486              
00001640  12FC 0020                487  CLROP       MOVE.B  #' ',(A1)+
00001644  32FC 2020                488              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
00001648  32FC 2020                489              MOVE.W  #'  ',(A1)+
0000164C  5A41                     490              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces
0000164E                           491              
0000164E  2C05                     492              MOVE.L  D5,D6              ; Push D5 into D6
00001650  0286 0000003F            493              ANDI.L  #$003F,D6          ; Isolate the Src EA bits 
00001656  4EB9 00001DC8            494              JSR EAGETSRCEA             ; Find and print the code stored in D6
0000165C                           495  
0000165C  4E75                     496              RTS
0000165E                           497              
0000165E                           498  ;  Here we assume that all 16 bits have been confirmed 
0000165E                           499  NOP
0000165E  32FC 4E4F                500              MOVE.W  #'NO',(A1)+
00001662  12FC 0050                501              MOVE.B  #'P',(A1)+
00001666  5641                     502              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
00001668                           503              
00001668  12FC 0020                504              MOVE.B  #' ',(A1)+       ; Add a spacer into our IOStringLoc
0000166C  32FC 2020                505              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
00001670  32FC 2020                506              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
00001674  5A41                     507              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces        
00001676  4E75                     508              RTS
00001678                           509  
00001678                           510  ;  Here we assume that all 16 bits have been confirmed            
00001678                           511  RTS         
00001678  32FC 5254                512              MOVE.W  #'RT',(A1)+
0000167C  12FC 0053                513              MOVE.B  #'S',(A1)+
00001680  5641                     514              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
00001682                           515              
00001682  12FC 0020                516              MOVE.B  #' ',(A1)+       ; Add a spacer into our IOStringLoc
00001686  32FC 2020                517              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
0000168A  32FC 2020                518              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
0000168E  5A41                     519              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces        
00001690  4E75                     520              RTS
00001692                           521              
00001692                           522  
00001692                           523  ;  Here we assume the first left-most 10 bits have been confirmed: 0100 1110 10 
00001692                           524  JSR         
00001692  32FC 4A53                525              MOVE.W  #'JS',(A1)+
00001696  12FC 0052                526              MOVE.B  #'R',(A1)+
0000169A  5641                     527              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
0000169C                           528              
0000169C  12FC 0020                529              MOVE.B  #' ',(A1)+
000016A0  32FC 2020                530              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
000016A4  22FC 20202020            531              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
000016AA  5E41                     532              ADDQ    #7,D1              ; We added 4 bytes, aka 4 spaces
000016AC  2C05                     533              MOVE.L  D5,D6              ; Push D5 into D6
000016AE                           534              
000016AE  0286 0000003F            535              ANDI.L  #$003F,D6          ; Isolate the Src EA bits 
000016B4  4EB9 00001DC8            536              JSR EAGETSRCEA             ; Find and print the code stored in D6 
000016BA  4E75                     537              RTS
000016BC                           538              
000016BC                           539  
000016BC                           540  ;  Here we assume that these left-most bits have been confirmed, where - have not been confirmed: 0100 --00
000016BC                           541  MOVEM       
000016BC  22FC 4D4F5645            542              MOVE.L  #'MOVE',(A1)+
000016C2  32FC 4D2E                543              MOVE.W  #'M.',(A1)+
000016C6  5C41                     544              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
000016C8                           545              
000016C8  2C05                     546              MOVE.L  D5,D6              ; Copy our OpCode
000016CA  EC8E                     547              LSR.L   #6,D6              ; Shift it 6 bits to the right
000016CC  0806 0000                548              BTST    #$00,D6            ; If our size bit is 0..
000016D0  6700 0006                549              BEQ     MOVEMW             ; .. Its a MOVEM of size W
000016D4  6000 000C                550              BRA     MOVEML             ; .. Otherwise it's of size L
000016D8                           551  
000016D8  12FC 0057                552  MOVEMW      MOVE.B  #'W',(A1)+
000016DC  5241                     553              ADDQ    #1,D1              ; We've added another character into IOStringLoc
000016DE  6000 0008                554              BRA     MOVEMOP            ; MovemOp label, to skip MovemL label
000016E2                           555              
000016E2  12FC 004C                556  MOVEML      MOVE.B  #'L',(A1)+
000016E6  5241                     557              ADDQ    #1,D1              ; We've added another character into IOStringLoc
000016E8                           558              
000016E8  12FC 0020                559  MOVEMOP     MOVE.B  #' ',(A1)+         ; Add a spacer into our IOStringLoc
000016EC  32FC 2020                560              MOVE.W  #'  ',(A1)+        ;
000016F0  5641                     561              ADDQ    #3,D1              ; We added 4 bytes, aka 4 spaces 
000016F2                           562              
000016F2  E88E                     563              LSR.L   #4,D6              ; Shift our OpCode 4 bits to the left of Size (going to the right)
000016F4  0806 0000                564              BTST    #$00,D6            ; Check our Direction bit
000016F8  6700 0006                565              BEQ     MOVEMPRED          ; If it's 0, our direction is Pre Decrement (eg. Move TO the stack)
000016FC  6000 001E                566              BRA     MOVEMPOSTI         ; Otherwise, it's Post Increment (eg. Move FROM the stack)
00001700                           567              
00001700                           568  MOVEMPRED   ; This part is where we get the gross A0-A6/D0-D7 part
00001700  4EB9 00002010            569              JSR     EAMOVEMPRED  
00001706                           570              
00001706  12FC 002C                571              MOVE.B  #',',(A1)+
0000170A  5241                     572              ADDQ    #1,D1
0000170C                           573              
0000170C  2C05                     574              MOVE.L  D5,D6              ; Copy our OpCode to D6
0000170E  0286 0000003F            575              ANDI.L  #$3F,D6            ; Isolate our EA src bits
00001714                           576              
00001714  4EB9 00001DC8            577              JSR EAGETSRCEA  
0000171A                           578            
0000171A  4E75                     579              RTS
0000171C                           580  
0000171C  2C05                     581  MOVEMPOSTI  MOVE.L  D5,D6              ; Copy our OpCode to D6
0000171E  0286 0000003F            582              ANDI.L  #$3F,D6            ; Isolate our EA src bits
00001724                           583              
00001724  4EB9 00001DC8            584              JSR EAGETSRCEA  
0000172A                           585              
0000172A  12FC 002C                586              MOVE.B  #',',(A1)+
0000172E  5241                     587              ADDQ    #1,D1
00001730                           588              
00001730                           589              ; This part is where we get the gross A0-A6/D0-D7 part
00001730  4EB9 00001F26            590              JSR     EAMOVEMPOSTI
00001736                           591              
00001736  4E75                     592              RTS
00001738                           593              
00001738                           594  
00001738                           595  ;  Here we assume that these left-most bits have been confirmed, where - have not been confirmed: 0100 ---1            
00001738                           596  LEA
00001738  32FC 4C45                597              MOVE.W  #'LE',(A1)+
0000173C  12FC 0041                598              MOVE.B  #'A',(A1)+
00001740  5641                     599              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
00001742                           600               
00001742  12FC 0020                601              MOVE.B  #' ',(A1)+          ; Added an extra space here, due to only 3 character OpCode
00001746  22FC 20202020            602              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
0000174C  32FC 2020                603              MOVE.W  #'  ',(A1)+ 
00001750  5E41                     604              ADDQ    #7,D1               ; We added 4 bytes, aka 4 spaces
00001752                           605              
00001752  2C05                     606              MOVE.L  D5,D6               ; Copy D5 into D6
00001754  0286 0000003F            607              ANDI.L  #$003F,D6           ; Isolate the Src EA bits
0000175A  4EB9 00001DC8            608              JSR EAGETSRCEA
00001760                           609              
00001760  12FC 002C                610              MOVE.B  #',',(A1)+
00001764  5241                     611              ADDQ    #1,D1
00001766                           612              
00001766  2C05                     613              MOVE.L  D5,D6               ; Copy D5 into D6
00001768  E09E                     614              ROR.L   #8,D6               ; Rotate 9 bits to the right (An Dst bits)
0000176A  E29E                     615              ROR.L   #1,D6               ; 
0000176C  0286 00000003            616              ANDI.L  #$0003,D6           ; Isolate the An Destination bits
00001772  4EF9 00001E52            617              JMP EAAN
00001778  4E75                     618              RTS      
0000177A                           619              
0000177A  2C05                     620  Bcc         MOVE.L  D5,D6               ; Copy our OpCode into D6
0000177C  E15E                     621              ROL.W   #8,D6               ; Rotate our condition bit into place
0000177E  0206 000F                622              ANDI.B  #$0F,D6             ; Isolate the right-most nybble (condition)
00001782                           623              
00001782  BC3C 0004                624              CMP.B   #%0100,D6           ; See if our Condition is '0100'
00001786  6700 0016                625              BEQ     BCCOP               ; If it is, we have a BCC operation
0000178A  BC3C 000E                626              CMP.B   #%1110,D6           ; See if our Condition is '1110'
0000178E  6700 001C                627              BEQ     BGTOP               ; If it is, we have a BGT operation
00001792  BC3C 000F                628              CMP.B   #%1111,D6           ; See if our Condition is '1111'
00001796  6700 0022                629              BEQ     BLEOP               ; If it is, we have a BLE operation
0000179A                           630              
0000179A  6000 0608                631              BRA     UNKNOWN             ; Otherwise we don't know what kind of operation we have
0000179E                           632              
0000179E  32FC 4243                633  BCCOP       MOVE.W  #'BC',(A1)+
000017A2  12FC 0043                634              MOVE.B  #'C',(A1)+
000017A6  5641                     635              ADDQ    #3,D1               ; We've added three characters into our IOStringLoc
000017A8  6000 001E                636              BRA     BccSIZE             ; Branch to find our Bcc Op's Size
000017AC                           637              
000017AC  32FC 4247                638  BGTOP       MOVE.W  #'BG',(A1)+
000017B0  12FC 0054                639              MOVE.B  #'T',(A1)+
000017B4  5641                     640              ADDQ    #3,D1               ; We've added three characters into our IOStringLoc
000017B6  6000 0010                641              BRA     BccSIZE             ; Branch to find our Bcc Op's Size
000017BA                           642              
000017BA  32FC 424C                643  BLEOP       MOVE.W  #'BL',(A1)+
000017BE  12FC 0045                644              MOVE.B  #'E',(A1)+
000017C2  5641                     645              ADDQ    #3,D1               ; We've added three characters into our IOStringLoc
000017C4  6000 0002                646              BRA     BccSIZE             ; Branch to find our Bcc Op's Size
000017C8                           647  
000017C8                           648  BccSIZE     ; Find Displacement value
000017C8                           649              ; Branch to proper displacement value label
000017C8                           650              ; Store the value of A2 into D7
000017C8                           651              ; Get our total displacement into D6
000017C8                           652              ; Print the new address as D7 +/- D6
000017C8                           653              
000017C8  12FC 0020                654              MOVE.B  #' ',(A1)+       ; Add a spacer into our IOStringLoc
000017CC  32FC 2020                655              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
000017D0  32FC 2020                656              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
000017D4  5A41                     657              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces   
000017D6                           658              
000017D6  12FC 0024                659              MOVE.B  #'$',(A1)+
000017DA  5241                     660              ADDQ    #1,D1
000017DC                           661              
000017DC  2C05                     662              MOVE.L  D5,D6
000017DE  0286 000000FF            663              ANDI.L  #$FF,D6             ; Isolate our Size bits
000017E4  BC3C 0000                664              CMP.B   #$00,D6             ; If it's equal to $00..
000017E8  6700 001C                665              BEQ     Bcc16               ; .. It has a 16 bit displacement
000017EC  0286 000000FF            666              ANDI.L  #$FF,D6             ; If it's equal to $FF..
000017F2  6700 0012                667              BEQ     Bcc32               ; .. It has a 32 bit displacement
000017F6                           668              ; Otherwise, it's an 8 bit displacement
000017F6                           669              
000017F6  2E0A                     670              MOVE.L  A2,D7
000017F8  9E46                     671              SUB.W   D6,D7 
000017FA                           672              
000017FA  2C07                     673              MOVE.L  D7,D6
000017FC  4244                     674              CLR     D4
000017FE  4EB9 00001F02            675              JSR     EAHEXtoASCII
00001804                           676              
00001804  4E75                     677              RTS 
00001806                           678              
00001806                           679  Bcc16
00001806                           680  
00001806                           681  Bcc32
00001806                           682              
00001806  4E75                     683              RTS           
00001808                           684  MOVEQ
00001808  22FC 4D4F5645            685              MOVE.L  #'MOVE',(A1)+
0000180E  12FC 0051                686              MOVE.B  #'Q',(A1)+
00001812  5A41                     687              ADDQ    #5,D1               ; We added 4 new characters to our IOStringLoc
00001814                           688              
00001814  12FC 0020                689              MOVE.B  #' ',(A1)+
00001818  32FC 2020                690              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
0000181C  32FC 2020                691              MOVE.W  #'  ',(A1)+
00001820  5841                     692              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
00001822                           693              
00001822  2C05                     694              MOVE.L  D5,D6               ; Copy D5 into D6
00001824  0286 000000FF            695              ANDI.L  #$00FF,D6           ; Isolate the Src EA bits
0000182A                           696              
0000182A  12FC 0023                697              MOVE.B  #'#',(A1)+
0000182E  12FC 0024                698              MOVE.B  #'$',(A1)+
00001832  5241                     699              ADDQ    #1,D1               ; We added 4 bytes, aka 4 spaces
00001834  183C 0002                700              MOVE.B  #2,D4               ; "Start" at 2 characters
00001838  E19E                     701              ROL.L   #$8,D6
0000183A  4EB9 00001F02            702              JSR     EAHEXtoASCII
00001840                           703              
00001840  12FC 002C                704              MOVE.B  #',',(A1)+
00001844  5241                     705              ADDQ    #1,D1
00001846                           706              
00001846  2C05                     707              MOVE.L  D5,D6               ; Copy D5 into D6
00001848  E09E                     708              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
0000184A  E29E                     709              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
0000184C  0286 00000007            710              ANDI.L  #$0007,D6           ; Isolate the Dn Destination bits
00001852  4EF9 00001E44            711              JMP EADN
00001858                           712              
00001858  4E75                     713              RTS 
0000185A                           714              
0000185A                           715  DIVU 
0000185A  22FC 44495655            716              MOVE.L  #'DIVU',(A1)+
00001860  5841                     717              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001862                           718              
00001862  22FC 20202020            719              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
00001868  32FC 2020                720              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
0000186C  5C41                     721              ADDQ    #6,D1               ; We added 4 bytes, aka 4 spaces
0000186E                           722              
0000186E  2C05                     723              MOVE.L  D5,D6               ; Copy D5 into D6
00001870  0286 0000003F            724              ANDI.L  #$003F,D6           ; Isolate the Src EA bits
00001876  4EB9 00001DC8            725              JSR EAGETSRCEA
0000187C                           726              
0000187C  12FC 002C                727              MOVE.B  #',',(A1)+
00001880  5241                     728              ADDQ    #1,D1
00001882                           729              
00001882  2C05                     730              MOVE.L  D5,D6               ; Copy D5 into D6
00001884  E09E                     731              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00001886  E29E                     732              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00001888  0286 00000007            733              ANDI.L  #$0007,D6           ; Isolate the Dn Destination bits
0000188E  4EF9 00001E44            734              JMP EADN
00001894                           735              
00001894  4E75                     736              RTS
00001896                           737  
00001896                           738              
00001896  2C05                     739  SUB         MOVE.L  D5,D6               ; Copy D5 into D6
00001898  EC8E                     740              LSR.L   #6,D6               ; Shift the size bits to the far right
0000189A  0206 0007                741              ANDI.B  #$7,D6              ; Isolate the size bits    
0000189E                           742                   
0000189E  BC3C 0006                743              CMP.B   #%0110,D6            ; See if D6 is size "%100" through "%110"..
000018A2  6700 002E                744              BEQ     SUBLEA              ; If it is, our OpCode is in the format of..
000018A6  BC3C 0005                745              CMP.B   #%101,D6            ; .. Dn ~ <EA> --> <EA>
000018AA  6700 0038                746              BEQ     SUBWEA
000018AE  BC3C 0004                747              CMP.B   #%100,D6
000018B2  6700 0042                748              BEQ     SUBBEA
000018B6                           749              
000018B6  BC3C 0002                750              CMP.B   #%10,D6             ; See if D6 is size "%000" through "%010"..
000018BA  6700 004C                751              BEQ     SUBLDN              ; If it is, our OpCode is in the format of..
000018BE  BC3C 0001                752              CMP.B   #%01,D6             ; .. <EA> ~ Dn --> Dn
000018C2  6700 0056                753              BEQ     SUBWDN
000018C6  BC3C 0000                754              CMP.B   #%00,D6
000018CA  6700 0060                755              BEQ     SUBBDN              ; == 000 at this point
000018CE                           756              
000018CE  6000 04D4                757              BRA     UNKNOWN
000018D2                           758              
000018D2  22FC 5355422E            759  SUBLEA      MOVE.L  #'SUB.',(A1)+
000018D8  5841                     760              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000018DA  12FC 004C                761              MOVE.B  #'L',(A1)+
000018DE  5241                     762              ADDQ    #1,D1               ; We added 1 byte into D1
000018E0  6000 01AC                763              BRA     ANDEA
000018E4                           764              
000018E4  22FC 5355422E            765  SUBWEA      MOVE.L  #'SUB.',(A1)+
000018EA  5841                     766              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000018EC  12FC 0057                767              MOVE.B  #'W',(A1)+
000018F0  5241                     768              ADDQ    #1,D1               ; We added 1 byte into D1
000018F2  6000 019A                769              BRA     ANDEA
000018F6                           770  
000018F6  22FC 5355422E            771  SUBBEA      MOVE.L  #'SUB.',(A1)+
000018FC  5841                     772              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000018FE  12FC 0042                773              MOVE.B  #'B',(A1)+
00001902  5241                     774              ADDQ    #1,D1               ; We added 1 byte into D1
00001904  6000 0188                775              BRA     ANDEA
00001908                           776  
00001908  22FC 5355422E            777  SUBLDN      MOVE.L  #'SUB.',(A1)+
0000190E  5841                     778              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001910  12FC 004C                779              MOVE.B  #'L',(A1)+
00001914  5241                     780              ADDQ    #1,D1               ; We added 1 byte into D1
00001916  6000 01E2                781              BRA ANDDN
0000191A                           782              
0000191A  22FC 5355422E            783  SUBWDN      MOVE.L  #'SUB.',(A1)+
00001920  5841                     784              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001922  12FC 0057                785              MOVE.B  #'W',(A1)+
00001926  5241                     786              ADDQ    #1,D1               ; We added 1 byte into D1
00001928  6000 01D0                787              BRA ANDDN
0000192C                           788  
0000192C  22FC 5355422E            789  SUBBDN      MOVE.L  #'SUB.',(A1)+
00001932  5841                     790              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001934  12FC 0042                791              MOVE.B  #'B',(A1)+
00001938  5241                     792              ADDQ    #1,D1               ; We added 1 byte into D1
0000193A  6000 01BE                793              BRA ANDDN  
0000193E                           794  
0000193E                           795  ;  Here we assume that these left-most nybble has been confirmed: 1011  
0000193E                           796  CMP        
0000193E  2C05                     797              MOVE.L  D5,D6               ; Push D5 into D6
00001940  EC9E                     798              ROR.L   #6,D6               ; Rotate 6 bits to the right
00001942  E38E                     799              LSL.L   #1,D6               ; Add 0 to right most bit
00001944  0206 000F                800              ANDI.B  #$0F,D6             ; Isolate right-most nybble
00001948                           801              
00001948  BC3C 0000                802              CMP.B   #$00,D6             ; If it matches CMP.B's size bit + 0 added to right
0000194C  6700 0016                803              BEQ     CMPB                ; First 4 left-most bits plus size of CMP confirmed
00001950                           804  
00001950  BC3C 0002                805              CMP.B   #$02,D6             ; If it matches CMP.W's size bit + 0 added to right
00001954  6700 0024                806              BEQ     CMPW                ; First 4 left-most bits plus size of CMP confirmed 
00001958                           807  
00001958  BC3C 0004                808              CMP.B   #$04,D6             ; If it matches CMP.B's size bit + 0 added to right
0000195C  6700 0032                809              BEQ     CMPL                ; First 4 left-most bits plus size of CMP confirmed 
00001960                           810   
00001960  6000 0442                811              BRA     UNKNOWN             ; else unknown 
00001964                           812  
00001964                           813  ;  Here we assume that confirming these bits, 1011 --- 000 --- ---, is enough to identify CMP.B 
00001964  32FC 434D                814  CMPB        MOVE.W  #'CM',(A1)+
00001968  12FC 0050                815              MOVE.B  #'P',(A1)+
0000196C  12FC 002E                816              MOVE.B  #'.',(A1)+
00001970  12FC 0042                817              MOVE.B  #'B',(A1)+
00001974  5A41                     818              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
00001976  6000 002E                819              BRA     CMPOP
0000197A                           820  
0000197A                           821  ;  Here we assume that confirming these bits, 1011 --- 001 --- ---, is enough to identify CMP.W   
0000197A  32FC 434D                822  CMPW        MOVE.W  #'CM',(A1)+
0000197E  12FC 0050                823              MOVE.B  #'P',(A1)+
00001982  12FC 002E                824              MOVE.B  #'.',(A1)+
00001986  12FC 0057                825              MOVE.B  #'W',(A1)+
0000198A  5A41                     826              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
0000198C  6000 0018                827              BRA     CMPOP
00001990                           828              
00001990                           829  ;  Here we assume that confirming these bits, 1011 --- 010 --- ---, is enough to identify CMP.L
00001990  32FC 434D                830  CMPL        MOVE.W  #'CM',(A1)+
00001994  12FC 0050                831              MOVE.B  #'P',(A1)+
00001998  12FC 002E                832              MOVE.B  #'.',(A1)+
0000199C  12FC 004C                833              MOVE.B  #'L',(A1)+
000019A0  5A41                     834              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
000019A2  6000 0002                835              BRA     CMPOP
000019A6                           836              
000019A6  12FC 0020                837  CMPOP       MOVE.B  #' ',(A1)+
000019AA  32FC 2020                838              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
000019AE  32FC 2020                839              MOVE.W  #'  ',(A1)+
000019B2  5A41                     840              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces
000019B4                           841              
000019B4  2C05                     842              MOVE.L  D5,D6               ; Push D5 into D6
000019B6  0286 0000003F            843              ANDI.L  #$003F,D6           ; Isolate the Src EA bits 
000019BC  4EB9 00001DC8            844              JSR EAGETSRCEA              ; Find and print the code stored in D6
000019C2                           845              
000019C2  12FC 002C                846              MOVE.B  #',',(A1)+
000019C6  5241                     847              ADDQ    #1,D1
000019C8                           848              
000019C8  2C05                     849              MOVE.L  D5,D6               ; Copy D5 into D6
000019CA  E09E                     850              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
000019CC  E29E                     851              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
000019CE  0286 00000003            852              ANDI.L  #$0003,D6           ; Isolate the Dn Destination bits
000019D4  4EF9 00001E44            853              JMP EADN
000019DA                           854              
000019DA  4E75                     855              RTS          
000019DC                           856          
000019DC                           857  ; This label determines if the code is either MULS or AND, by looking at it's size bits     
000019DC  2C05                     858  MULSAND     MOVE.L  D5,D6               ; Copy D5 into D6
000019DE  EC8E                     859              LSR.L   #6,D6               ; Shift the size bits to the far right
000019E0  0206 0007                860              ANDI.B  #$7,D6              ; Isolate the size bits
000019E4  BC3C 0007                861              CMP.B   #7,D6               ; See if the size is '111'..
000019E8  6704                     862              BEQ.S   MULS                ; ..If so, it's a MULS opcode
000019EA  6000 003E                863              BRA     AND                 ; Otherwise, it's an AND code
000019EE                           864          
000019EE  22FC 4D554C53            865  MULS        MOVE.L  #'MULS',(A1)+
000019F4  5841                     866              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000019F6                           867              
000019F6  22FC 20202020            868              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
000019FC  32FC 2020                869              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
00001A00  5C41                     870              ADDQ    #6,D1               ; We added 4 bytes, aka 4 spaces
00001A02                           871              
00001A02  2C05                     872              MOVE.L  D5,D6               ; Copy D5 into D6
00001A04  0286 0000003F            873              ANDI.L  #$003F,D6           ; Isolate the Src EA bits
00001A0A  4EB9 00001DC8            874              JSR EAGETSRCEA
00001A10                           875              
00001A10  12FC 002C                876              MOVE.B  #',',(A1)+
00001A14  5241                     877              ADDQ    #1,D1
00001A16                           878              
00001A16  2C05                     879              MOVE.L  D5,D6               ; Copy D5 into D6
00001A18  E09E                     880              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00001A1A  E29E                     881              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00001A1C  0286 00000007            882              ANDI.L  #$0007,D6           ; Isolate the Dn Destination bits
00001A22  4EF9 00001E44            883              JMP EADN
00001A28                           884              
00001A28  4E75                     885              RTS
00001A2A                           886              
00001A2A                           887  ; At this point, we know D6 is the size of our opcode
00001A2A  BC3C 0006                888  AND         CMP.B   #%0110,D6            ; See if D6 is size "%100" through "%110"..
00001A2E  6700 002E                889              BEQ     ANDLEA              ; If it is, our OpCode is in the format of..
00001A32  BC3C 0005                890              CMP.B   #%101,D6            ; .. Dn ~ <EA> --> <EA>
00001A36  6700 0036                891              BEQ     ANDWEA
00001A3A  BC3C 0004                892              CMP.B   #%100,D6
00001A3E  6700 003E                893              BEQ     ANDBEA
00001A42                           894              
00001A42  BC3C 0002                895              CMP.B   #%10,D6             ; See if D6 is size "%000" through "%010"..
00001A46  6700 007C                896              BEQ     ANDLDN              ; If it is, our OpCode is in the format of..
00001A4A  BC3C 0001                897              CMP.B   #%01,D6             ; .. <EA> ~ Dn --> Dn
00001A4E  6700 0086                898              BEQ     ANDWDN
00001A52  BC3C 0000                899              CMP.B   #%00,D6
00001A56  6700 0090                900              BEQ     ANDBDN              ; == 000 at this point
00001A5A                           901              
00001A5A  6000 0348                902              BRA     UNKNOWN
00001A5E                           903              
00001A5E  22FC 414E442E            904  ANDLEA      MOVE.L  #'AND.',(A1)+
00001A64  12FC 004C                905              MOVE.B  #'L',(A1)+
00001A68  5A41                     906              ADDQ    #5,D1               ; We added 5 byte into D1
00001A6A  6000 0022                907              BRA     ANDEA
00001A6E                           908              
00001A6E  22FC 414E442E            909  ANDWEA      MOVE.L  #'AND.',(A1)+
00001A74  12FC 0057                910              MOVE.B  #'W',(A1)+
00001A78  5A41                     911              ADDQ    #5,D1               ; We added 5 byte into D1
00001A7A  6000 0012                912              BRA     ANDEA
00001A7E                           913  
00001A7E  22FC 414E442E            914  ANDBEA      MOVE.L  #'AND.',(A1)+
00001A84  12FC 0042                915              MOVE.B  #'B',(A1)+
00001A88  5A41                     916              ADDQ    #5,D1               ; We added 5 byte into D1
00001A8A  6000 0002                917              BRA     ANDEA
00001A8E                           918  
00001A8E  12FC 0020                919  ANDEA       MOVE.B  #' ',(A1)+          ; Add a spacer into our IOStringLoc
00001A92  32FC 2020                920              MOVE.W  #'  ',(A1)+          ; Add a spacer into our IOStringLoc
00001A96  12FC 0020                921              MOVE.B  #' ',(A1)+          ; Add a spacer into our IOStringLoc
00001A9A  5241                     922              ADDQ    #1,D1               ; We added 4 bytes, aka 4 spaces
00001A9C                           923              
00001A9C  2C05                     924              MOVE.L  D5,D6
00001A9E  E08E                     925              LSR.L   #8,D6               ; Shift our OpCode a total of 9 bits to the right
00001AA0  E28E                     926              LSR.L   #1,D6               ; 
00001AA2  0286 00000007            927              ANDI.L  #$07,D6             ; Isolate our data register
00001AA8                           928              
00001AA8  4EB9 00001E44            929              JSR EADN
00001AAE                           930              
00001AAE  12FC 002C                931              MOVE.B  #',',(A1)+
00001AB2  5241                     932              ADDQ    #1,D1
00001AB4                           933              
00001AB4  2C05                     934              MOVE.L  D5,D6               ; Copy our OpCode again
00001AB6  0286 0000003F            935              ANDI.L  #$3F,D6             ; Isolate our EA bits
00001ABC                           936              
00001ABC  4EB9 00001DC8            937              JSR EAGETSRCEA  
00001AC2                           938              
00001AC2  4E75                     939              RTS
00001AC4                           940              
00001AC4  22FC 414E442E            941  ANDLDN      MOVE.L  #'AND.',(A1)+
00001ACA  5841                     942              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001ACC  12FC 004C                943              MOVE.B  #'L',(A1)+
00001AD0  5241                     944              ADDQ    #1,D1               ; We added 1 byte into D1
00001AD2  6000 0026                945              BRA ANDDN
00001AD6                           946              
00001AD6  22FC 414E442E            947  ANDWDN      MOVE.L  #'AND.',(A1)+
00001ADC  5841                     948              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001ADE  12FC 0057                949              MOVE.B  #'W',(A1)+
00001AE2  5241                     950              ADDQ    #1,D1               ; We added 1 byte into D1
00001AE4  6000 0014                951              BRA ANDDN
00001AE8                           952  
00001AE8  22FC 414E442E            953  ANDBDN      MOVE.L  #'AND.',(A1)+
00001AEE  5841                     954              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001AF0  12FC 0042                955              MOVE.B  #'B',(A1)+
00001AF4  5241                     956              ADDQ    #1,D1               ; We added 1 byte into D1
00001AF6  6000 0002                957              BRA ANDDN  
00001AFA                           958  
00001AFA                           959  ANDDN
00001AFA  12FC 0009                960              MOVE.B  #$09,(A1)+          ; Add a spacer into our IOStringLoc
00001AFE  5241                     961              ADDQ    #1,D1               ; We added 4 bytes, aka 4 spaces
00001B00                           962              
00001B00  2C05                     963              MOVE.L  D5,D6               ; Copy our OpCode again
00001B02  0286 0000003F            964              ANDI.L  #$3F,D6             ; Isolate our EA bits
00001B08                           965              
00001B08  4EB9 00001DC8            966              JSR EAGETSRCEA              
00001B0E                           967              
00001B0E  12FC 002C                968              MOVE.B  #',',(A1)+
00001B12  5241                     969              ADDQ    #1,D1
00001B14                           970              
00001B14  2C05                     971              MOVE.L  D5,D6
00001B16  E08E                     972              LSR.L   #8,D6               ; Shift our OpCode a total of 9 bits to the right
00001B18  E28E                     973              LSR.L   #1,D6               ; 
00001B1A  0286 00000007            974              ANDI.L  #$07,D6             ; Isolate our data register
00001B20                           975              
00001B20  4EB9 00001E44            976              JSR EADN
00001B26                           977              
00001B26  4E75                     978              RTS
00001B28                           979  
00001B28                           980  ; This label determines if the code is either ADD or ADDA           
00001B28  2C05                     981  ADDADDA     MOVE.L  D5,D6               ; Copy D5 into D6
00001B2A  EC8E                     982              LSR.L   #6,D6               ; Shift the size bits to the far right
00001B2C  0206 0007                983              ANDI.B  #$7,D6              ; Isolate the size bits
00001B30                           984              
00001B30  BC3C 0006                985              CMP.B   #%0110,D6           ; See if D6 is size "%100" through "%110"..
00001B34  6700 0074                986              BEQ     ADDLEA              ; If it is, our OpCode is in the format of..
00001B38  BC3C 0005                987              CMP.B   #%101,D6            ; .. Dn ~ <EA> --> <EA>
00001B3C  6700 007E                988              BEQ     ADDWEA
00001B40  BC3C 0004                989              CMP.B   #%100,D6
00001B44  6700 0088                990              BEQ     ADDBEA
00001B48                           991              
00001B48  BC3C 0002                992              CMP.B   #%10,D6             ; See if D6 is size "%000" through "%010"..
00001B4C  6700 0026                993              BEQ     ADDLDN              ; If it is, our OpCode is in the format of..
00001B50  BC3C 0001                994              CMP.B   #%01,D6             ; .. <EA> ~ Dn --> Dn
00001B54  6700 0030                995              BEQ     ADDWDN
00001B58  BC3C 0000                996              CMP.B   #%00,D6
00001B5C  6700 003A                997              BEQ     ADDBDN              ; == 000 at this point
00001B60                           998              
00001B60  BC3C 0003                999              CMP.B   #%011,D6            ; ADDA Word Operation <EA> -> An 
00001B64  6700 007A               1000              BEQ     ADDAW
00001B68  BC3C 0007               1001              CMP.B   #%111,D6            ; ADDA Word Operation <EA> -> An  
00001B6C  6700 0084               1002              BEQ     ADDAL
00001B70  6000 0232               1003              BRA     UNKNOWN
00001B74                          1004              
00001B74  22FC 4144442E           1005  ADDLDN      MOVE.L  #'ADD.',(A1)+
00001B7A  5841                    1006              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001B7C  12FC 004C               1007              MOVE.B  #'L',(A1)+
00001B80  5241                    1008              ADDQ    #1,D1               ; We added 1 byte into D1
00001B82  6000 FF76               1009              BRA ANDDN
00001B86                          1010              
00001B86  22FC 4144442E           1011  ADDWDN      MOVE.L  #'ADD.',(A1)+
00001B8C  5841                    1012              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001B8E  12FC 0057               1013              MOVE.B  #'W',(A1)+
00001B92  5241                    1014              ADDQ    #1,D1               ; We added 1 byte into D1
00001B94  6000 FF64               1015              BRA ANDDN
00001B98                          1016  
00001B98  22FC 4144442E           1017  ADDBDN      MOVE.L  #'ADD.',(A1)+
00001B9E  5841                    1018              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001BA0  12FC 0042               1019              MOVE.B  #'B',(A1)+
00001BA4  5241                    1020              ADDQ    #1,D1               ; We added 1 byte into D1
00001BA6  6000 FF52               1021              BRA ANDDN  
00001BAA                          1022              
00001BAA  22FC 4144442E           1023  ADDLEA      MOVE.L  #'ADD.',(A1)+
00001BB0  5841                    1024              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001BB2  12FC 004C               1025              MOVE.B  #'L',(A1)+
00001BB6  5241                    1026              ADDQ    #1,D1               ; We added 1 byte into D1
00001BB8  6000 FED4               1027              BRA     ANDEA
00001BBC                          1028              
00001BBC  22FC 4144442E           1029  ADDWEA      MOVE.L  #'ADD.',(A1)+
00001BC2  5841                    1030              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001BC4  12FC 0057               1031              MOVE.B  #'W',(A1)+
00001BC8  5241                    1032              ADDQ    #1,D1               ; We added 1 byte into D1
00001BCA  6000 FEC2               1033              BRA     ANDEA
00001BCE                          1034  
00001BCE  22FC 4144442E           1035  ADDBEA      MOVE.L  #'ADD.',(A1)+
00001BD4  5841                    1036              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001BD6  12FC 0042               1037              MOVE.B  #'B',(A1)+
00001BDA  5241                    1038              ADDQ    #1,D1               ; We added 1 byte into D1
00001BDC  6000 FEB0               1039              BRA     ANDEA
00001BE0                          1040              
00001BE0  22FC 41444441           1041  ADDAW       MOVE.L  #'ADDA',(A1)+
00001BE6  5841                    1042              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001BE8  32FC 2E57               1043              MOVE.W  #'.W',(A1)+
00001BEC  5441                    1044              ADDQ    #2,D1               ; We added 1 byte into D1
00001BEE  6000 0014               1045              BRA     ADDAN
00001BF2                          1046              
00001BF2  22FC 41444441           1047  ADDAL       MOVE.L  #'ADDA',(A1)+
00001BF8  5841                    1048              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00001BFA  32FC 2E4C               1049              MOVE.W  #'.L',(A1)+
00001BFE  5441                    1050              ADDQ    #2,D1               ; We added 1 byte into D1
00001C00  6000 0002               1051              BRA     ADDAN
00001C04                          1052         
00001C04                          1053  ADDAN
00001C04  22FC 20202020           1054              MOVE.L  #'    ',(A1)+          ; Add a spacer into our IOStringLoc
00001C0A                          1055              
00001C0A  5841                    1056              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
00001C0C                          1057              
00001C0C  2C05                    1058              MOVE.L  D5,D6               ; Copy our OpCode again
00001C0E  0286 0000003F           1059              ANDI.L  #$3F,D6             ; Isolate our EA bits
00001C14                          1060              
00001C14  4EB9 00001DC8           1061              JSR EAGETSRCEA              
00001C1A                          1062              
00001C1A  12FC 002C               1063              MOVE.B  #',',(A1)+
00001C1E  5241                    1064              ADDQ    #1,D1
00001C20                          1065              
00001C20  2C05                    1066              MOVE.L  D5,D6
00001C22  E08E                    1067              LSR.L   #8,D6               ; Shift our OpCode a total of 9 bits to the right
00001C24  E28E                    1068              LSR.L   #1,D6               ; 
00001C26  0286 00000007           1069              ANDI.L  #$07,D6             ; Isolate our data register
00001C2C                          1070              
00001C2C  4EB9 00001E52           1071              JSR EAAN
00001C32                          1072              
00001C32  4E75                    1073              RTS
00001C34                          1074  ; This label determines if the code is either ASd (ASR) or LSd (LSL) or ROd (ROL) 
00001C34                          1075  ASLSRO
00001C34  2C05                    1076              MOVE.L  D5,D6               ; Copy our OpCode
00001C36  EC4E                    1077              LSR.W   #6,D6               ; Shift our size bits into place
00001C38  0206 0003               1078              ANDI.B  #$03,D6             ; Isolate our size bits
00001C3C  BC3C 0003               1079              CMP.B   #%11,D6             ; If our size is '11'..
00001C40  6700 00E2               1080              BEQ     AASLSRO             ; ..this is an address ASLSRO
00001C44                          1081              
00001C44  2C05                    1082              MOVE.L  D5,D6               ; Copy our OpCode
00001C46  E64E                    1083              LSR.W   #3,D6               ; Shift our identification bits over
00001C48  0206 0003               1084              ANDI.B  #03,D6              ;  and isolate them
00001C4C                          1085              
00001C4C  BC3C 0000               1086              CMP.B   #%00,D6             ; If '00', this is a ASd op
00001C50  6700 0016               1087              BEQ     ASD
00001C54  BC3C 0001               1088              CMP.B   #%01,D6             ; If '01', this is a LSd op
00001C58  6700 0018               1089              BEQ     LSD
00001C5C  BC3C 0003               1090              CMP.B   #%11,D6             ; If '11', this is a ROd op
00001C60  6700 001A               1091              BEQ     ROD
00001C64                          1092              
00001C64  6000 013E               1093              BRA     UNKNOWN             ; This catches for ROX, non-required op
00001C68                          1094  
00001C68  32FC 4153               1095  ASD         MOVE.W  #'AS',(A1)+
00001C6C  5441                    1096              ADDQ    #2,D1
00001C6E  6000 0016               1097              BRA     ASLSRODR
00001C72                          1098              
00001C72  32FC 4C53               1099  LSD         MOVE.W  #'LS',(A1)+
00001C76  5441                    1100              ADDQ    #2,D1
00001C78  6000 000C               1101              BRA     ASLSRODR
00001C7C                          1102              
00001C7C  32FC 524F               1103  ROD         MOVE.W  #'RO',(A1)+
00001C80  5441                    1104              ADDQ    #2,D1
00001C82  6000 0002               1105              BRA     ASLSRODR
00001C86                          1106              
00001C86                          1107  ; This section checks our ASd/LSd/ROd direction, and defaults to Right 
00001C86  2C05                    1108  ASLSRODR    MOVE.L  D5,D6               ; Copy our OpCode
00001C88  E09E                    1109              ROR.L   #8,D6               ; Shift our direction bit into place
00001C8A  0806 0000               1110              BTST    #$00,D6             ; Check our right-most bit 
00001C8E  6600 0010               1111              BNE     ASLSRODL            ; If it's '1', our direction is left
00001C92                          1112              
00001C92  12FC 0052               1113              MOVE.B  #'R',(A1)+          ; Otherwise it's right
00001C96  12FC 002E               1114              MOVE.B  #'.',(A1)+
00001C9A  5441                    1115              ADDQ    #2,D1
00001C9C                          1116              
00001C9C  6000 000C               1117              BRA ASLSROSIZE
00001CA0                          1118              
00001CA0                          1119  ; This section is our ASd/LSd/ROd left direction
00001CA0  12FC 004C               1120  ASLSRODL    MOVE.B  #'L',(A1)+          ; L for Left
00001CA4  12FC 002E               1121              MOVE.B  #'.',(A1)+
00001CA8  5441                    1122              ADDQ    #2,D1
00001CAA                          1123              ; Carry into our Size determiner
00001CAA                          1124  ; Determines what size our ASd/LSd/ROd is
00001CAA                          1125  ;  Our previous operations on D6 leave our size bits
00001CAA                          1126  ;  just our of range, so we shift them in
00001CAA                          1127  ASLSROSIZE  
00001CAA  E59E                    1128              ROL.L   #2,D6               ; Shift our size bits in
00001CAC  0206 0003               1129              ANDI.B  #$03,D6             ; Isolate our size bits
00001CB0  BC3C 0000               1130              CMP.B   #%00,D6             ; If our size is '00'..
00001CB4  6700 0012               1131              BEQ     ASLSROB             ; ..Then it's a byte op
00001CB8  BC3C 0001               1132              CMP.B   #%01,D6             ; If our size is '01'..
00001CBC  6700 0012               1133              BEQ     ASLSROW             ; ..Then it's a word op
00001CC0                          1134              ; Otherwise it's a long op, because we accounted for '11' earlier
00001CC0                          1135              
00001CC0  12FC 004C               1136              MOVE.B  #'L',(A1)+          ; Add L for Long
00001CC4  6000 000E               1137              BRA     ASLSROIR            ; Complete the rest of the ASLSRO Op
00001CC8                          1138              
00001CC8  12FC 0042               1139  ASLSROB     MOVE.B  #'B',(A1)+          ; Add B for Byte
00001CCC  6000 0006               1140              BRA     ASLSROIR            ; Complete the rest of the ASLSRO Op
00001CD0                          1141              
00001CD0  12FC 0057               1142  ASLSROW     MOVE.B  #'W',(A1)+          ; Add W for Word
00001CD4                          1143              ; Carry through to complete the rest of the ASLSRO Op  
00001CD4                          1144       
00001CD4                          1145  ; This section determines if our ASLSRO is an Immediate or Dn shfit, and defaults to Immediate
00001CD4  12FC 0020               1146  ASLSROIR    MOVE.B  #' ',(A1)+
00001CD8  32FC 2020               1147              MOVE.W  #'  ',(A1)+
00001CDC  32FC 2020               1148              MOVE.W  #'  ',(A1)+
00001CE0  5C41                    1149              ADDQ    #6,D1               ; We've added 5 new characters (Size char, plus spaces)
00001CE2                          1150              
00001CE2                          1151              ;MOVE.L  D5,D6
00001CE2  E39E                    1152              ROL.L   #1,D6               ; Get our Immediate / Register bit out front
00001CE4  0806 0000               1153              BTST.L  #$00,D6
00001CE8  6600 000C               1154              BNE     ASLSROIRDN          ; If it's '1', we have a Dn ASLSRO
00001CEC                          1155              ; Otherwise, assume immediate ASLSRO
00001CEC  12FC 0023               1156              MOVE.B  #'#',(A1)+
00001CF0  5241                    1157              ADDQ    #1,D1
00001CF2  6000 0008               1158              BRA     ASLSROOP            ; Branch to our ASLSRO Op finish
00001CF6                          1159  ; An ASLSRO of Dn Register type   
00001CF6  12FC 0044               1160  ASLSROIRDN  MOVE.B  #'D',(A1)+
00001CFA  5241                    1161              ADDQ    #1,D1
00001CFC                          1162              ; Continue through to our ASLSRO Op finish
00001CFC                          1163  ; Finishes the ASLSRO Op
00001CFC                          1164  ASLSROOP
00001CFC  2C05                    1165              MOVE.L  D5,D6               ; Copy our OpCode into D6
00001CFE  E09E                    1166              ROR.L   #8,D6               ; Shift our Count/Reg bits into place
00001D00  E29E                    1167              ROR.L   #1,D6               ;
00001D02  0206 0007               1168              ANDI.B  #$07,D6             ; Isolate the Count/Reg bits
00001D06                          1169              
00001D06  0606 0030               1170              ADDI.B  #48,D6 
00001D0A  12C6                    1171              MOVE.B  D6,(A1)+            ; Push our number to the IOStringLoc
00001D0C  5241                    1172              ADDQ    #1,D1
00001D0E                          1173              
00001D0E  12FC 002C               1174              MOVE.B  #',',(A1)+
00001D12  5241                    1175              ADDQ    #1,D1
00001D14                          1176              
00001D14  2C05                    1177              MOVE.L  D5,D6               ; Isolate our Dn affected num bits
00001D16  0286 00000007           1178              ANDI.L  #$07,D6             ;
00001D1C  4EB9 00001E44           1179              JSR     EADN
00001D22                          1180              
00001D22  4E75                    1181              RTS
00001D24                          1182  ; Start of the Effective Address version of ASLSRO
00001D24  2C05                    1183  AASLSRO     MOVE.L  D5,D6               ; Copy our OpCode into D6
00001D26  EF5E                    1184              ROL.W   #7,D6               ; Shift our determination bits to the far right
00001D28  0206 0007               1185              ANDI.B  #$07,D6             ; Isolate the determination bits   
00001D2C                          1186              
00001D2C  BC3C 0001               1187              CMP.B   #$01,D6             ; If our determination is '001'..
00001D30  6700 0020               1188              BEQ     ALSD                ; It's a Logical Shift
00001D34  BC3C 0003               1189              CMP.B   #$03,D6             ; If it's '011'
00001D38  6700 0022               1190              BEQ     AROD                ; It's a Rotation 
00001D3C  BC3C 0000               1191              CMP.B   #$00,D6             ; If it's '000'
00001D40  6700 0006               1192              BEQ     AASD                ; It's an Arithmetic Shift
00001D44                          1193              
00001D44  6000 005E               1194              BRA     UNKNOWN              ; Otherwise it's data
00001D48                          1195  
00001D48  32FC 4153               1196  AASD        MOVE.W  #'AS',(A1)+
00001D4C  5441                    1197              ADDQ    #2,D1
00001D4E  6000 0016               1198              BRA     AASLSRODR
00001D52                          1199              
00001D52  32FC 4C53               1200  ALSD        MOVE.W  #'LS',(A1)+
00001D56  5441                    1201              ADDQ    #2,D1
00001D58  6000 000C               1202              BRA     AASLSRODR
00001D5C                          1203              
00001D5C  32FC 524F               1204  AROD        MOVE.W  #'RO',(A1)+
00001D60  5441                    1205              ADDQ    #2,D1
00001D62  6000 0002               1206              BRA     AASLSRODR
00001D66                          1207              
00001D66                          1208  ; This section checks our ASd/LSd/ROd direction, and defaults to Right 
00001D66  2C05                    1209  AASLSRODR   MOVE.L  D5,D6              ; Copy our OpCode
00001D68  E09E                    1210              ROR.L   #8,D6               ; Shift our direction bit into place
00001D6A  0806 0000               1211              BTST    #$00,D6             ; Check our right-most bit 
00001D6E  6600 000C               1212              BNE     AASLSRODL           ; If it's '1', our direction is left
00001D72                          1213              
00001D72  12FC 0052               1214              MOVE.B  #'R',(A1)+          ; Otherwise it's right
00001D76  5241                    1215              ADDQ    #1,D1
00001D78                          1216              
00001D78  6000 0008               1217              BRA AASLSROOP
00001D7C                          1218              
00001D7C                          1219  ; This section is our ASd/LSd/ROd left direction
00001D7C  12FC 004C               1220  AASLSRODL   MOVE.B  #'L',(A1)+          ; L for Left
00001D80  5241                    1221              ADDQ    #1,D1
00001D82                          1222              ; Carry into finishing AASLSRO op
00001D82                          1223  
00001D82                          1224  ; This section finishes off our Effective Address ASLSRO Op
00001D82  2C05                    1225  AASLSROOP   MOVE.L  D5,D6               ; Copy our OpCode
00001D84  0286 0000003F           1226              ANDI.L  #$3F,D6             ; Isolate our EA bits
00001D8A                          1227              
00001D8A  12FC 0020               1228              MOVE.B  #' ',(A1)+
00001D8E  12FC 0020               1229              MOVE.B  #' ',(A1)+
00001D92  12FC 0020               1230              MOVE.B  #' ',(A1)+
00001D96  12FC 0020               1231              MOVE.B  #' ',(A1)+
00001D9A  5841                    1232              ADDQ    #4,D1
00001D9C                          1233              
00001D9C  4EB9 00001DC8           1234              JSR EAGETSRCEA
00001DA2                          1235              
00001DA2  4E75                    1236              RTS
00001DA4                          1237  UNKNOWN
00001DA4  22FC 44415441           1238              MOVE.L  #'DATA',(A1)+
00001DAA  5841                    1239              ADDQ    #4,D1           ; We added 4 new characters to our IOStringLoc 
00001DAC                          1240              
00001DAC  22FC 20202020           1241              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
00001DB2  32FC 2020               1242              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
00001DB6  5C41                    1243              ADDQ    #6,D1               ; We added 6 bytes, aka 6 spaces
00001DB8                          1244              
00001DB8  12FC 0024               1245              MOVE.B  #'$',(A1)+
00001DBC  5241                    1246              ADDQ    #1,D1
00001DBE                          1247              
00001DBE  2C05                    1248              MOVE.L  D5,D6
00001DC0  4EB9 00001F02           1249              JSR     EAHEXtoASCII
00001DC6                          1250              
00001DC6  4E75                    1251              RTS
00001DC8                          1252  
00001DC8                          1253  
00001DC8                          1254  
00001DC8                          1255  
00001DC8                          1256  
00001DC8                          1257  
00001DC8                          1258  
00001DC8                          1259  
00001DC8                          1260  
00001DC8                          1261  
00001DC8                          1262  -------------------- end include --------------------
00001DC8                          1263      INCLUDE "EA.X68"        ; Handles EA types
00001DC8                          1264  
00001DC8                          1265  
00001DC8                          1266  ; It is assumed that D6 contains the bits for the EA, algined to the far right. D5 contains
00001DC8                          1267  ;  the original full op-code being reffered to. We assume that A2 contains the address 
00001DC8                          1268  ;  pointing to the start of our EA address (if applicable), and we assume that A1 contains
00001DC8                          1269  ;  the address pointing to our IOStringLoc. D1 contains the current length to be printed from A1
00001DC8                          1270  
00001DC8                          1271  ; For this method, D6 is in the format of: <3 bits Src Mode><3 bits Src Reg> 
00001DC8                          1272  EAGETSRCEA  
00001DC8  E69E                    1273      ROR.L   #3,D6       ; Rotate our bits 3 to the right
00001DCA  1E06                    1274      MOVE.B  D6,D7       ; Store the mode of the EA in D7
00001DCC  E79E                    1275      ROL.L   #3,D6       ; Rotate our 3 bits back
00001DCE  0286 00000007           1276      ANDI.L  #$0007,D6   ; Isolate the 3 rightmost bits as 'Reg'
00001DD4  BE3C 0000               1277      CMP.B   #0,D7       ; See if the mode == '000'
00001DD8  6700 006A               1278      BEQ     EADN
00001DDC                          1279  
00001DDC  BE3C 0001               1280      CMP.B   #1,D7       ; See if the mode == '001'
00001DE0  6700 0070               1281      BEQ     EAAN        ; Address Register Direct
00001DE4                          1282      
00001DE4  BE3C 0002               1283      CMP.B   #2,D7       ; See if the mode == '010'
00001DE8  6700 0076               1284      BEQ     EAANI       ; Address Register Indirect
00001DEC                          1285      
00001DEC  BE3C 0003               1286      CMP.B   #3,D7       ; See if the mode == '011'
00001DF0  6700 0084               1287      BEQ     EAAPOST     ; Address Register Indirect with Post increment
00001DF4                          1288      
00001DF4  BE3C 0004               1289      CMP.B   #4,D7       ; See if the mode == '100'
00001DF8  6700 0096               1290      BEQ     EAAPRE      ; Address Register Indirect with Pre increment
00001DFC                          1291      
00001DFC  BE3C 0007               1292      CMP.B   #7,D7       ; See if the mode == '111' 
00001E00  6700 00EA               1293      BEQ     EA111       ; Determine if (Immediate Data, Aboslute Word or Long Address)
00001E04                          1294  
00001E04  6000 02F4               1295      BRA     EAUNKN
00001E08                          1296  
00001E08                          1297  ; For this method, D6 is in the format of: <3 bits Dst Reg><3 bits Dst Mode> 
00001E08                          1298  EAGETDSTEA  
00001E08  1E06                    1299      MOVE.B  D6,D7       ; Store the right-most byte into D7
00001E0A  CE3C 0007               1300      AND.B   #$07,D7     ; Isolate 3 rightmost bits as 'Mode'
00001E0E  E68E                    1301      LSR.L   #3,D6       ; Shift D6 to the right 3 bits (D6 Byte = 'Reg')
00001E10  BE3C 0000               1302      CMP.B   #0,D7       ; See if the mode == '000'
00001E14  6700 002E               1303      BEQ     EADN
00001E18                          1304  
00001E18  BE3C 0001               1305      CMP.B   #1,D7       ; See if the mode == '001'
00001E1C  6700 0034               1306      BEQ     EAAN        ; Address Register Direct
00001E20                          1307      
00001E20  BE3C 0002               1308      CMP.B   #2,D7       ; See if the mode == '010'
00001E24  6700 003A               1309      BEQ     EAANI       ; Address Register Indirect
00001E28                          1310      
00001E28  BE3C 0003               1311      CMP.B   #3,D7       ; See if the mode == '011'
00001E2C  6700 0048               1312      BEQ     EAAPOST     ; Address Register Indirect with Post increment
00001E30                          1313      
00001E30  BE3C 0004               1314      CMP.B   #4,D7       ; See if the mode == '100'
00001E34  6700 005A               1315      BEQ     EAAPRE      ; Address Register Indirect with Pre increment
00001E38                          1316      
00001E38  BE3C 0007               1317      CMP.B   #7,D7       ; See if the mode == '111' 
00001E3C  6700 00AE               1318      BEQ     EA111       ; Determine if (Immediate Data, Aboslute Word or Long Address)
00001E40                          1319  
00001E40  6000 02B8               1320      BRA     EAUNKN
00001E44                          1321           
00001E44                          1322  ;If the EA is a Dn EA    
00001E44                          1323  ;This method assume D6 contains the Reg for Dn  
00001E44                          1324  EADN
00001E44  12FC 0044               1325      MOVE.B  #'D',(A1)+
00001E48  0606 0030               1326      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
00001E4C  12C6                    1327      MOVE.B  D6,(A1)+
00001E4E  5441                    1328      ADDQ    #2,D1
00001E50  4E75                    1329      RTS
00001E52                          1330  ;If the EA is a An EA    
00001E52                          1331  ;This method assume D6 contains the Reg for An  
00001E52                          1332  EAAN
00001E52  12FC 0041               1333      MOVE.B  #'A',(A1)+
00001E56  0606 0030               1334      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
00001E5A  12C6                    1335      MOVE.B  D6,(A1)+
00001E5C  5441                    1336      ADDQ    #2,D1
00001E5E  4E75                    1337      RTS
00001E60                          1338  
00001E60                          1339  ;If the EA is a (An) EA    
00001E60                          1340  ;This method assume D6 contains the Reg for (An)  
00001E60                          1341  EAANI
00001E60  12FC 0028               1342      MOVE.B  #'(',(A1)+
00001E64  12FC 0041               1343      MOVE.B  #'A',(A1)+
00001E68  0606 0030               1344      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
00001E6C  12C6                    1345      MOVE.B  D6,(A1)+
00001E6E  12FC 0029               1346      MOVE.B  #')',(A1)+
00001E72  5841                    1347      ADDQ    #4,D1
00001E74  4E75                    1348      RTS
00001E76                          1349  ;If the EA is a (An)+ EA    
00001E76                          1350  ;This method assume D6 contains the Reg for (An)+  
00001E76                          1351  EAAPOST
00001E76  12FC 0028               1352      MOVE.B  #'(',(A1)+
00001E7A  12FC 0041               1353      MOVE.B  #'A',(A1)+
00001E7E  0606 0030               1354      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
00001E82  12C6                    1355      MOVE.B  D6,(A1)+
00001E84  12FC 0029               1356      MOVE.B  #')',(A1)+
00001E88  12FC 002B               1357      MOVE.B  #'+',(A1)+
00001E8C  5A41                    1358      ADDQ    #5,D1
00001E8E  4E75                    1359      RTS
00001E90                          1360  ;If the EA is a -(An) EA    
00001E90                          1361  ;This method assume D6 contains the Reg for -(An) 
00001E90                          1362  EAAPRE
00001E90  12FC 002D               1363      MOVE.B  #'-',(A1)+
00001E94  12FC 0028               1364      MOVE.B  #'(',(A1)+
00001E98  12FC 0041               1365      MOVE.B  #'A',(A1)+
00001E9C  0606 0030               1366      ADD.B   #48,D6      ; Add 48 into D6 to turn num 0 into ASCII 0
00001EA0  12C6                    1367      MOVE.B  D6,(A1)+
00001EA2  12FC 0029               1368      MOVE.B  #')',(A1)+
00001EA6  5A41                    1369      ADDQ    #5,D1
00001EA8  4E75                    1370      RTS 
00001EAA                          1371  ;If the EA is a #<data> EA    
00001EAA                          1372  ;This method assume D6 contains the Reg for #<data>  
00001EAA                          1373  EAID
00001EAA  32FC 2324               1374      MOVE.W  #'#$',(A1)+
00001EAE  5441                    1375      ADDQ    #2,D1
00001EB0  3C1A                    1376      MOVE.W  (A2)+,D6
00001EB2  4244                    1377      CLR     D4
00001EB4  4EB9 00001F02           1378      JSR     EAHEXtoASCII
00001EBA  4E75                    1379      RTS
00001EBC                          1380  ;If the EA is a (xxx).W EA    
00001EBC                          1381  ;This method assume D6 contains the Reg for (xxx).W  
00001EBC                          1382  EAAWA
00001EBC  12FC 0024               1383      MOVE.B  #'$',(A1)+
00001EC0  5241                    1384      ADDQ    #1,D1
00001EC2  3C1A                    1385      MOVE.W  (A2)+,D6   ; Push our next Word value into D6
00001EC4                          1386      ; Push the ASCII equivlent characters of D6-- only the
00001EC4                          1387      ;   first Word's worth (our entire Word we just acquired)
00001EC4  4244                    1388      CLR     D4
00001EC6  4EB9 00001F02           1389      JSR     EAHEXtoASCII
00001ECC                          1390      
00001ECC  4E75                    1391      RTS
00001ECE                          1392  ;If the EA is a (xxx).L EA    
00001ECE                          1393  ;This method assume D6 contains the Reg for (xxx).L  
00001ECE                          1394  EAALA
00001ECE  12FC 0024               1395      MOVE.B  #'$',(A1)+
00001ED2  5241                    1396      ADDQ    #1,D1
00001ED4  2C1A                    1397      MOVE.L  (A2)+,D6   ; Push our next Long value into D6
00001ED6                          1398      ; Push the ASCII equivlent characters of D6-- only the
00001ED6                          1399      ;   first Word's worth of our Long
00001ED6  4244                    1400      CLR     D4         ; Clear our counter
00001ED8  4846                    1401      SWAP    D6         ; Flip the high-order Word with the Low-order
00001EDA  4EB9 00001F02           1402      JSR     EAHEXtoASCII
00001EE0  4846                    1403      SWAP    D6         ; Flip the high-order Word with the Low-order
00001EE2                          1404      ; Print the second half of the Long, too
00001EE2  4244                    1405      CLR     D4
00001EE4  4EB9 00001F02           1406      JSR     EAHEXtoASCII
00001EEA                          1407      
00001EEA  4E75                    1408      RTS
00001EEC                          1409  ;If the EA Mode = 111, Determine EA    
00001EEC                          1410  ;This method assume D6 contains the Reg for EA  
00001EEC                          1411  EA111
00001EEC  BC3C 0000               1412      CMP.B #0,D6
00001EF0  67CA                    1413      BEQ     EAAWA       ; Absolute Word Address 
00001EF2  BC3C 0001               1414      CMP.B #1,D6
00001EF6  67D6                    1415      BEQ     EAALA       ; Absolute Long Address 
00001EF8  BC3C 0004               1416      CMP.B #4,D6
00001EFC  67AC                    1417      BEQ     EAID        ; Immediate Data 
00001EFE                          1418      *-----------------------------------------------let fall through? it shouldn't RTS right?
00001EFE  6000 01FA               1419      BRA     EAUNKN
00001F02                          1420      
00001F02                          1421  ; Uses D6 as a storage, D3 as a go-between, and D4 as a counter..
00001F02                          1422  ;  This operates on the low-order word of D6, and pushes exactly 4 
00001F02                          1423  ;  characters into IOStringLoc, converted from HEX of D6's nybble,
00001F02                          1424  ;  to ASCII in IOStringLoc
00001F02  5244                    1425  EAHEXtoASCII    ADDQ    #1,D4
00001F04  E95E                    1426                  ROL.W   #4,D6              Get the left-most nyblle to the front..
00001F06  1606                    1427                  MOVE.B  D6,D3              .. Put the front-most byte into D3    
00001F08  C63C 000F               1428                  AND.B   #$0F,D3            Distill D3 down to the original left-most nybble
00001F0C  B63C 0009               1429                  CMP.B   #9,D3              See if our number is greater than 9..
00001F10  6F00 0004               1430                  BLE     EADIGIT            If it is 9 or less, it's a digit..
00001F14  5E03                    1431                  ADD.B   #7,D3              Otherwise it is a digit, and needs an additional 7
00001F16  0603 0030               1432  EADIGIT         ADD.B   #48,D3             We now have the nybble's ASCII code
00001F1A  12C3                    1433                  MOVE.B  D3,(A1)+           Move the ASCII code into the output string at A1
00001F1C  B83C 0004               1434                  CMP.B   #4,D4              See if we've read all the characters
00001F20  66E0                    1435                  BNE.S   EAHEXtoASCII       Continue if we haven't
00001F22                          1436                  
00001F22  5841                    1437                  ADDQ    #4,D1
00001F24  4E75                    1438                  RTS
00001F26                          1439      
00001F26                          1440  ; MOVEM's (A7)+,A0-A6,D0-D7 format
00001F26                          1441  ; Gets the follow-up WORD in order to process it
00001F26                          1442  EAMOVEMPOSTI
00001F26  3C1A                    1443      MOVE.W  (A2)+,D6    ; Get follow-up word for processing
00001F28                          1444      
00001F28  2E3C 000000FF           1445      MOVE.L  #$FF,D7     ; Initilize D7 to be our counter
00001F2E                          1446      
00001F2E  EE9E                    1447      ROR.L   #7,D6       ; Shift our new bits seven to the right
00001F30                          1448  IANSL    ; Increment An Start Loop  
00001F30  5247                    1449      ADDQ    #1,D7       ; Itterate D7
00001F32  E29E                    1450      ROR.L   #1,D6       ; Rotate one bit to the right  
00001F34  BE3C 0008               1451      CMP.B   #8,D7       ; Check if we've hit A8
00001F38  6700 0056               1452      BEQ     INOA        ; If we have, break the loop
00001F3C  0806 0000               1453      BTST    #$00,D6     ; Check the far right bit
00001F40  67EE                    1454      BEQ     IANSL       ; If it isn't 1, continue checking
00001F42                          1455      
00001F42  12FC 0041               1456      MOVE.B  #'A',(A1)+
00001F46                          1457      
00001F46  0607 0030               1458      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
00001F4A  12C7                    1459      MOVE.B  D7,(A1)+
00001F4C  5441                    1460      ADDQ    #2,D1
00001F4E                          1461      
00001F4E  0407 002F               1462      SUB.B   #47,D7      ; Balance out out D7 from ASCII conversion
00001F52  E29E                    1463      ROR.L   #1,D6       ; Rotate one bit to the right  
00001F54  BE3C 0008               1464      CMP.B   #8,D7       ; Check if we've hit A8
00001F58  6700 003A               1465      BEQ     INOEA       ; If we have, break the loop
00001F5C  0806 0000               1466      BTST    #$00,D6     ; Check the far right bit
00001F60  6700 0032               1467      BEQ     INOEA       ; If it is 0, skip past -A
00001F64                          1468  IANEL    ; Increment An End Loop  
00001F64  5247                    1469      ADDQ    #1,D7       ; Itterate D7
00001F66  E29E                    1470      ROR.L   #1,D6       ; Rotate one bit to the right  
00001F68  BE3C 0008               1471      CMP.B   #8,D7       ; Check if we've hit A8
00001F6C  6700 0008               1472      BEQ     IANELE      ; If we have, break the loop
00001F70  0806 0000               1473      BTST    #$00,D6     ; Check the far right bit
00001F74  66EE                    1474      BNE     IANEL       ; If it isn't 0, continue checking    
00001F76                          1475  IANELE
00001F76  5347                    1476      SUBQ    #1,D7
00001F78                          1477      
00001F78  12FC 002D               1478      MOVE.B  #'-',(A1)+
00001F7C  12FC 0041               1479      MOVE.B  #'A',(A1)+
00001F80                          1480      
00001F80  0607 0030               1481      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
00001F84  12C7                    1482      MOVE.B  D7,(A1)+
00001F86  5641                    1483      ADDQ    #3,D1
00001F88  0407 0030               1484      SUB.B   #48,D7      ; SUB 48 into D7 for ASCII conversion
00001F8C  6000 0006               1485      BRA     INOEA       ; Branch past the 'No An Skip Label'
00001F90                          1486  
00001F90                          1487  INOA     ; No An Skip label 
00001F90  08C7 001F               1488      BSET.L  #$1F,D7     ; Set our MSB to equal 1
00001F94                          1489   
00001F94                          1490  INOEA    ; No An Ending (aka Single An) Skip Label
00001F94  5207                    1491      ADD.B   #1,D7       ; Add 1 for 0ing balance
00001F96  0887 0008               1492      BCLR    #$08,D7     ; Incase we're iterated base FF in A
00001F9A  EFBE                    1493      ROL.L   D7,D6       ; Rotate our A bits back into view
00001F9C  E19E                    1494      ROL.L   #8,D6       ; Rotate our D bits back into place
00001F9E  E39E                    1495      ROL.L   #1,D6       ; Rotate an extra bit over, to account for the loop
00001FA0  1E3C 00FF               1496      MOVE.B  #$FF,D7     ; Initilize D7
00001FA4                          1497  
00001FA4                          1498  IDNSL    ; Increment Dn Start Loop  
00001FA4  5247                    1499      ADDQ    #1,D7       ; Itterate D7
00001FA6  E29E                    1500      ROR.L   #1,D6       ; Rotate one bit to the right  
00001FA8  BE3C 0008               1501      CMP.B   #8,D7       ; Check if we've hit D8
00001FAC  6700 0060               1502      BEQ     ENDEAMOVEMPI ; If we have, break the loop
00001FB0  0806 0000               1503      BTST    #$00,D6     ; Check the far right bit
00001FB4  67EE                    1504      BEQ     IDNSL       ; If it isn't 1, continue checking     
00001FB6                          1505      
00001FB6                          1506      ; The issue with the below line:
00001FB6                          1507      ;  We need to skip / if there are no An registers, as we do in INOA
00001FB6                          1508      ;  We also need to skip / if there are no Dn registers, as we do here
00001FB6                          1509      ;  However, we need to skip / if there are no An's, but we still need to run
00001FB6                          1510      ;   the above code to determine the starting Dn, so we use the MSB of D7
00001FB6                          1511      ;   as a boolean to determine if we had an An
00001FB6  0807 001F               1512      BTST    #$1F,D7     ; If our MSB is equal to 1, we have no A
00001FBA  6600 0008               1513      BNE     INOA2       ; .. So, skip the /
00001FBE  12FC 002F               1514      MOVE.B  #'/',(A1)+
00001FC2  5241                    1515      ADDQ    #1,D1
00001FC4                          1516  INOA2     ; 2nd No An Skip label 
00001FC4  0887 001F               1517      BCLR    #$1F,D7     ; If our MSB is set, clear it
00001FC8  12FC 0044               1518      MOVE.B  #'D',(A1)+
00001FCC  0607 0030               1519      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
00001FD0  12C7                    1520      MOVE.B  D7,(A1)+    
00001FD2  5441                    1521      ADDQ    #2,D1
00001FD4                          1522      
00001FD4  0407 002F               1523      SUB.B   #47,D7      ; Balance out our D7 from ASCII conversion
00001FD8  E29E                    1524      ROR.L   #1,D6       ; Rotate one bit to the right  
00001FDA  BE3C 0008               1525      CMP.B   #8,D7       ; Check if we've hit A8
00001FDE  6700 002E               1526      BEQ     ENDEAMOVEMPI  ; If we have, break to the end
00001FE2  0806 0000               1527      BTST    #$00,D6     ; Check the far right bit
00001FE6  6700 0026               1528      BEQ     ENDEAMOVEMPI ; If it is 0, we have no -Dn
00001FEA                          1529  IDNEL    ; Increment Dn End Loop  
00001FEA  5247                    1530      ADDQ    #1,D7       ; Itterate D7
00001FEC  E29E                    1531      ROR.L   #1,D6       ; Rotate one bit to the right  
00001FEE  BE3C 0008               1532      CMP.B   #8,D7       ; Check if we've hit A8
00001FF2  6700 0008               1533      BEQ     INENLE      ; If we have, break the loop
00001FF6  0806 0000               1534      BTST    #$00,D6     ; Check the far right bit
00001FFA  66EE                    1535      BNE     IDNEL       ; If it isn't 0, continue checking    
00001FFC                          1536  INENLE
00001FFC  5347                    1537      SUBQ    #1,D7
00001FFE                          1538      
00001FFE  12FC 002D               1539      MOVE.B  #'-',(A1)+
00002002  12FC 0044               1540      MOVE.B  #'D',(A1)+
00002006                          1541  
00002006  0607 0030               1542      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
0000200A  12C7                    1543      MOVE.B  D7,(A1)+
0000200C  5641                    1544      ADDQ    #3,D1 
0000200E                          1545      ; If no Dn, skip to the end
0000200E                          1546  ENDEAMOVEMPI
0000200E  4E75                    1547      RTS
00002010                          1548      
00002010                          1549  EAMOVEMPRED
00002010  3C1A                    1550      MOVE.W  (A2)+,D6    ; Get follow-up word for processing
00002012                          1551      
00002012  2E3C 000000FF           1552      MOVE.L  #$FF,D7     ; Initilize D7 to be our counter
00002018                          1553      
00002018  E09E                    1554      ROR.L   #8,D6       ; Shift our new bits eight to the right
0000201A                          1555  DANSL    ; Decrement An Start Loop  
0000201A  5247                    1556      ADDQ    #1,D7       ; Itterate D7
0000201C  E39E                    1557      ROL.L   #1,D6       ; Rotate one bit to the left  
0000201E  BE3C 0008               1558      CMP.B   #8,D7       ; Check if we've hit A8
00002022  6700 0056               1559      BEQ     DNOA        ; If we have, break the loop
00002026  0806 0000               1560      BTST    #$00,D6     ; Check the far right bit
0000202A  67EE                    1561      BEQ     DANSL       ; If it isn't 1, continue checking
0000202C                          1562      
0000202C  12FC 0041               1563      MOVE.B  #'A',(A1)+
00002030                          1564      
00002030  0607 0030               1565      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
00002034  12C7                    1566      MOVE.B  D7,(A1)+
00002036  5441                    1567      ADDQ    #2,D1
00002038                          1568      
00002038  0407 002F               1569      SUB.B   #47,D7      ; Balance out out D7 from ASCII conversion
0000203C  E39E                    1570      ROL.L   #1,D6       ; Rotate one bit to the left  
0000203E  BE3C 0008               1571      CMP.B   #8,D7       ; Check if we've hit A8
00002042  6700 003A               1572      BEQ     DNOEA       ; If we have, break the loop
00002046  0806 0000               1573      BTST    #$00,D6     ; Check the far right bit
0000204A  6700 0032               1574      BEQ     DNOEA       ; If it is 0, skip past -A
0000204E                          1575  DANEL    ; Decrement An End Loop  
0000204E  5247                    1576      ADDQ    #1,D7       ; Itterate D7
00002050  E39E                    1577      ROL.L   #1,D6       ; Rotate one bit to the left  
00002052  BE3C 0008               1578      CMP.B   #8,D7       ; Check if we've hit A8
00002056  6700 0008               1579      BEQ     DANELE      ; If we have, break the loop
0000205A  0806 0000               1580      BTST    #$00,D6     ; Check the far right bit
0000205E  66EE                    1581      BNE     DANEL       ; If it isn't 0, continue checking    
00002060                          1582  DANELE
00002060  5347                    1583      SUBQ    #1,D7
00002062                          1584      
00002062  12FC 002D               1585      MOVE.B  #'-',(A1)+
00002066  12FC 0041               1586      MOVE.B  #'A',(A1)+
0000206A                          1587      
0000206A  0607 0030               1588      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
0000206E  12C7                    1589      MOVE.B  D7,(A1)+
00002070  5641                    1590      ADDQ    #3,D1
00002072  0407 0030               1591      SUB.B   #48,D7      ; SUB 48 into D7 for ASCII conversion
00002076  6000 0006               1592      BRA     DNOEA       ; Branch past the 'No An Skip Label'
0000207A                          1593  
0000207A                          1594  DNOA     ; No An Skip label 
0000207A  08C7 001F               1595      BSET.L  #$1F,D7     ; Set our MSB to equal 1
0000207E                          1596   
0000207E                          1597  DNOEA    ; No An Ending (aka Single An) Skip Label
0000207E  5207                    1598      ADDQ.B  #1,D7       ; Add 1 for 0ing balance
00002080  0887 0008               1599      BCLR    #$08,D7     ; Incase we're iterated base FF in A
00002084  EEBE                    1600      ROR.L   D7,D6       ; Rotate our A bits back into view
00002086  E09E                    1601      ROR.L   #8,D6       ; Rotate our D bits back into place
00002088  E29E                    1602      ROR.L   #1,D6       ; Rotate an extra bit over, to account for the loop
0000208A  1E3C 00FF               1603      MOVE.B  #$FF,D7     ; Initilize D7
0000208E                          1604  
0000208E                          1605  DDNSL    ; Decrement Dn Start Loop  
0000208E  5207                    1606      ADDQ.B  #1,D7       ; Itterate D7
00002090  E39E                    1607      ROL.L   #1,D6       ; Rotate one bit to the right  
00002092  BE3C 0008               1608      CMP.B   #8,D7       ; Check if we've hit D8
00002096  6700 0060               1609      BEQ     ENDEAMOVEMPD ; If we have, break the loop
0000209A  0806 0000               1610      BTST    #$00,D6     ; Check the far right bit
0000209E  67EE                    1611      BEQ     DDNSL       ; If it isn't 1, continue checking     
000020A0                          1612      
000020A0                          1613      ; The issue with the below line:
000020A0                          1614      ;  We need to skip / if there are no An registers, as we do in INOA
000020A0                          1615      ;  We also need to skip / if there are no Dn registers, as we do here
000020A0                          1616      ;  However, we need to skip / if there are no An's, but we still need to run
000020A0                          1617      ;   the above code to determine the starting Dn, so we use the MSB of D7
000020A0                          1618      ;   as a boolean to determine if we had an An
000020A0  0807 001F               1619      BTST    #$1F,D7     ; If our MSB is equal to 1, we have no A
000020A4  6600 0008               1620      BNE     DNOA2       ; .. So, skip the /
000020A8  12FC 002F               1621      MOVE.B  #'/',(A1)+
000020AC  5241                    1622      ADDQ    #1,D1
000020AE                          1623  DNOA2     ; 2nd No An Skip label 
000020AE  0887 001F               1624      BCLR    #$1F,D7     ; If our MSB is set, clear it
000020B2  12FC 0044               1625      MOVE.B  #'D',(A1)+
000020B6  0607 0030               1626      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
000020BA  12C7                    1627      MOVE.B  D7,(A1)+    
000020BC  5441                    1628      ADDQ    #2,D1
000020BE                          1629      
000020BE  0407 002F               1630      SUB.B   #47,D7      ; Balance out our D7 from ASCII conversion
000020C2  E39E                    1631      ROL.L   #1,D6       ; Rotate one bit to the right  
000020C4  BE3C 0008               1632      CMP.B   #8,D7       ; Check if we've hit A8
000020C8  6700 002E               1633      BEQ     ENDEAMOVEMPD  ; If we have, break to the end
000020CC  0806 0000               1634      BTST    #$00,D6     ; Check the far right bit
000020D0  6700 0026               1635      BEQ     ENDEAMOVEMPD ; If it is 0, we have no -Dn
000020D4                          1636  DDNEL    ; Decrement Dn End Loop  
000020D4  5247                    1637      ADDQ    #1,D7       ; Itterate D7
000020D6  E39E                    1638      ROL.L   #1,D6       ; Rotate one bit to the right  
000020D8  BE3C 0008               1639      CMP.B   #8,D7       ; Check if we've hit A8
000020DC  6700 0008               1640      BEQ     DNENLE      ; If we have, break the loop
000020E0  0806 0000               1641      BTST    #$00,D6     ; Check the far right bit
000020E4  66EE                    1642      BNE     DDNEL       ; If it isn't 0, continue checking    
000020E6                          1643  DNENLE
000020E6  5347                    1644      SUBQ    #1,D7
000020E8                          1645      
000020E8  12FC 002D               1646      MOVE.B  #'-',(A1)+
000020EC  12FC 0044               1647      MOVE.B  #'D',(A1)+
000020F0                          1648  
000020F0  0607 0030               1649      ADD.B   #48,D7      ; Add 48 into D7 to turn num 0 into ASCII 0
000020F4  12C7                    1650      MOVE.B  D7,(A1)+
000020F6  5641                    1651      ADDQ    #3,D1 
000020F8                          1652      ; If no Dn, skip to the end
000020F8                          1653  ENDEAMOVEMPD
000020F8  4E75                    1654      RTS
000020FA                          1655  
000020FA                          1656  ; If the EA is unknown
000020FA                          1657  EAUNKN
000020FA  12FC 003C               1658      MOVE.B  #'<',(A1)+  ; We did this byte-by-byte in case A1 is at an odd register
000020FE  12FC 0045               1659      MOVE.B  #'E',(A1)+
00002102  12FC 0041               1660      MOVE.B  #'A',(A1)+
00002106  12FC 003E               1661      MOVE.B  #'>',(A1)+
0000210A  5841                    1662      ADDQ    #4,D1
0000210C  4E75                    1663      RTS
0000210E                          1664  
0000210E                          1665  
0000210E                          1666  
0000210E                          1667  
0000210E                          1668  
0000210E                          1669  
0000210E                          1670  
0000210E                          1671  
0000210E                          1672  -------------------- end include --------------------
0000210E                          1673      
0000210E  FFFF FFFF               1674      SIMHALT             ; halt simulator
00002112                          1675  
00002112                          1676  * Put variables and constants here
00002112                          1677  
00002112                          1678      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AASD                1D48
AASLSRO             1D24
AASLSRODL           1D7C
AASLSRODR           1D66
AASLSROOP           1D82
ADDADDA             1B28
ADDAL               1BF2
ADDAN               1C04
ADDAW               1BE0
ADDBDN              1B98
ADDBEA              1BCE
ADDI                1480
ADDI8               1494
ADDIB               14E4
ADDIL               1504
ADDIOP              1514
ADDIW               14F4
ADDLDN              1B74
ADDLEA              1BAA
ADDWDN              1B86
ADDWEA              1BBC
ALSD                1D52
AND                 1A2A
ANDBDN              1AE8
ANDBEA              1A7E
ANDDN               1AFA
ANDEA               1A8E
ANDLDN              1AC4
ANDLEA              1A5E
ANDWDN              1AD6
ANDWEA              1A6E
AROD                1D5C
ASD                 1C68
ASLSRO              1C34
ASLSROB             1CC8
ASLSRODL            1CA0
ASLSRODR            1C86
ASLSROIR            1CD4
ASLSROIRDN          1CF6
ASLSROOP            1CFC
ASLSROSIZE          1CAA
ASLSROW             1CD0
BAD_EVEN            10D2
BAD_LENGTH          1094
BCC                 177A
BCC16               1806
BCC32               1806
BCCOP               179E
BCCSIZE             17C8
BGTOP               17AC
BLEOP               17BA
CHECK31             1052
CLEARMEMORY         107C
CLR                 15D2
CLRB                15FE
CLRL                162A
CLROP               1640
CLRW                1614
CMP                 193E
CMPB                1964
CMPL                1990
CMPOP               19A6
CMPW                197A
CNRJML              158A
COUNTER             1404
CR                  D
DANEL               204E
DANELE              2060
DANSL               201A
DDNEL               20D4
DDNSL               208E
DIVU                185A
DNENLE              20E6
DNOA                207A
DNOA2               20AE
DNOEA               207E
EA111               1EEC
EAALA               1ECE
EAAN                1E52
EAANI               1E60
EAAPOST             1E76
EAAPRE              1E90
EAAWA               1EBC
EADIGIT             1F16
EADN                1E44
EAGETDSTEA          1E08
EAGETSRCEA          1DC8
EAHEXTOASCII        1F02
EAID                1EAA
EAMOVEMPOSTI        1F26
EAMOVEMPRED         2010
EAUNKN              20FA
ENDEAMOVEMPD        20F8
ENDEAMOVEMPI        200E
ENDINGADDRESS       1400
ENDLOOP             1118
ENTERCHECK          105E
ENTERPROMPT         136E
FAIL_INPUT          1328
HEXEND              12AB
HEXSTART            1255
IANEL               1F64
IANELE              1F76
IANSL               1F30
IDNEL               1FEA
IDNSL               1FA4
INENLE              1FFC
INOA                1F90
INOA2               1FC4
INOEA               1F94
INTROMSG            1238
IOASCIITOHEX        10E8
IOASCIITOHEX2       114C
IODIGIT             1214
IODONE              1222
IOHEXTOASCII        1200
IOINTRO             100C
IOLOOP              101A
IOORTAG             10FA
IOORTAG2            115E
IOSTRINGLOC         100
JSR                 1692
LEA                 1738
LENGTH_CHECK        107C
LF                  A
LSD                 1C72
MOVEB               152C
MOVEL               154C
MOVEM               16BC
MOVEML              16E2
MOVEMOP             16E8
MOVEMPOSTI          171C
MOVEMPRED           1700
MOVEMW              16D8
MOVEOP              155C
MOVEQ               1808
MOVEW               153C
MULS                19EE
MULSAND             19DC
NOP                 165E
OPGETCODE           1408
OUTPUTOPCODE        1190
OUTRO               131E
RES                 1300
ROD                 1C7C
RTS                 1678
SPC                 130E
START               1000
STARTADDRESS        13FC
STARTGTEND          13B2
STARTLESSTHNEND     10A6
SUB                 1896
SUBBDN              192C
SUBBEA              18F6
SUBLDN              1908
SUBLEA              18D2
SUBWDN              191A
SUBWEA              18E4
TEST_ODD            10B8
UNKEA               1314
UNKNOWN             1DA4
