00000000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.03
Created On: 3/8/2016 4:33:15 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : IO
00000000                             3  * Written by : Circles
00000000                             4  * Date       : ##/##/16
00000000                             5  * Description: Input Output File
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  *-------Code for output-------
00000000  52B9 00000374              9  IOINTRO         ADD.L   #$00000001,COUNTER
00000006  43F9 00000236             10                  LEA     IntroMsg,A1        Display the intro
0000000C  103C 000E                 11                  MOVE.B  #14, D0
00000010  4E4F                      12                  TRAP    #15
Line 13 ERROR: Invalid addressing mode
00000012                            13                  CMP.L   COUNTER,#$00000001
00000012  6EEC                      14                  BGT     IOINTRO
00000014                            15  
00000014  43F9 00000253             16  IOLOOP          LEA     HexStart,A1        Display the prompt and loop it
0000001A  103C 000E                 17                  MOVE.B  #14,D0          
0000001E  4E4F                      18                  TRAP    #15   
00000020  54B9 00000374             19                  ADD.L   #$00000002,COUNTER  
00000026                            20  
00000026                            21  *-------Code for input-------
00000026  43F9 00000100             22                  LEA     IOStringLoc,A1     Store the string of our user input at StartAddress,A1 
0000002C  103C 0002                 23                  MOVE.B  #2,D0              uses Trap #15, Task 2
00000030  4E4F                      24                  TRAP    #15              
00000032                            25          
00000032  B2BC 00000001             26                  CMP.L   #1,D1              Compares D1 to the number 1 (eg. String length of 1)
00000038  6700 01E6                 27                  BEQ     IODONE             Branch to DONE if they are equal
0000003C                            28          
0000003C  4284                      29                  CLR.L   D4                 Ensure our counter (D4) is 0 
0000003E                            30  
0000003E  4EB9 0000008C             31                  JSR     LENGTH_CHECK 
00000044  4282                      32                  CLR.L   D2  
00000046  BA3C 0001                 33                  CMP.B   #1,D5              if 1 then it passed the tests         
0000004A                            34                  
0000004A  6700 0096                 35                  BEQ     IOASCIItoHEX
0000004E  60C4                      36                  BRA     IOLOOP
00000050                            37                  
00000050  0CB9 0000001D 00000374    38  CHECK31         CMP.L   #$0000001D,COUNTER compare the counter to 29
0000005A  6E00 0004                 39                  BGT     ENTERCHECK         counter is at at least 30
0000005E  4E75                      40                  RTS                        counter is still low
00000060                            41  
00000060  43F9 00000374             42  ENTERCHECK      LEA     ENTERPROMPT,A1     display the enter prompt
00000066  123C 000E                 43                  MOVE.B  #14,D1
0000006A  4E4F                      44                  TRAP    #15
0000006C                            45                  
0000006C  2E01                      46                  MOVE.L  D1,D7              store what was previously in D1
0000006E                            47                  
0000006E  123C 0002                 48                  MOVE.B  #2,D1              wait for the user to hit enter
00000072  4E4F                      49                  TRAP    #15
00000074  06B9 00000000 00000374    50                  ADD.L   #$00000000,COUNTER clear the counter
0000007E  52B9 00000374             51                  ADD.L   #$00000001,COUNTER add one to the counter
00000084                            52                  
00000084  4281                      53                  CLR.L   D1
00000086  2207                      54                  MOVE.L  D7,D1              move what was in D1 at the start back
00000088  4287                      55                  CLR.L   D7
0000008A                            56                  
0000008A  4E75                      57                  RTS
0000008C                            58                  
0000008C  4285                      59  LENGTH_CHECK    CLR.L   D5                 store the result of the test
0000008E  7C00                      60                  MOVEQ   #$0,D6             make D6 0
00000090  B206                      61                  CMP.B   D6,D1              see if null
00000092  6700 0010                 62                  BEQ     BAD_LENGTH         if null then branch to bad input
00000096  0C41 0008                 63                  CMPI    #$8,D1             see if it is more than 8 characters long
0000009A  6E00 0008                 64                  BGT     BAD_LENGTH         if more than 8 branch to bad input
0000009E  1A3C 0001                 65                  MOVE.B  #$1,D5             passed the length checks so move 1
000000A2  4E75                      66                  RTS                        go back
000000A4                            67                  
000000A4  7A00                      68  BAD_LENGTH      MOVEQ   #$0,D5             did not pass the test
000000A6  43F9 00000326             69                  LEA     FAIL_INPUT,A1      load bad input message
000000AC  103C 000E                 70                  MOVE.B  #14,D0          
000000B0  4E4F                      71                  TRAP    #15 
000000B2  4E75                      72                  RTS                        go back
000000B4                            73                  
000000B4  4286                      74  TEST_ODD        CLR.L   D6           
000000B6  4285                      75                  CLR.L   D5
000000B8  7A02                      76                  MOVE.L  #$00000002,D5      divide by 2 to see remainder
000000BA  2C02                      77                  MOVE.L  D2,D6              create a copy of the input in D7
000000BC  8CC5                      78                  DIVU    D5,D6              divide the hex number by 2
000000BE  4846                      79                  SWAP    D6                 put the remainder on the far left
000000C0  BC3C 0001                 80                  CMP.B   #1,D6              see if the remainder is one
000000C4  6700 0008                 81                  BEQ     BAD_EVEN           branch to to even
000000C8  4286                      82                  CLR.L   D6
000000CA  4285                      83                  CLR.L   D5
000000CC  4E75                      84                  RTS
000000CE                            85                  
000000CE                            86                  
000000CE  4285                      87  BAD_EVEN        CLR.L   D5
000000D0  4286                      88                  CLR.L   D6
000000D2  43F9 00000326             89                  LEA     FAIL_INPUT,A1      load bad input message  
000000D8  103C 000E                 90                  MOVE.B  #14,D0          
000000DC  4E4F                      91                  TRAP    #15 
000000DE  6000 FF34                 92                  BRA     IOLOOP             go back to the beginning
000000E2                            93                  
000000E2                            94              
000000E2  5244                      95  IOASCIItoHEX    ADDQ    #1,D4
000000E4  E98A                      96                  LSL.L   #4,D2              Scoot D2 a nybble
000000E6  1619                      97                  MOVE.B  (A1)+,D3           Move a Byte from A1's address to D3
000000E8  0403 0030                 98                  SUB.B   #48,D3             Sub 48 to turn ASCII 0 into binary 0
000000EC  B63C 0009                 99                  CMP.B   #9,D3              If our number is greater than 9..
000000F0  6F02                     100                  BLE.S   IOORTAG            .. it must be a character; A-F: 
000000F2  5F03                     101                  SUB.B   #7,D3              Sub 7 to turn A into 10
000000F4  8403                     102  IOORTAG         OR.B    D3,D2              Store our nybble into D2
000000F6  B204                     103                  CMP.B   D4,D1              See if we've read all the characters
000000F8  66E8                     104                  BNE.S   IOASCIItoHEX       Continue if we haven't
000000FA                           105              
000000FA                           106              
000000FA  23FC 00000000 0000036C   107                  MOVE.L  #0,StartAddress
00000104  23C2 0000036C            108                  MOVE.L  D2,StartAddress    Store our StartAddress
0000010A                           109                  
0000010A  4EB8 00B4                110                  JSR     TEST_ODD          ******************** need test_odd to not always branch to outputopcode **************************
0000010E                           111                  
0000010E  4281                     112                  CLR.L   D1
00000110  4282                     113                  CLR.L   D2
00000112                           114  ************************ Ending Address ************************
00000112                           115                  ;The Labels of this section are the same as the previous (different names)
00000112                           116                  ;due to errors that I was getting with bracnhing and overwriting 
00000112                           117                  ;data registers
00000112                           118                  
00000112  43F9 000002A9            119  ENDLOOP         LEA     HexEnd,A1          load the ending address prompt
00000118  103C 000E                120                  MOVE.B  #14,D0
0000011C  4E4F                     121                  TRAP    #15  
0000011E                           122                  
0000011E  43F9 00000100            123                  LEA     IOStringLoc,A1     Store the string of our user input at StartAddress,A1 
00000124  103C 0002                124                  MOVE.B  #2,D0              uses Trap #15, Task 2
00000128  4E4F                     125                  TRAP    #15              
0000012A                           126          
0000012A  B2BC 00000001            127                  CMP.L   #1,D1              Compares D1 to the number 1 (eg. String length of 1)
00000130  6700 00EE                128                  BEQ     IODONE             Branch to DONE if they are equal
00000134                           129          
00000134  4284                     130                  CLR.L   D4                 Ensure our counter (D4) is 0 
00000136                           131  
00000136  4EB8 008C                132                  JSR     LENGTH_CHECK       check to make sure the length is ok
0000013A  BA3C 0001                133                  CMP.B   #1,D5              if 1 then it passed the tests         
0000013E                           134  
0000013E  6700 0004                135                  BEQ     IOASCIItoHEX2      convert to hex
00000142  60CE                     136                  BRA     ENDLOOP
00000144                           137                  
00000144  5244                     138  IOASCIItoHEX2   ADDQ    #1,D4
00000146  E98A                     139                  LSL.L   #4,D2              Scoot D2 a nybble
00000148  1619                     140                  MOVE.B  (A1)+,D3           Move a Byte from A1's address to D3
0000014A  0403 0030                141                  SUB.B   #48,D3             Sub 48 to turn ASCII 0 into binary 0
0000014E  B63C 0009                142                  CMP.B   #9,D3              If our number is greater than 9..
00000152  6F02                     143                  BLE.S   IOORTAG2           .. it must be a character; A-F: 
00000154  5F03                     144                  SUB.B   #7,D3              Sub 7 to turn A into 10
00000156  8403                     145  IOORTAG2        OR.B    D3,D2              Store our nybble into D2
00000158  B204                     146                  CMP.B   D4,D1              See if we've read all the characters
0000015A  66E8                     147                  BNE.S   IOASCIItoHEX2      Continue if we haven't
0000015C                           148              
0000015C                           149    
0000015C  23FC 00000000 00000370   150                  MOVE.L  #0,EndingAddress
00000166  23C2 00000370            151                  MOVE.L  D2,EndingAddress   Store our EndingAddress
0000016C                           152                  
0000016C  4EB8 00B4                153                  JSR     TEST_ODD
00000170                           154                  
00000170  4281                     155                  CLR.L   D1
00000172                           156          
00000172                           157  *-------Output Opcode------- 
00000172  23FC 00000000 00000100   158  OUTPUTOPCODE    MOVE.L  #0,IOStringLoc     ********** Testing purposes ********** 
0000017C                           159          
0000017C                           160                  ; <Testing section>        
0000017C  2479 0000036C            161                  MOVE.L  StartAddress,A2    Push our start address into A2 
00000182  24FC 48A7FFFE            162                  MOVE.L  #$48A7FFFE,(A2)+   Push OpCode for MOVEM.L (A7)+,A0-A6/D0-D7 into our start address
00000188  34FC 3200                163                  MOVE.W  #$3200,(A2)+       Push OpCode for Move.W D0,D1 into our start address
0000018C  34FC 2200                164                  MOVE.W  #$2200,(A2)+       Push OpCode for Move.L D0,D1 into our start address
00000190                           165                  ; </Testing section>
00000190                           166          
00000190  2479 0000036C            167                  MOVE.L  StartAddress,A2    Push our start address into A2 
00000196  43F9 00000100            168                  LEA     IOStringLoc,A1     Load our IOStringLoc into A1 for string contruction purposes
0000019C                           169          
0000019C                           170                  ; Here we could loop all of the addresses of A2 until End, or something.
0000019C  22FC 23232323            171                  MOVE.L  #'####',(A1)+      Move our "OpCode location" into our IOStringLoc <---- THIS NEEDS TO BE HEX
000001A2  5841                     172                  ADDQ    #4,D1              We added 4 new characters                       <---- THIS NEEDS TO BE 8
000001A4  22FC 20202020            173                  MOVE.L  #'    ',(A1)+      Add a spacer into our IOStringLoc
000001AA  5841                     174                  ADDQ    #4,D1              We added 4 bytes, aka 4 spaces
000001AC                           175          
Line 176 ERROR: Undefined symbol
000001AC  4EB9 004DBAA6            176                  JSR OPGETCODE              Get the OpCode pointed at by A2, it's string stored in IOStringLoc
000001B2                           177                  
000001B2  43F9 00000100            178                  LEA     IOStringLoc,A1     Now that we've populated the string, load it's beginning
000001B8  103C 0001                179                  MOVE.B  #1,D0              Trap task 1 prints a string at A1 with #D1 bytes.
000001BC  4E4F                     180                  TRAP    #15
000001BE                           181          
000001BE                           182                  ;LEA     UnkEA,A1          TEMPORARY Print "<EA>,<EA>"
000001BE                           183                  ;MOVE.B  #13,D0              
000001BE                           184                  ;TRAP    #15                 
000001BE                           185          
000001BE  43F9 0000030C            186                  LEA     SPC,A1             Puts the space before the opCode
000001C4  103C 000D                187                  MOVE.B  #13,D0
000001C8  4E4F                     188                  TRAP    #15
000001CA                           189                  
000001CA                           190                  
000001CA                           191  *-------End Output Opcode------- 
000001CA                           192  
000001CA  43F9 000002FE            193                  LEA     RES,A1             Output the beginning of the message
000001D0  103C 000E                194                  MOVE.B  #14,D0  
000001D4  4E4F                     195                  TRAP    #15
000001D6                           196  
000001D6                           197  *-------Output User Input------- 
000001D6                           198                  ; The following outputs the input, converting what we've saved in HEX to ASCII
000001D6                           199                  ; We won't need this in the final version, but the below code should be handy
000001D6                           200                  ;  for print out EA values
000001D6  2439 0000036C            201                  MOVE.L  StartAddress,D2    Ensure our address is actually at D2
000001DC  7208                     202                  MOVEQ   #8,D1              There are 8 characters in the hex of our address
000001DE  4284                     203                  CLR.L   D4                 Ensure our counter (D4) is 0
000001E0  43F9 00000100            204                  LEA     IOStringLoc,A1     Load our IO String location, to store our output at  
000001E6                           205  
000001E6                           206          
000001E6  5244                     207  IOHEXtoASCII    ADDQ    #1,D4
000001E8  E99A                     208                  ROL.L   #4,D2              Get the left-most nyblle to the front..
000001EA  1602                     209                  MOVE.B  D2,D3              .. Put the front-most byte into D3    
000001EC  C63C 000F                210                  AND.B   #$0F,D3            Distill D3 down to the original left-most nybble
000001F0  B63C 0009                211                  CMP.B   #9,D3              See if our number is greater than 9..
000001F4  6F00 0004                212                  BLE     IODIGIT            If it is 9 or less, it's a digit..
000001F8  5E03                     213                  ADD.B   #7,D3              Otherwise it is a digit, and needs an additional 7
000001FA  0603 0030                214  IODIGIT         ADD.B   #48,D3             We now how the nybble's ASCII code
000001FE  12C3                     215                  MOVE.B  D3,(A1)+           Move the ASCII code into the output string at A1
00000200  B204                     216                  CMP.B   D4,D1              See if we've read all the characters
00000202  66E2                     217                  BNE.S   IOHEXtoASCII       Continue if we haven't
00000204                           218          
00000204  43F9 00000100            219                  LEA     IOStringLoc,A1     Now that we've populated the string, load it's beginning
0000020A  103C 0001                220                  MOVE.B  #1,D0              Trap task 1 prints a string at A1 with #D1 bytes.
0000020E  4E4F                     221                  TRAP    #15
00000210                           222  *-------End User Input------- 
00000210                           223  
00000210  43F9 0000030C            224                  LEA     SPC,A1             Puts the space after the number
00000216  103C 000D                225                  MOVE.B  #13,D0
0000021A  4E4F                     226                  TRAP    #15
0000021C                           227  
0000021C  6000 FDF6                228                  BRA     IOLOOP
00000220                           229          
00000220                           230  *-------Finishes the program-        
00000220  43F9 0000031C            231  IODONE          LEA     OUTRO,A1           Display the ending message 
00000226  103C 000E                232                  MOVE.B  #14,D0
0000022A  4E4F                     233                  TRAP    #15
0000022C  103C 0009                234                  MOVE.B  #9,D0
00000230  4E4F                     235                  TRAP    #15                Halt Simulator
00000232                           236          
00000232  FFFF FFFF                237                  SIMHALT
00000236                           238          
00000236  =0000000D                239  CR              EQU     $0D         
00000236  =0000000A                240  LF              EQU     $0A 
00000236  =00000100                241  IOStringLoc     EQU     $0100              This is where we will store the string of the user input, and other strings
00000236                           242  
00000236                           243  *-------Various outputs------
00000236= 54 65 61 6D 20 43 ...    244  IntroMsg        DC.B    'Team Circles Disassembler ',CR,LF,0     Intro
00000253= 45 6E 74 65 72 20 ...    245  HexStart        DC.B    'Enter a starting address in hex of length 8 or less and even, or',CR,LF,'type in 0 to quit: ',0 Prompt for the user
000002A9= 45 6E 74 65 72 20 ...    246  HexEnd          DC.B    'Enter an ending address in hex of length 8 or less and even, or',CR,LF,'type in 0 to quit: ',0 Prompt for the user
000002FE= 59 6F 75 20 74 79 ...    247  RES             DC.B    'You typed in ',0                        Response to the user
0000030C= 20 20 20 20 20 00        248  SPC             DC.B    '     ',0                                tab
00000312= 3C 45 41 3E 2C 3C ...    249  UnkEA           DC.B    '<EA>,<EA>',0                            Interim message for unkown EAs.
0000031C= 47 6F 6F 64 62 79 ...    250  OUTRO           DC.B    'Goodbye !',0                            Outro message
00000326= 49 20 61 6D 20 73 ...    251  FAIL_INPUT      DC.B    'I am sorry, but you typed an address that did not meet the criteria',CR,LF,0 
0000036C                           252  StartAddress    DS.L    1
00000370                           253  EndingAddress   DS.L    1
00000374                           254  COUNTER         DS.L    0 keep track of the lines on the screen
00000374= 54 68 65 20 73 63 ...    255  ENTERPROMPT     DC.B    'The screen limit has been reached, please press enter to continue',CR,LF,0
000003B8                           256  
000003B8                           257  * Put variables and constants herevv
000003B8                           258  
000003B8                           259  
000003B8                           260  
000003B8                           261  
000003B8                           262  
000003B8                           263  
Line 264 WARNING: END directive missing, starting address not set

2 errors detected
1 warning generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BAD_EVEN            CE
BAD_LENGTH          A4
CHECK31             50
COUNTER             374
CR                  D
ENDINGADDRESS       370
ENDLOOP             112
ENTERCHECK          60
ENTERPROMPT         374
FAIL_INPUT          326
HEXEND              2A9
HEXSTART            253
INTROMSG            236
IOASCIITOHEX        E2
IOASCIITOHEX2       144
IODIGIT             1FA
IODONE              220
IOHEXTOASCII        1E6
IOINTRO             0
IOLOOP              14
IOORTAG             F4
IOORTAG2            156
IOSTRINGLOC         100
LENGTH_CHECK        8C
LF                  A
OUTPUTOPCODE        172
OUTRO               31C
RES                 2FE
SPC                 30C
STARTADDRESS        36C
TEST_ODD            B4
UNKEA               312
