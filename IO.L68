00000000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.03
Created On: 3/9/2016 11:57:52 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : IO
00000000                             3  * Written by : Circles
00000000                             4  * Date       : ##/##/16
00000000                             5  * Description: Input Output File
00000000                             6  *-----------------------------------------------------------
00000000  47F9 0000039C              7                  LEA     COUNTER,A3
00000006  26BC 00000000              8                  MOVE.L  #0,(A3)
0000000C                             9                  
0000000C                            10  *-------Code for output-------
0000000C  5293                      11  IOINTRO         ADD.L   #$00000001,(A3)    COUNTER++
0000000E  43F9 0000025E             12                  LEA     IntroMsg,A1        Display the intro
00000014  103C 000E                 13                  MOVE.B  #14, D0
00000018  4E4F                      14                  TRAP    #15
0000001A                            15  
0000001A  43F9 0000027B             16  IOLOOP          LEA     HexStart,A1        Display the prompt and loop it
00000020  103C 000E                 17                  MOVE.B  #14,D0          
00000024  4E4F                      18                  TRAP    #15   
00000026  5493                      19                  ADD.L   #$00000002,(A3)    COUNTER++ COUNTER++
00000028                            20  
00000028                            21  *-------Code for input-------
00000028  43F9 00000100             22                  LEA     IOStringLoc,A1     Store the string of our user input at StartAddress,A1 
0000002E  103C 0002                 23                  MOVE.B  #2,D0              uses Trap #15, Task 2
00000032  4E4F                      24                  TRAP    #15              
00000034                            25          
00000034  B2BC 00000001             26                  CMP.L   #1,D1              Compares D1 to the number 1 (eg. String length of 1)
0000003A  6700 020C                 27                  BEQ     IODONE             Branch to DONE if they are equal
0000003E                            28          
0000003E  4284                      29                  CLR.L   D4                 Ensure our counter (D4) is 0 
00000040                            30  
00000040  4EB9 00000082             31                  JSR     LENGTH_CHECK 
00000046  4282                      32                  CLR.L   D2  
00000048  BA3C 0001                 33                  CMP.B   #1,D5              if 1 then it passed the tests         
0000004C                            34                  
0000004C  6700 00A0                 35                  BEQ     IOASCIItoHEX
00000050  60C8                      36                  BRA     IOLOOP
00000052                            37                  
00000052  0C93 0000001E             38  CHECK31         CMP.L   #$0000001E,(A3)    compare the counter to 29
00000058  6E00 0004                 39                  BGT     ENTERCHECK         counter is at at least 30
0000005C  4E75                      40                  RTS                        counter is still low
0000005E                            41  
0000005E  43F9 000003A0             42  ENTERCHECK      LEA     ENTERPROMPT,A1     display the enter prompt
00000064  103C 000E                 43                  MOVE.B  #14,D0
00000068  4E4F                      44                  TRAP    #15
0000006A                            45                  
0000006A  2E01                      46                  MOVE.L  D1,D7             store what was previously in D1
0000006C                            47                  
0000006C                            48   
0000006C  103C 0002                 49                  MOVE.B  #2,D0              wait for the user to hit enter
00000070  4E4F                      50                  TRAP    #15
00000072                            51                  
00000072  26BC 00000000             52                  MOVE.L  #0,(A3)            clear the counter
00000078  5293                      53                  ADD.L   #$00000001,(A3)    add one to the counter
0000007A                            54                  
0000007A  4281                      55                  CLR.L   D1
0000007C  2207                      56                  MOVE.L  D7,D1              move what was in D1 at the start back
0000007E  4287                      57                  CLR.L   D7
00000080                            58                  
00000080  4E75                      59                  RTS
00000082                            60                  
00000082  4285                      61  LENGTH_CHECK    CLR.L   D5                 store the result of the test
00000084  7C00                      62                  MOVEQ   #$0,D6             make D6 0
00000086  B206                      63                  CMP.B   D6,D1              see if null
00000088  6700 0010                 64                  BEQ     BAD_LENGTH         if null then branch to bad input
0000008C  0C41 0008                 65                  CMPI    #$8,D1             see if it is more than 8 characters long
00000090  6E00 0008                 66                  BGT     BAD_LENGTH         if more than 8 branch to bad input
00000094  1A3C 0001                 67                  MOVE.B  #$1,D5             passed the length checks so move 1
00000098  4E75                      68                  RTS                        go back
0000009A                            69                  
0000009A  7A00                      70  BAD_LENGTH      MOVEQ   #$0,D5             did not pass the test
0000009C  43F9 0000034E             71                  LEA     FAIL_INPUT,A1      load bad input message
000000A2  103C 000E                 72                  MOVE.B  #14,D0          
000000A6  4E4F                      73                  TRAP    #15 
000000A8  5293                      74                  ADD.L   #$00000001,(A3)    COUNTER++
000000AA  4E75                      75                  RTS                        go back
000000AC                            76                  
000000AC  43F9 000003E4             77  STARTLESSTHNEND LEA     STARTGTEND,A1      load the error 
000000B2  103C 000E                 78                  MOVE.B  #14,D0
000000B6  4E4F                      79                  TRAP    #15
000000B8  5293                      80                  ADD.L   #$00000001,(A3)    COUNTER++
000000BA  6000 FF5E                 81                  BRA     IOLOOP             go back to the start
000000BE                            82  
000000BE                            83  
000000BE  4286                      84  TEST_ODD        CLR.L   D6           
000000C0  4285                      85                  CLR.L   D5
000000C2  7A02                      86                  MOVE.L  #$00000002,D5      divide by 2 to see remainder
000000C4  2C02                      87                  MOVE.L  D2,D6              create a copy of the input in D7
000000C6  8CC5                      88                  DIVU    D5,D6              divide the hex number by 2
000000C8  4846                      89                  SWAP    D6                 put the remainder on the far left
000000CA  BC3C 0001                 90                  CMP.B   #1,D6              see if the remainder is one
000000CE  6700 0008                 91                  BEQ     BAD_EVEN           branch to to even
000000D2  4286                      92                  CLR.L   D6
000000D4  4285                      93                  CLR.L   D5
000000D6  4E75                      94                  RTS
000000D8                            95                  
000000D8                            96                  
000000D8  4285                      97  BAD_EVEN        CLR.L   D5
000000DA  4286                      98                  CLR.L   D6
000000DC  43F9 0000034E             99                  LEA     FAIL_INPUT,A1      load bad input message  
000000E2  103C 000E                100                  MOVE.B  #14,D0          
000000E6  4E4F                     101                  TRAP    #15 
000000E8  5293                     102                  ADD.L   #$00000001,(A3)    COUNTER++
000000EA  6000 FF2E                103                  BRA     IOLOOP             go back to the beginning
000000EE                           104                  
000000EE                           105              
000000EE  5244                     106  IOASCIItoHEX    ADDQ    #1,D4
000000F0  E98A                     107                  LSL.L   #4,D2              Scoot D2 a nybble
000000F2  1619                     108                  MOVE.B  (A1)+,D3           Move a Byte from A1's address to D3
000000F4  0403 0030                109                  SUB.B   #48,D3             Sub 48 to turn ASCII 0 into binary 0
000000F8  B63C 0009                110                  CMP.B   #9,D3              If our number is greater than 9..
000000FC  6F02                     111                  BLE.S   IOORTAG            .. it must be a character; A-F: 
000000FE  5F03                     112                  SUB.B   #7,D3              Sub 7 to turn A into 10
00000100  8403                     113  IOORTAG         OR.B    D3,D2              Store our nybble into D2
00000102  B204                     114                  CMP.B   D4,D1              See if we've read all the characters
00000104  66E8                     115                  BNE.S   IOASCIItoHEX       Continue if we haven't
00000106                           116              
00000106                           117              
00000106  23FC 00000000 00000394   118                  MOVE.L  #0,StartAddress
00000110  23C2 00000394            119                  MOVE.L  D2,StartAddress    Store our StartAddress
00000116                           120                  
00000116  4EB8 00BE                121                  JSR     TEST_ODD          ******************** need test_odd to not always branch to outputopcode **************************
0000011A                           122                  
0000011A  4281                     123                  CLR.L   D1
0000011C  4282                     124                  CLR.L   D2
0000011E                           125  ************************ Ending Address ************************
0000011E                           126                  ;The Labels of this section are the same as the previous (different names)
0000011E                           127                  ;due to errors that I was getting with bracnhing and overwriting 
0000011E                           128                  ;data registers
0000011E                           129                  
0000011E  43F9 000002D1            130  ENDLOOP         LEA     HexEnd,A1          load the ending address prompt
00000124  103C 000E                131                  MOVE.B  #14,D0
00000128  4E4F                     132                  TRAP    #15  
0000012A  5493                     133                  ADD.L   #$00000002,(A3)
0000012C                           134                  
0000012C  43F9 00000100            135                  LEA     IOStringLoc,A1     Store the string of our user input at StartAddress,A1 
00000132  103C 0002                136                  MOVE.B  #2,D0              uses Trap #15, Task 2
00000136  4E4F                     137                  TRAP    #15              
00000138                           138          
00000138  B2BC 00000001            139                  CMP.L   #1,D1              Compares D1 to the number 1 (eg. String length of 1)
0000013E  6700 0108                140                  BEQ     IODONE             Branch to DONE if they are equal
00000142                           141          
00000142  4284                     142                  CLR.L   D4                 Ensure our counter (D4) is 0 
00000144                           143  
00000144  4EB8 0082                144                  JSR     LENGTH_CHECK       check to make sure the length is ok
00000148  BA3C 0001                145                  CMP.B   #1,D5              if 1 then it passed the tests         
0000014C                           146  
0000014C  6700 0004                147                  BEQ     IOASCIItoHEX2      convert to hex
00000150  60CC                     148                  BRA     ENDLOOP
00000152                           149                  
00000152  5244                     150  IOASCIItoHEX2   ADDQ    #1,D4
00000154  E98A                     151                  LSL.L   #4,D2              Scoot D2 a nybble
00000156  1619                     152                  MOVE.B  (A1)+,D3           Move a Byte from A1's address to D3
00000158  0403 0030                153                  SUB.B   #48,D3             Sub 48 to turn ASCII 0 into binary 0
0000015C  B63C 0009                154                  CMP.B   #9,D3              If our number is greater than 9..
00000160  6F02                     155                  BLE.S   IOORTAG2           .. it must be a character; A-F: 
00000162  5F03                     156                  SUB.B   #7,D3              Sub 7 to turn A into 10
00000164  8403                     157  IOORTAG2        OR.B    D3,D2              Store our nybble into D2
00000166  B204                     158                  CMP.B   D4,D1              See if we've read all the characters
00000168  66E8                     159                  BNE.S   IOASCIItoHEX2      Continue if we haven't
0000016A                           160              
0000016A                           161    
0000016A  23FC 00000000 00000398   162                  MOVE.L  #0,EndingAddress
00000174  23C2 00000398            163                  MOVE.L  D2,EndingAddress   Store our EndingAddress
0000017A                           164                  
0000017A  4EB8 00BE                165                  JSR     TEST_ODD           tezt if the ending address is odd
0000017E                           166                  
0000017E  2479 00000394            167                  MOVE.L  StartAddress,A2    Push our start address into A2
00000184                           168                  
00000184  B5F9 00000398            169                  CMP.L   EndingAddress,A2
0000018A  6E00 FF20                170                  BGT     STARTLESSTHNEND
0000018E                           171                  
0000018E  4281                     172                  CLR.L   D1
00000190                           173          
00000190                           174                  
00000190  24FC 48A7FFFE            175                  MOVE.L  #$48A7FFFE,(A2)+   Push OpCode for MOVEM.L (A7)+,A0-A6/D0-D7 into our start address
00000196  34FC 3200                176                  MOVE.W  #$3200,(A2)+       Push OpCode for Move.W D0,D1 into our start address
0000019A  34FC 2200                177                  MOVE.W  #$2200,(A2)+       Push OpCode for Move.L D0,D1 into our start address
0000019E                           178                  
0000019E  2479 00000394            179                  MOVE.L  StartAddress,A2    Push our start address into A2 
000001A4                           180  *-------Output Opcode------- 
000001A4  23FC 00000000 00000100   181  OUTPUTOPCODE    MOVE.L  #0,IOStringLoc     ********** Testing purposes ********** 
000001AE  4281                     182                  CLR.L   D1
000001B0                           183                  ; <Testing section>        
000001B0                           184  
000001B0                           185                  ; </Testing section>
000001B0                           186          
000001B0                           187  
000001B0  43F9 00000100            188                  LEA     IOStringLoc,A1     Load our IOStringLoc into A1 for string contruction purposes
000001B6                           189          
000001B6                           190                  ; Here we could loop all of the addresses of A2 until End, or something.
000001B6  22FC 23232323            191                  MOVE.L  #'####',(A1)+      Move our "OpCode location" into our IOStringLoc <---- THIS NEEDS TO BE HEX
000001BC  5841                     192                  ADDQ    #4,D1              We added 4 new characters                       <---- THIS NEEDS TO BE 8
000001BE  22FC 20202020            193                  MOVE.L  #'    ',(A1)+      Add a spacer into our IOStringLoc
000001C4  5841                     194                  ADDQ    #4,D1              We added 4 bytes, aka 4 spaces
000001C6                           195          
Line 196 ERROR: Undefined symbol
000001C6  4EB9 004DBAA6            196                  JSR OPGETCODE              Get the OpCode pointed at by A2, it's string stored in IOStringLoc
000001CC                           197                  
000001CC  43F9 00000100            198                  LEA     IOStringLoc,A1     Now that we've populated the string, load it's beginning
000001D2  103C 0001                199                  MOVE.B  #1,D0              Trap task 1 prints a string at A1 with #D1 bytes.
000001D6  4E4F                     200                  TRAP    #15
000001D8                           201          
000001D8                           202                  ;LEA     UnkEA,A1          TEMPORARY Print "<EA>,<EA>"
000001D8                           203                  ;MOVE.B  #13,D0              
000001D8                           204                  ;TRAP    #15                 
000001D8                           205          
000001D8  43F9 00000334            206                  LEA     SPC,A1             Puts the space before the opCode
000001DE  103C 000D                207                  MOVE.B  #13,D0
000001E2  4E4F                     208                  TRAP    #15
000001E4                           209                  
000001E4  5293                     210                  ADD.L   #$00000001,(A3)    COUNTER++
000001E6  4EB8 0052                211                  JSR     CHECK31
000001EA                           212                  
000001EA  B5F9 00000398            213                  CMP.L   EndingAddress,A2
000001F0  6DB2                     214                  BLT     OUTPUTOPCODE
000001F2                           215                  
000001F2                           216  *-------End Output Opcode------- 
000001F2                           217  
000001F2  43F9 00000326            218                  LEA     RES,A1             Output the beginning of the message
000001F8  103C 000E                219                  MOVE.B  #14,D0  
000001FC  4E4F                     220                  TRAP    #15
000001FE                           221  
000001FE                           222  *-------Output User Input------- 
000001FE                           223                  ; The following outputs the input, converting what we've saved in HEX to ASCII
000001FE                           224                  ; We won't need this in the final version, but the below code should be handy
000001FE                           225                  ;  for print out EA values
000001FE  2439 00000394            226                  MOVE.L  StartAddress,D2    Ensure our address is actually at D2
00000204  7208                     227                  MOVEQ   #8,D1              There are 8 characters in the hex of our address
00000206  4284                     228                  CLR.L   D4                 Ensure our counter (D4) is 0
00000208  43F9 00000100            229                  LEA     IOStringLoc,A1     Load our IO String location, to store our output at  
0000020E                           230  
0000020E                           231          
0000020E  5244                     232  IOHEXtoASCII    ADDQ    #1,D4
00000210  E99A                     233                  ROL.L   #4,D2              Get the left-most nyblle to the front..
00000212  1602                     234                  MOVE.B  D2,D3              .. Put the front-most byte into D3    
00000214  C63C 000F                235                  AND.B   #$0F,D3            Distill D3 down to the original left-most nybble
00000218  B63C 0009                236                  CMP.B   #9,D3              See if our number is greater than 9..
0000021C  6F00 0004                237                  BLE     IODIGIT            If it is 9 or less, it's a digit..
00000220  5E03                     238                  ADD.B   #7,D3              Otherwise it is a digit, and needs an additional 7
00000222  0603 0030                239  IODIGIT         ADD.B   #48,D3             We now how the nybble's ASCII code
00000226  12C3                     240                  MOVE.B  D3,(A1)+           Move the ASCII code into the output string at A1
00000228  B204                     241                  CMP.B   D4,D1              See if we've read all the characters
0000022A  66E2                     242                  BNE.S   IOHEXtoASCII       Continue if we haven't
0000022C                           243          
0000022C  43F9 00000100            244                  LEA     IOStringLoc,A1     Now that we've populated the string, load it's beginning
00000232  103C 0001                245                  MOVE.B  #1,D0              Trap task 1 prints a string at A1 with #D1 bytes.
00000236  4E4F                     246                  TRAP    #15
00000238                           247  *-------End User Input------- 
00000238                           248  
00000238  43F9 00000334            249                  LEA     SPC,A1             Puts the space after the number
0000023E  103C 000D                250                  MOVE.B  #13,D0
00000242  4E4F                     251                  TRAP    #15
00000244                           252  
00000244  6000 FDD4                253                  BRA     IOLOOP
00000248                           254          
00000248                           255  *-------Finishes the program-        
00000248  43F9 00000344            256  IODONE          LEA     OUTRO,A1           Display the ending message 
0000024E  103C 000E                257                  MOVE.B  #14,D0
00000252  4E4F                     258                  TRAP    #15
00000254  103C 0009                259                  MOVE.B  #9,D0
00000258  4E4F                     260                  TRAP    #15                Halt Simulator
0000025A                           261          
0000025A  FFFF FFFF                262                  SIMHALT
0000025E                           263          
0000025E  =0000000D                264  CR              EQU     $0D         
0000025E  =0000000A                265  LF              EQU     $0A 
0000025E  =00000100                266  IOStringLoc     EQU     $0100              This is where we will store the string of the user input, and other strings
0000025E                           267  
0000025E                           268  *-------Various outputs------
0000025E= 54 65 61 6D 20 43 ...    269  IntroMsg        DC.B    'Team Circles Disassembler ',CR,LF,0     Intro
0000027B= 45 6E 74 65 72 20 ...    270  HexStart        DC.B    'Enter a starting address in hex of length 8 or less and even, or',CR,LF,'type in 0 to quit: ',0 Prompt for the user
000002D1= 45 6E 74 65 72 20 ...    271  HexEnd          DC.B    'Enter an ending address in hex of length 8 or less and even, or',CR,LF,'type in 0 to quit: ',0 Prompt for the user
00000326= 59 6F 75 20 74 79 ...    272  RES             DC.B    'You typed in ',0                        Response to the user
00000334= 20 20 20 20 20 00        273  SPC             DC.B    '     ',0                                tab
0000033A= 3C 45 41 3E 2C 3C ...    274  UnkEA           DC.B    '<EA>,<EA>',0                            Interim message for unkown EAs.
00000344= 47 6F 6F 64 62 79 ...    275  OUTRO           DC.B    'Goodbye !',0                            Outro message
0000034E= 49 20 61 6D 20 73 ...    276  FAIL_INPUT      DC.B    'I am sorry, but you typed an address that did not meet the criteria',CR,LF,0 
00000394                           277  StartAddress    DS.L    1
00000398                           278  EndingAddress   DS.L    1
0000039C                           279  COUNTER         DS.L    1 keep track of the lines on the screen
000003A0= 54 68 65 20 73 63 ...    280  ENTERPROMPT     DC.B    'The screen limit has been reached, please press enter to continue',CR,LF,0
000003E4= 54 68 65 20 65 6E ...    281  STARTGTEND      DC.B    'The ending address was less than the starting address, please try again',CR,LF,0
0000042E                           282  
0000042E                           283  * Put variables and constants herevv
0000042E                           284  
0000042E                           285  
0000042E                           286  
0000042E                           287  
0000042E                           288  
0000042E                           289  
0000042E                           290  
0000042E                           291  
0000042E                           292  
0000042E                           293  
0000042E                           294  
0000042E                           295  
0000042E                           296  
Line 297 WARNING: END directive missing, starting address not set

1 error detected
1 warning generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BAD_EVEN            D8
BAD_LENGTH          9A
CHECK31             52
COUNTER             39C
CR                  D
ENDINGADDRESS       398
ENDLOOP             11E
ENTERCHECK          5E
ENTERPROMPT         3A0
FAIL_INPUT          34E
HEXEND              2D1
HEXSTART            27B
INTROMSG            25E
IOASCIITOHEX        EE
IOASCIITOHEX2       152
IODIGIT             222
IODONE              248
IOHEXTOASCII        20E
IOINTRO             C
IOLOOP              1A
IOORTAG             100
IOORTAG2            164
IOSTRINGLOC         100
LENGTH_CHECK        82
LF                  A
OUTPUTOPCODE        1A4
OUTRO               344
RES                 326
SPC                 334
STARTADDRESS        394
STARTGTEND          3E4
STARTLESSTHNEND     AC
TEST_ODD            BE
UNKEA               33A
