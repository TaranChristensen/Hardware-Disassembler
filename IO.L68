00000000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.03
Created On: 3/3/2016 3:21:20 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : IO
00000000                             3  * Written by : Circles
00000000                             4  * Date       : ##/##/16
00000000                             5  * Description: Input Output File
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  *-------Code for output-------
00000000  43F9 00000184              9  IOINTRO         LEA     IntroMsg,A1        Display the intro
00000006  103C 000E                 10                  MOVE.B  #14, D0
0000000A  4E4F                      11                  TRAP    #15
0000000C                            12  
0000000C  43F9 000001A1             13  IOLOOP          LEA     HexStart,A1        Display the prompt and loop it
00000012  103C 000E                 14                  MOVE.B  #14,D0          
00000016  4E4F                      15                  TRAP    #15       
00000018                            16  
00000018                            17  *-------Code for input-------
00000018  43F9 00000100             18                  LEA     IOStringLoc,A1     Store the string of our user input at StartAddress,A1 
0000001E  103C 0002                 19                  MOVE.B  #2,D0              uses Trap #15, Task 2
00000022  4E4F                      20                  TRAP    #15              
00000024                            21          
00000024  B2BC 00000001             22                  CMP.L   #1,D1              Compares D1 to the number 1 (eg. String length of 1)
0000002A  6700 0142                 23                  BEQ     IODONE             Branch to DONE if they are equal
0000002E                            24          
0000002E  4284                      25                  CLR.L   D4                 Ensure our counter (D4) is 0 
00000030                            26  
00000030  4EB9 00000040             27                  JSR     LENGTH_CHECK   
00000036  BA3C 0001                 28                  CMP.B   #1,D5              if 1 then it passed the tests         
0000003A                            29  
0000003A  6700 005C                 30                  BEQ     IOASCIItoHEX
0000003E  60CC                      31                  BRA     IOLOOP
00000040                            32  
00000040                            33    
00000040                            34                  
00000040  4285                      35  LENGTH_CHECK    CLR.L   D5                 store the result of the test
00000042  7C00                      36                  MOVEQ   #$0,D6             make D6 0
00000044  B206                      37                  CMP.B   D6,D1              see if null
00000046  6700 0010                 38                  BEQ     BAD_LENGTH         if null then branch to bad input
0000004A  0C41 0008                 39                  CMPI    #$8,D1             see if it is more than 8 characters long
0000004E  6E00 0008                 40                  BGT     BAD_LENGTH         if more than 8 branch to baad input
00000052  1A3C 0001                 41                  MOVE.B  #$1,D5             passed the length checks so move 1
00000056  4E75                      42                  RTS                        go back
00000058                            43                  
00000058  7A00                      44  BAD_LENGTH      MOVEQ   #$0,D5             did not pass the test
0000005A  43F9 0000021F             45                  LEA     FAIL_INPUT,A1      load bad input message
00000060  103C 000E                 46                  MOVE.B  #14,D0          
00000064  4E4F                      47                  TRAP    #15 
00000066  4E75                      48                  RTS                        go back
00000068                            49                  
00000068  4286                      50  TEST_ODD        CLR.L   D6           
0000006A  4287                      51                  CLR.L   D7
0000006C  7C02                      52                  MOVE.L  #$00000002,D6      divide by 2 to see remainder
0000006E  2E02                      53                  MOVE.L  D2,D7              create a copy of the input in D7
00000070  8EC6                      54                  DIVU    D6,D7              divide the hex number by 2
00000072  4847                      55                  SWAP    D7                 put the remainder on the far left
00000074  BE3C 0001                 56                  CMP.B   #1,D7              see if the remainder is one
00000078  6700 000A                 57                  BEQ     BAD_EVEN           branch to to even
0000007C  4286                      58                  CLR.L   D6
0000007E  4287                      59                  CLR.L   D7
00000080  6000 0040                 60                  BRA     OUTPUTOPCODE       was even so keep going
00000084                            61                  
00000084  4286                      62  BAD_EVEN        CLR.L   D6
00000086  4287                      63                  CLR.L   D7
00000088  43F9 0000021F             64                  LEA     FAIL_INPUT,A1      load bad input message  
0000008E  103C 000E                 65                  MOVE.B  #14,D0          
00000092  4E4F                      66                  TRAP    #15 
00000094  6000 FF76                 67                  BRA     IOLOOP             go back to the beginning
00000098                            68                  
00000098                            69              
00000098  5244                      70  IOASCIItoHEX    ADDQ    #1,D4
0000009A  E98A                      71                  LSL.L   #4,D2              Scoot D2 a nybble
0000009C  1619                      72                  MOVE.B  (A1)+,D3           Move a Byte from A1's address to D3
0000009E  0403 0030                 73                  SUB.B   #48,D3             Sub 48 to turn ASCII 0 into binary 0
000000A2  B63C 0009                 74                  CMP.B   #9,D3              If our number is greater than 9..
000000A6  6F02                      75                  BLE.S   IOORTAG            .. it must be a character; A-F: 
000000A8  5F03                      76                  SUB.B   #7,D3              Sub 7 to turn A into 10
000000AA  8403                      77  IOORTAG         OR.B    D3,D2              Store our nybble into D2
000000AC  B204                      78                  CMP.B   D4,D1              See if we've read all the characters
000000AE  66E8                      79                  BNE.S   IOASCIItoHEX       Continue if we haven't
000000B0                            80              
000000B0  23FC 00000000 00000266    81                  MOVE.L  #0,StartAddress
000000BA  23C2 00000266             82                  MOVE.L  D2,StartAddress    Store our StartAddress
000000C0                            83                  
000000C0                            84                  ;BRA     TEST_ODD
000000C0                            85                  
000000C0  4281                      86                  CLR.L   D1
000000C2                            87          
000000C2                            88  *-------Output Opcode------- 
000000C2  23FC 00000000 00000100    89  OUTPUTOPCODE    MOVE.L  #0,IOStringLoc     ********** Testing purposes ********** 
000000CC                            90          
000000CC                            91                  ; <Testing section>        
000000CC  2479 00000266             92                  MOVE.L  StartAddress,A2    Push our start address into A2 
000000D2  34FC 3807                 93                  MOVE.W  #$3807,(A2)+       Push OpCode for Move.B D0,D1 into our start address
000000D6  34FC 3200                 94                  MOVE.W  #$3200,(A2)+       Push OpCode for Move.W D0,D1 into our start address
000000DA  34FC 2200                 95                  MOVE.W  #$2200,(A2)+       Push OpCode for Move.L D0,D1 into our start address
000000DE                            96                  ; </Testing section>
000000DE                            97          
000000DE  2479 00000266             98                  MOVE.L  StartAddress,A2    Push our start address into A2 
000000E4  43F9 00000100             99                  LEA     IOStringLoc,A1     Load our IOStringLoc into A1 for string contruction purposes
000000EA                           100          
000000EA                           101                  ; Here we could loop all of the addresses of A2 until End, or something.
000000EA  22FC 23232323            102                  MOVE.L  #'####',(A1)+      Move our "OpCode location" into our IOStringLoc <---- THIS NEEDS TO BE HEX
000000F0  5841                     103                  ADDQ    #4,D1              We added 4 new characters                       <---- THIS NEEDS TO BE 8
000000F2  22FC 20202020            104                  MOVE.L  #'    ',(A1)+      Add a spacer into our IOStringLoc
000000F8  5841                     105                  ADDQ    #4,D1              We added 4 bytes, aka 4 spaces
000000FA                           106          
Line 107 ERROR: Undefined symbol
000000FA  4EB9 004DBAA6            107                  JSR OPGETCODE              Get the OpCode pointed at by A2, it's string stored in IOStringLoc
00000100                           108          
00000100  43F9 00000100            109                  LEA     IOStringLoc,A1     Now that we've populated the string, load it's beginning
00000106  103C 0001                110                  MOVE.B  #1,D0              Trap task 1 prints a string at A1 with #D1 bytes.
0000010A  4E4F                     111                  TRAP    #15
0000010C                           112          
0000010C                           113                  ;LEA     UnkEA,A1          TEMPORARY Print "<EA>,<EA>"
0000010C                           114                  ;MOVE.B  #13,D0              
0000010C                           115                  ;TRAP    #15                 
0000010C                           116          
0000010C  43F9 00000205            117                  LEA     SPC,A1             Puts the space before the opCode
00000112  103C 000D                118                  MOVE.B  #13,D0
00000116  4E4F                     119                  TRAP    #15
00000118                           120  *-------End Output Opcode------- 
00000118                           121  
00000118  43F9 000001F7            122                  LEA     RES,A1             Output the beginning of the message
0000011E  103C 000E                123                  MOVE.B  #14,D0  
00000122  4E4F                     124                  TRAP    #15
00000124                           125  
00000124                           126  *-------Output User Input------- 
00000124                           127                  ; The following outputs the input, converting what we've saved in HEX to ASCII
00000124                           128                  ; We won't need this in the final version, but the below code should be handy
00000124                           129                  ;  for print out EA values
00000124  2439 00000266            130                  MOVE.L  StartAddress,D2    Ensure our address is actually at D2
0000012A  7208                     131                  MOVEQ   #8,D1              There are 8 characters in the hex of our address
0000012C  4284                     132                  CLR.L   D4                 Ensure our counter (D4) is 0
0000012E  43F9 00000100            133                  LEA     IOStringLoc,A1     Load our IO String location, to store our output at  
00000134                           134          
00000134  5244                     135  IOHEXtoASCII    ADDQ    #1,D4
00000136  E99A                     136                  ROL.L   #4,D2              Get the left-most nyblle to the front..
00000138  1602                     137                  MOVE.B  D2,D3              .. Put the front-most byte into D3    
0000013A  C63C 000F                138                  AND.B   #$0F,D3            Distill D3 down to the original left-most nybble
0000013E  B63C 0009                139                  CMP.B   #9,D3              See if our number is greater than 9..
00000142  6F00 0004                140                  BLE     IODIGIT            If it is 9 or less, it's a digit..
00000146  5E03                     141                  ADD.B   #7,D3              Otherwise it is a digit, and needs an additional 7
00000148  0603 0030                142  IODIGIT         ADD.B   #48,D3             We now how the nybble's ASCII code
0000014C  12C3                     143                  MOVE.B  D3,(A1)+           Move the ASCII code into the output string at A1
0000014E  B204                     144                  CMP.B   D4,D1              See if we've read all the characters
00000150  66E2                     145                  BNE.S   IOHEXtoASCII       Continue if we haven't
00000152                           146          
00000152  43F9 00000100            147                  LEA     IOStringLoc,A1     Now that we've populated the string, load it's beginning
00000158  103C 0001                148                  MOVE.B  #1,D0              Trap task 1 prints a string at A1 with #D1 bytes.
0000015C  4E4F                     149                  TRAP    #15
0000015E                           150  *-------End User Input------- 
0000015E                           151  
0000015E  43F9 00000205            152                  LEA     SPC,A1             Puts the space after the number
00000164  103C 000D                153                  MOVE.B  #13,D0
00000168  4E4F                     154                  TRAP    #15
0000016A                           155  
0000016A  6000 FEA0                156                  BRA     IOLOOP
0000016E                           157          
0000016E                           158  *-------Finishes the program-        
0000016E  43F9 00000215            159  IODONE          LEA     OUTRO,A1           Display the ending message 
00000174  103C 000E                160                  MOVE.B  #14,D0
00000178  4E4F                     161                  TRAP    #15
0000017A  103C 0009                162                  MOVE.B  #9,D0
0000017E  4E4F                     163                  TRAP    #15                Halt Simulator
00000180                           164          
00000180  FFFF FFFF                165                  SIMHALT
00000184                           166          
00000184  =0000000D                167  CR              EQU     $0D         
00000184  =0000000A                168  LF              EQU     $0A 
00000184  =00000100                169  IOStringLoc     EQU     $0100              This is where we will store the string of the user input, and other strings
00000184                           170  
00000184                           171  *-------Various outputs------
00000184= 54 65 61 6D 20 43 ...    172  IntroMsg        DC.B    'Team Circles Disassembler ',CR,LF,0     Intro
000001A1= 45 6E 74 65 72 20 ...    173  HexStart        DC.B    'Enter a starting address in hex of length 8 or less and even, or',CR,LF,'type in 0 to quit: ',0 Prompt for the user
000001F7= 59 6F 75 20 74 79 ...    174  RES             DC.B    'You typed in ',0                        Response to the user
00000205= 20 20 20 20 20 00        175  SPC             DC.B    '     ',0                                tab
0000020B= 3C 45 41 3E 2C 3C ...    176  UnkEA           DC.B    '<EA>,<EA>',0                            Interim message for unkown EAs.
00000215= 47 6F 6F 64 62 79 ...    177  OUTRO           DC.B    'Goodbye !',0                            Outro message
0000021F= 49 20 61 6D 20 73 ...    178  FAIL_INPUT      DC.B    'I am sorry, but you typed an address that did not meet the criteria',CR,LF,0 
00000266                           179  StartAddress    DS.L    1
0000026A                           180  
0000026A                           181  * Put variables and constants herevv
0000026A                           182  
0000026A                           183  
0000026A                           184  
0000026A                           185  
0000026A                           186  
0000026A                           187  
0000026A                           188  
0000026A                           189  
0000026A                           190  
0000026A                           191  
0000026A                           192  
0000026A                           193  
Line 194 WARNING: END directive missing, starting address not set

1 error detected
1 warning generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BAD_EVEN            84
BAD_LENGTH          58
CR                  D
FAIL_INPUT          21F
HEXSTART            1A1
INTROMSG            184
IOASCIITOHEX        98
IODIGIT             148
IODONE              16E
IOHEXTOASCII        134
IOINTRO             0
IOLOOP              C
IOORTAG             AA
IOSTRINGLOC         100
LENGTH_CHECK        40
LF                  A
OUTPUTOPCODE        C2
OUTRO               215
RES                 1F7
SPC                 205
STARTADDRESS        266
TEST_ODD            68
UNKEA               20B
