00000000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.03
Created On: 3/1/2016 5:47:47 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : IO
00000000                             3  * Written by : Circles
00000000                             4  * Date       : ##/##/16
00000000                             5  * Description: Input Output File
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  * Put program code here
00000000                             9  *-------Code for output-------
00000000  43F9 0000011C             10  IOINTRO LEA     IntroMsg,A1      Display the intro
00000006  103C 000E                 11          MOVE.B  #14, D0
0000000A  4E4F                      12          TRAP    #15
0000000C                            13  
0000000C  43F9 00000139             14  IOLOOP  LEA     HexStart,A1        Display the prompt and loop it
00000012  103C 000E                 15          MOVE.B  #14,D0          
00000016  4E4F                      16          TRAP    #15       
00000018                            17  
00000018                            18  *-------Code for input-------
00000018  43F9 00000100             19          LEA  IOStringLoc,A1     ; Store the string of our user input at StartAddress,A1 
0000001E  103C 0002                 20          MOVE.B  #2,D0           ;   uses Trap #15, Task 2
00000022  4E4F                      21          TRAP    #15             ;
00000024                            22          
00000024  B2BC 00000001             23          CMP.L   #1,D1           ; Compares D1 to the number 1 (eg. String length of 1)
0000002A  6700 00DA                 24          BEQ     IODONE          ; Branch to DONE if they are equal
0000002E                            25          
0000002E  4284                      26          CLR.L   D4              ; Ensure our counter (D4) is 0      
00000030                            27              
00000030  5244                      28  IOASCIItoHEX    ADDQ    #1,D4
00000032  E98A                      29                  LSL.L   #4,D2           ; Scoot D2 a nybble
00000034  1619                      30                  MOVE.B  (A1)+,D3        ; Move a Byte from A1's address to D3
00000036  0403 0030                 31                  SUB.B   #48,D3          ; Sub 48 to turn ASCII 0 into binary 0
0000003A  B63C 0009                 32                  CMP.B   #9,D3           ; If our number is greater than 9..
0000003E  6F02                      33                  BLE.S   IOORTAG         ; .. it must be a character; A-F: 
00000040  5F03                      34                  SUB.B   #7,D3           ; Sub 7 to turn A into 10
00000042  8403                      35  IOORTAG         OR.B    D3,D2           ; Store our nybble into D2
00000044  B204                      36                  CMP.B   D4,D1           ; See if we've read all the characters
00000046  66E8                      37                  BNE.S   IOASCIItoHEX    ; Continue if we haven't
00000048                            38              
00000048  23FC 00000000 000001B2    39          MOVE.L  #0,StartAddress
00000052  23C2 000001B2             40          MOVE.L  D2,StartAddress     ; Store our StartAddress
00000058                            41          
00000058  4281                      42          CLR.L   D1
0000005A                            43          
0000005A                            44          ; ==== OUTPUT OPCODE ===    
0000005A  23FC 00000000 00000100    45          MOVE.L  #0,IOStringLoc      ; == Testing Purposes; not nessessary ==   
00000064                            46          
00000064                            47          ; <Testing section>        
00000064  2479 000001B2             48          MOVE.L  StartAddress,A2     ; Push our start address into A2 
0000006A  34FC 3807                 49          MOVE.W  #$3807,(A2)+    ; Push OpCode for Move.B D0,D1 into our start address
0000006E  34FC 3200                 50          MOVE.W  #$3200,(A2)+    ; Push OpCode for Move.W D0,D1 into our start address
00000072  34FC 2200                 51          MOVE.W  #$2200,(A2)+    ; Push OpCode for Move.L D0,D1 into our start address
00000076                            52          ; </Testing section>
00000076                            53          
00000076  2479 000001B2             54          MOVE.L  StartAddress,A2     ; Push our start address into A2 
0000007C  43F9 00000100             55          LEA     IOStringLoc,A1      ; Load our IOStringLoc into A1 for string contruction purposes
00000082                            56          
00000082                            57          ; Here we could loop all of the addresses of A2 until End, or something.
00000082  22FC 23232323             58          MOVE.L  #'####',(A1)+       ; Move our "OpCode location" into our IOStringLoc <---- THIS NEEDS TO BE HEX
00000088  5841                      59          ADDQ    #4,D1               ; We added 4 new characters                       <---- THIS NEEDS TO BE 8
0000008A  22FC 20202020             60          MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
00000090  5841                      61          ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
00000092                            62          
Line 63 ERROR: Undefined symbol
00000092  4EB9 004DBAA6             63          JSR OPGETCODE               ; Get the OpCode pointed at by A2, it's string stored in IOStringLoc
00000098                            64          
00000098  43F9 00000100             65          LEA     IOStringLoc,A1      ; Now that we've populated the string, load it's beginning
0000009E  103C 0001                 66          MOVE.B  #1,D0               ; Trap task 1 prints a string at A1 with #D1 bytes.
000000A2  4E4F                      67          TRAP    #15
000000A4                            68          
000000A4                            69          ;LEA     UnkEA,A1            ; TEMPORARY Print "<EA>,<EA>"
000000A4                            70          ;MOVE.B  #13,D0              ;
000000A4                            71          ;TRAP    #15                 ;
000000A4                            72          
000000A4  43F9 00000197             73          LEA     SPC,A1              ; Puts the space before the opCode
000000AA  103C 000D                 74          MOVE.B  #13,D0
000000AE  4E4F                      75          TRAP    #15
000000B0                            76          ; ==== END OUTPUT OPCODE ====
000000B0                            77  
000000B0  43F9 00000189             78          LEA     RES,A1          ; Output the beginning of the message
000000B6  103C 000E                 79          MOVE.B  #14,D0  
000000BA  4E4F                      80          TRAP    #15
000000BC                            81  
000000BC                            82          ; ==== OUTPUT USER INPUT ====
000000BC                            83          ; The following outputs the input, converting what we've saved in HEX to ASCII
000000BC                            84          ; We won't need this in the final version, but the below code should be handy
000000BC                            85          ;  for print out EA values
000000BC  2439 000001B2             86          MOVE.L  StartAddress,D2 ; Ensure our address is actually at D2
000000C2  7208                      87          MOVEQ   #8,D1           ; There are 8 characters in the hex of our address
000000C4  4284                      88          CLR.L   D4              ; Ensure our counter (D4) is 0
000000C6  43F9 00000100             89          LEA     IOStringLoc,A1  ; Load our IO String location, to store our output at  
000000CC                            90          
000000CC  5244                      91  IOHEXtoASCII    ADDQ    #1,D4
000000CE  E99A                      92                  ROL.L   #4,D2           ; Get the left-most nyblle to the front..
000000D0  1602                      93                  MOVE.B  D2,D3           ; .. Put the front-most byte into D3    
000000D2  C63C 000F                 94                  AND.B   #$0F,D3         ; Distill D3 down to the original left-most nybble
000000D6  B63C 0009                 95                  CMP.B   #9,D3           ; See if our number is greater than 9..
000000DA  6F00 0004                 96                  BLE     IODIGIT         ; If it is 9 or less, it's a digit..
000000DE  5E03                      97                  ADD.B   #7,D3           ; Otherwise it is a digit, and needs an additional 7
000000E0  0603 0030                 98  IODIGIT         ADD.B   #48,D3          ; We now how the nybble's ASCII code
000000E4  12C3                      99                  MOVE.B  D3,(A1)+        ; Move the ASCII code into the output string at A1
000000E6  B204                     100                  CMP.B   D4,D1           ; See if we've read all the characters
000000E8  66E2                     101                  BNE.S   IOHEXtoASCII    ; Continue if we haven't
000000EA                           102          
000000EA  43F9 00000100            103          LEA     IOStringLoc,A1  ; Now that we've populated the string, load it's beginning
000000F0  103C 0001                104          MOVE.B  #1,D0           ; Trap task 1 prints a string at A1 with #D1 bytes.
000000F4  4E4F                     105          TRAP    #15
000000F6                           106          ; ==== END OUTPUT USER INPUT ====
000000F6                           107  
000000F6  43F9 00000197            108          LEA     SPC,A1          Puts the space after the number
000000FC  103C 000D                109          MOVE.B  #13,D0
00000100  4E4F                     110          TRAP    #15
00000102                           111  
00000102  6000 FF08                112          BRA     IOLOOP
00000106                           113          
00000106                           114  *-------Finishes the program-        
00000106  43F9 000001A7            115  IODONE  LEA     OUTRO,A1        Display the ending message 
0000010C  103C 000E                116          MOVE.B  #14,D0
00000110  4E4F                     117          TRAP    #15
00000112  103C 0009                118          MOVE.B  #9,D0
00000116  4E4F                     119          TRAP    #15             Halt Simulator
00000118                           120          
00000118  FFFF FFFF                121          SIMHALT
0000011C                           122          
0000011C  =0000000D                123  CR              EQU     $0D         
0000011C  =0000000A                124  LF              EQU     $0A 
0000011C  =00000100                125  IOStringLoc     EQU     $0100   ; This is where we will store the string of the user input, and other strings
0000011C                           126  
0000011C                           127  *-------Various outputs------
0000011C= 54 65 61 6D 20 43 ...    128  IntroMsg        DC.B    'Team Circles Disassembler ',CR,LF,0     Intro
00000139= 50 6C 65 61 73 65 ...    129  HexStart        DC.B    'Please enter a full hexidecimal address to get started, or',CR,LF,'type in 0 to quit: ',0         Prompt for the user
00000189= 59 6F 75 20 74 79 ...    130  RES             DC.B    'You typed in ',0                        Response to the user
00000197= 20 20 20 20 20 00        131  SPC             DC.B    '     ',0                                tab
0000019D= 3C 45 41 3E 2C 3C ...    132  UnkEA           DC.B    '<EA>,<EA>',0                            Interim message for unkown EAs.
000001A7= 47 6F 6F 64 62 79 ...    133  OUTRO           DC.B    'Goodbye !',0                            Outro message
000001B2                           134  StartAddress    DS.L    1
000001B6                           135  
000001B6                           136  * Put variables and constants herevv
000001B6                           137  
000001B6                           138  
000001B6                           139  
000001B6                           140  
Line 141 WARNING: END directive missing, starting address not set

1 error detected
1 warning generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
CR                  D
HEXSTART            139
INTROMSG            11C
IOASCIITOHEX        30
IODIGIT             E0
IODONE              106
IOHEXTOASCII        CC
IOINTRO             0
IOLOOP              C
IOORTAG             42
IOSTRINGLOC         100
LF                  A
OUTRO               1A7
RES                 189
SPC                 197
STARTADDRESS        1B2
UNKEA               19D
