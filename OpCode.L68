00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 3/5/2016 9:56:33 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : OpCode
00000000                             3  * Written by : Circles
00000000                             4  * Date       : ##/##/16
00000000                             5  * Description: Operation Codes File
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  * Put program code here
00000000                             9  
00000000                            10  ; Here we assume that A2 contains the address pointing to our OpCode, and
00000000                            11  ;  we assume that A1 contains the address pointing to our IOStringLoc
00000000  3A1A                      12  OPGETCODE   MOVE.W  (A2)+,D5    ; Push our OpCode into D5
00000002  2C05                      13              MOVE.L  D5,D6       ; Also store the OpCode in D6
00000004  E09E                      14              ROR.L   #8,D6       ; Rotate our OpCode to right-most nybble
00000006  E89E                      15              ROR.L   #4,D6       ; 
00000008  0206 000F                 16              ANDI.B  #$0F,D6     ; Isolate our opcode nybble
0000000C  BC3C 0000                 17              CMP.B   #$00,D6
00000010  6700 0066                 18              BEQ     ADDI        ; ADDI (Worked on)
00000014  BC3C 0001                 19              CMP.B   #$01,D6     
00000018  6700 010A                 20              BEQ     MOVEB       ; MOVE.B
0000001C  BC3C 0003                 21              CMP.B   #$03,D6     
00000020  6700 0112                 22              BEQ     MOVEW       ; MOVE.W
00000024  BC3C 0002                 23              CMP.B   #$02,D6
00000028  6700 011A                 24              BEQ     MOVEL       ; MOVE.L
0000002C  BC3C 0004                 25              CMP.B   #$04,D6
00000030  6700 0150                 26              BEQ     CNRJML      ; CLR or NOP or RTS or JSR or MOVEM or LEA (Implement)(Working on NOP,RTS,CLR)
00000034  BC3C 0006                 27              CMP.B   #$06,D6
00000038  6700 0272                 28              BEQ     Bcc         ; Bcc (BCC, BGT, BLE) (Implement)
0000003C  BC3C 0007                 29              CMP.B   #$07,D6
00000040  6700 026C                 30              BEQ     MOVEQ       ; MOVEQ (Implement)
00000044  BC3C 0008                 31              CMP.B   #$08,D6
00000048  6700 0266                 32              BEQ     DIVU        ; DIVU (Implement)
0000004C  BC3C 0009                 33              CMP.B   #$09,D6
00000050  6700 0260                 34              BEQ     SUB         ; SUB (Implement)
00000054  BC3C 000B                 35              CMP.B   #$0B,D6
00000058  6700 025A                 36              BEQ     CMP         ; CMP (Implement)
0000005C  BC3C 000C                 37              CMP.B   #$0C,D6
00000060  6700 0254                 38              BEQ     MULSAND     ; MULS or AND opcodes (Implement AND)
00000064  BC3C 000D                 39              CMP.B   #$0D,D6
00000068  6700 0362                 40              BEQ     ADDADDA     ; ADD or ADDA (Implement)
0000006C  BC3C 000E                 41              CMP.B   #$0E,D6 
00000070  6700 035C                 42              BEQ     ASLSRO      ; ASd (ASR) or LSd (LSL) or ROd (ROL) (Implement)
00000074  6000 035A                 43              BRA     UNKNOWN  
00000078                            44     
00000078                            45  ADDI                                    ; Confirmed first left-most 4 bits of ADDI
00000078  2C05                      46              MOVE.L  D5,D6               ; Push D5 into D6
0000007A  E09E                      47              ROR.L   #8,D6               ; Rotate left-most middle nybble to the right-most nybble
0000007C  0206 000F                 48              ANDI.B  #$0F,D6             ; Isolate opcode nybble
00000080  BC3C 0006                 49              CMP.B   #$06,D6             ; If it matches ADDI's left-most middle nybble, branch
00000084  6700 0006                 50              BEQ     ADDI8               ; First 8 left-most bits of ADDI confirmed 
00000088  6000 0346                 51              BRA     UNKNOWN             ; else unknown                       
0000008C                            52              
0000008C                            53  ADDI8                                   ; Confirmed first left-most 8 bits of ADDI
0000008C                            54  
0000008C  2C05                      55              MOVE.L  D5,D6              ; Push D5 into D6 (Copy OPcode over isolated nybble)
0000008E  EC8E                      56              LSR.L   #6,D6              ; Shift six bits to the right
00000090  0286 00000003             57              ANDI.L  #$0003,D6          ; Isolate the size bits
00000096                            58                         
00000096  BCBC 00000000             59              CMP.L   #$0000,D6          ; See if the size is '00'..
0000009C  6700 001A                 60              BEQ     ADDIB              ; ..If so, it's ANDI.B
000000A0  BCBC 00000001             61              CMP.L   #$0001,D6          ; See if the size is '01'..
000000A6  6700 0034                 62              BEQ     ADDIW              ; ..If so, it's ANDI.W
000000AA  BCBC 00000002             63              CMP.L   #$0002,D6          ; See if the size is '10'..
000000B0  6700 004E                 64              BEQ     ADDIL              ; ..If so, it's ANDI.L
000000B4                            65              
000000B4  6000 031A                 66              BRA     UNKNOWN            ; If it isn't any, then it's Unknown
000000B8                            67              
000000B8                            68  ADDIB       
000000B8  22FC 41444449             69              MOVE.L  #'ADDI',(A1)+
000000BE  32FC 2E42                 70              MOVE.W  #'.B',(A1)+
000000C2  5C41                      71              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
000000C4                            72              
000000C4  22FC 20202020             73              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
000000CA  5841                      74              ADDQ    #4,D1              ; We added 4 bytes, aka 4 spaces
000000CC                            75              
000000CC  2C05                      76              MOVE.L  D5,D6              ; Push D5 into D6
000000CE  0286 0000003F             77              ANDI.L  #$003F,D6          ; Isolate the Src EA bits 
Line 78 ERROR: Undefined symbol
000000D4  4EB9 004DBB8E             78              JSR EAGETSRCEA             ; Find and print the code stored in D6
000000DA                            79              
000000DA  4E75                      80              RTS
000000DC                            81              
000000DC                            82  ADDIW       
000000DC  22FC 41444449             83              MOVE.L  #'ADDI',(A1)+
000000E2  32FC 2E57                 84              MOVE.W  #'.W',(A1)+
000000E6  5C41                      85              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
000000E8                            86              
000000E8  22FC 20202020             87              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
000000EE  5841                      88              ADDQ    #4,D1              ; We added 4 bytes, aka 4 spaces
000000F0                            89              
000000F0  2C05                      90              MOVE.L  D5,D6              ; Push D5 into D6
000000F2  0286 0000003F             91              ANDI.L  #$003F,D6          ; Isolate the Src EA bits 
Line 92 ERROR: Undefined symbol
000000F8  4EB9 004DBB8E             92              JSR EAGETSRCEA             ; Find and print the code stored in D6
000000FE  4E75                      93              RTS
00000100                            94              
00000100                            95  ADDIL      
00000100  22FC 41444449             96              MOVE.L  #'ADDI',(A1)+
00000106  32FC 2E4C                 97              MOVE.W  #'.L',(A1)+
0000010A  5C41                      98              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
0000010C                            99              
0000010C  22FC 20202020            100              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
00000112  5841                     101              ADDQ    #4,D1              ; We added 4 bytes, aka 4 spaces
00000114                           102              
00000114  2C05                     103              MOVE.L  D5,D6              ; Push D5 into D6
00000116  0286 0000003F            104              ANDI.L  #$003F,D6          ; Isolate the Src EA bits 
Line 105 ERROR: Undefined symbol
0000011C  4EB9 004DBB8E            105              JSR EAGETSRCEA             ; Find and print the code stored in D6
00000122                           106                  
00000122  4E75                     107              RTS 
00000124                           108                
00000124  22FC 4D4F5645            109  MOVEB       MOVE.L  #'MOVE',(A1)+
0000012A  32FC 2E42                110              MOVE.W  #'.B',(A1)+
0000012E  5C41                     111              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
00000130                           112              
00000130  6000 0022                113              BRA MOVEOP
00000134                           114              
00000134  22FC 4D4F5645            115  MOVEW       MOVE.L  #'MOVE',(A1)+
0000013A  32FC 2E57                116              MOVE.W  #'.W',(A1)+
0000013E  5C41                     117              ADDQ    #6,D1               ; We added 6 new characters to our IOStringLoc 
00000140                           118              
00000140  6000 0012                119              BRA MOVEOP
00000144                           120              
00000144  22FC 4D4F5645            121  MOVEL       MOVE.L  #'MOVE',(A1)+
0000014A  32FC 2E4C                122              MOVE.W  #'.L',(A1)+
0000014E  5C41                     123              ADDQ    #6,D1               ; We added 6 new characters to our IOStringLoc 
00000150                           124              
00000150  6000 0002                125              BRA MOVEOP
00000154                           126              
00000154  22FC 20202020            127  MOVEOP      MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
0000015A  5841                     128              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
0000015C                           129              
0000015C  2C05                     130              MOVE.L  D5,D6               ; Push D5 into D6
0000015E  0286 0000003F            131              ANDI.L  #$003F,D6           ; Isolate the Src EA bits 
Line 132 ERROR: Undefined symbol
00000164  4EB9 004DBB8E            132              JSR EAGETSRCEA              ; Find and print the code stored in D6
0000016A                           133              
0000016A  12FC 002C                134              MOVE.B  #',',(A1)+
0000016E  5241                     135              ADDQ    #1,D1
00000170                           136              
00000170  2C05                     137              MOVE.L  D5,D6               ; Push D5 into D6
00000172  EC8E                     138              LSR.L   #6,D6               ; Shift six bits to the right
00000174  0286 0000003F            139              ANDI.L  #$003F,D6           ; Isolate the Dst EA bits
Line 140 ERROR: Undefined symbol
0000017A  4EB9 004DBB8E            140              JSR EAGETDSTEA
00000180  4E75                     141              RTS
00000182                           142              
00000182                           143  ; This label determines if the code is either CLR or NOP or RTS or JSR or MOVEM or LEA
00000182                           144  ; Here we assume that the first left-most four bits equal 0100            
00000182                           145  CNRJML      
00000182  2C05                     146              MOVE.L  D5,D6              ; Push D5 into D6 (Copy OPcode over isolated nybble)
00000184                           147              
00000184                           148              *NOP & RTS's machine code is uniquely hardcoded, check first
00000184  BCBC 00004E71            149              CMP.L   #$4E71,D6          ; See if the OPcode matches NOP's hardcode
0000018A  6700 0060                150              BEQ     NOP
0000018E  BCBC 00004E75            151              CMP.L   #$4E75,D6          ; See if the OPcode matches RTS's hardcode
00000194  6700 006A                152              BEQ     RTS
00000198                           153                                         ; CLR's middle most left nybble is unique (0010)
00000198  E09E                     154              ROR.L   #8,D6              ; Rotate our OpCode to right-most nybble
0000019A  0206 000F                155              ANDI.B  #$0F,D6            ; Isolate our opcode nybble
0000019E  BC3C 0002                156              CMP.B   #$02,D6            ; See if matches nybble
000001A2  6700 0046                157              BEQ     CLR               
000001A6                           158              
000001A6  2C05                     159              MOVE.L  D5,D6              ; Push D5 into D6
000001A8  E08E                     160              LSR.L   #8,D6              ; Shift 8 bits to the right
000001AA                           161              
000001AA  0806 0000                162              BTST    #$00,D6            ; See if our right-most bit is set
000001AE  6600 00F0                163              BNE     LEA                ; If our bit is set, branch to LEA     
000001B2                           164              
000001B2  E28E                     165              LSR.L   #1,D6              ; Shift another bit
000001B4  0806 0000                166              BTST    #$00,D6            ; See if our right-most bit is set
000001B8  6600 005A                167              BNE     JSR                ; If this one is set, branch to JSR
000001BC                           168              
000001BC  6000 0062                169              BRA     MOVEM
000001C0                           170                                         ; LEA's middle most left nybble is unique (xxx1)
000001C0  0806 0001                171              BTST    #1,D6              ; Check the right most bit's value
000001C4  6700 00DA                172              BEQ     LEA                ; If equals 1, branch
000001C8                           173                 
000001C8                           174                                         ; MOVEM's middle most left nybble is unique (1x00)
000001C8  E29E                     175              ROR.L   #1,D6              ; first bit must be 0, rotate 1 bit 
000001CA  0806 0000                176              BTST    #0,D6               ; Compare again for 00 match
000001CE  6700 0050                177              BEQ     MOVEM                           
000001D2                           178                                         
000001D2  2C05                     179              MOVE.L  D5,D6              ; Push D5 into D6; JSR's middle nybbles are unique (1110 10xx)
000001D4  EC9E                     180              ROR.L   #6,D6              ; Rotate 6 bits
000001D6  0286 000000FF            181              ANDI.L  #$00FF,D6          ; Isolate the 8 known bits (00 1110 10)
000001DC  BCBC 0000003A            182              CMP.L   #$003A,D6          ; Compare
000001E2  6700 0030                183              BEQ     JSR                ; Branch
000001E6                           184              
000001E6  6000 01E8                185              BRA     UNKNOWN            ; If it doesnt any match, then it's Unknown
000001EA                           186  
000001EA                           187  
000001EA                           188  ;  Here we assume the first left-most 8 bits have been confirmed: 0100 0010
000001EA                           189  CLR         *(Implement)
000001EA                           190  
000001EA  4E75                     191              RTS
000001EC                           192              
000001EC                           193  ;  Here we assume that all 16 bits have been confirmed 
000001EC                           194  NOP
000001EC  32FC 4E4F                195              MOVE.W  #'NO',(A1)+
000001F0  12FC 0050                196              MOVE.B  #'P',(A1)+
000001F4  5641                     197              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
000001F6                           198              
000001F6  22FC 20202020            199              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
000001FC  5841                     200              ADDQ    #4,D1              ; We added 4 bytes, aka 4 spaces        
000001FE  4E75                     201              RTS
00000200                           202  
00000200                           203  ;  Here we assume that all 16 bits have been confirmed            
00000200                           204  RTS         
00000200  32FC 5254                205              MOVE.W  #'RT',(A1)+
00000204  12FC 0053                206              MOVE.B  #'S',(A1)+
00000208  5641                     207              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
0000020A                           208              
0000020A  22FC 20202020            209              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
00000210  5841                     210              ADDQ    #4,D1              ; We added 4 bytes, aka 4 spaces        
00000212  4E75                     211              RTS
00000214                           212              
00000214                           213  
00000214                           214  ;  Here we assume the first left-most 10 bits have been confirmed: 0100 1110 10 
00000214                           215  JSR         *(Implement)
00000214  32FC 4A53                216              MOVE.W  #'JS',(A1)+
00000218  12FC 0052                217              MOVE.B  #'R',(A1)+
0000021C  5641                     218              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
0000021E  4E75                     219              RTS
00000220                           220              
00000220                           221  
00000220                           222  ;  Here we assume that these left-most have been confirmed, where - have not been confirmed: 0100 --00
00000220                           223  MOVEM       *(Implement)
00000220  22FC 4D4F5645            224              MOVE.L  #'MOVE',(A1)+
00000226  32FC 4D2E                225              MOVE.W  #'M.',(A1)+
0000022A  5C41                     226              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
0000022C                           227              
0000022C  2C05                     228              MOVE.L  D5,D6              ; Copy our OpCode
0000022E  EE8E                     229              LSR.L   #7,D6              ; Rotate it 7 bits to the right
00000230  0806 0000                230              BTST    #$00,D6            ; If our size bit is 0..
00000234  6700 0006                231              BEQ     MOVEMW             ; .. Its a MOVEM of size W
00000238  6000 000C                232              BRA     MOVEML             ; .. Otherwise it's of size L
0000023C                           233  
0000023C  12FC 0057                234  MOVEMW      MOVE.B  #'W',(A1)+
00000240  5241                     235              ADDQ    #1,D1              ; We've added another character into IOStringLoc
00000242  6000 0008                236              BRA     MOVEMOP            ; MovemOp label, to skip MovemL label
00000246                           237              
00000246  12FC 004C                238  MOVEML      MOVE.B  #'L',(A1)+
0000024A  5241                     239              ADDQ    #1,D1              ; We've added another character into IOStringLoc
0000024C                           240              
0000024C  12FC 0020                241  MOVEMOP     MOVE.B  #' ',(A1)+         ; Add a spacer into our IOStringLoc
00000250  32FC 2020                242              MOVE.W  #'  ',(A1)+        ;
00000254  12FC 0020                243              MOVE.B  #' ',(A1)+         ;
00000258  5841                     244              ADDQ    #4,D1              ; We added 4 bytes, aka 4 spaces 
0000025A                           245              
0000025A  E88E                     246              LSR.L   #4,D6              ; Shift our OpCode 4 bits to the left of Size (going to the right)
0000025C  0806 0000                247              BTST    #$00,D6            ; Check our Direction bit
00000260  6700 0006                248              BEQ     MOVEMPRED          ; If it's 0, our direction is Pre Decrement (eg. Move TO the stack)
00000264  6000 001E                249              BRA     MOVEMPOSTI         ; Otherwise, it's Post Increment (eg. Move FROM the stack)
00000268                           250              
00000268                           251  MOVEMPRED   ; This part is where we get the gross A0-A6/D0-D7 part
Line 252 ERROR: Undefined symbol
00000268  4EB9 004DBB8E            252              JSR     EAMOVEMPRED  
0000026E                           253              
0000026E  12FC 002C                254              MOVE.B  #',',(A1)+
00000272  5241                     255              ADDQ    #1,D1
00000274                           256              
00000274  2C05                     257              MOVE.L  D5,D6              ; Copy our OpCode to D6
00000276  0286 0000003F            258              ANDI.L  #$3F,D6            ; Isolate our EA src bits
0000027C                           259              
Line 260 ERROR: Undefined symbol
0000027C  4EB9 004DBB8E            260              JSR EAGETSRCEA  
00000282                           261            
00000282  4E75                     262              RTS
00000284                           263  
00000284  2C05                     264  MOVEMPOSTI  MOVE.L  D5,D6              ; Copy our OpCode to D6
00000286  0286 0000003F            265              ANDI.L  #$3F,D6            ; Isolate our EA src bits
0000028C                           266              
Line 267 ERROR: Undefined symbol
0000028C  4EB9 004DBB8E            267              JSR EAGETSRCEA  
00000292                           268              
00000292  12FC 002C                269              MOVE.B  #',',(A1)+
00000296  5241                     270              ADDQ    #1,D1
00000298                           271              
00000298                           272              ; This part is where we get the gross A0-A6/D0-D7 part
Line 273 ERROR: Undefined symbol
00000298  4EB9 004DBB8E            273              JSR     EAMOVEMPOSTI
0000029E                           274              
0000029E  4E75                     275              RTS
000002A0                           276              
000002A0                           277  
000002A0                           278  ;  Here we assume that these left-most have been confirmed, where - have not been confirmed: 0100 ---1            
000002A0                           279  LEA         *(Implement)
000002A0  32FC 4C45                280              MOVE.W  #'LE',(A1)+
000002A4  12FC 0041                281              MOVE.B  #'A',(A1)+
000002A8  5641                     282              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
000002AA  4E75                     283              RTS      
000002AC                           284              
000002AC                           285  Bcc         *(Implement)
000002AC                           286                   
000002AC  4E75                     287              RTS
000002AE                           288              
000002AE                           289  MOVEQ       *(Implement)
000002AE                           290                   
000002AE  4E75                     291              RTS 
000002B0                           292              
000002B0                           293  DIVU        *(Implement)
000002B0                           294                   
000002B0  4E75                     295              RTS
000002B2                           296              
000002B2                           297  SUB         *(Implement)
000002B2                           298                   
000002B2  4E75                     299              RTS
000002B4                           300    
000002B4                           301  CMP         *(Implement)
000002B4                           302                   
000002B4  4E75                     303              RTS         
000002B6                           304         
000002B6                           305  ; This label determines if the code is either MULS or AND, by looking at it's size bits     
000002B6  2C05                     306  MULSAND     MOVE.L  D5,D6               ; Copy D5 into D6
000002B8  EC8E                     307              LSR.L   #6,D6               ; Shift the size bits to the far right
000002BA  0206 0007                308              ANDI.B  #$7,D6              ; Isolate the size bits
000002BE  BC3C 0007                309              CMP.B   #7,D6               ; See if the size is '111'..
000002C2  6704                     310              BEQ.S   MULS                ; ..If so, it's a MULS opcode
000002C4  6000 003A                311              BRA     AND                 ; Otherwise, it's an AND code
000002C8                           312          
000002C8  22FC 4D554C53            313  MULS        MOVE.L  #'MULS',(A1)+
000002CE  5841                     314              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000002D0                           315              
000002D0  22FC 20202020            316              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
000002D6  5841                     317              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
000002D8                           318              
000002D8  2C05                     319              MOVE.L  D5,D6               ; Copy D5 into D6
000002DA  0286 0000003F            320              ANDI.L  #$003F,D6           ; Isolate the Src EA bits
Line 321 ERROR: Undefined symbol
000002E0  4EB9 004DBB8E            321              JSR EAGETSRCEA
000002E6                           322              
000002E6  12FC 002C                323              MOVE.B  #',',(A1)+
000002EA  5241                     324              ADDQ    #1,D1
000002EC                           325              
000002EC  2C05                     326              MOVE.L  D5,D6               ; Copy D5 into D6
000002EE  E09E                     327              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
000002F0  E29E                     328              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
000002F2  0286 00000003            329              ANDI.L  #$0003,D6           ; Isolate the Dn Destination bits
Line 330 ERROR: Undefined symbol
000002F8  4EF9 004DBB8E            330              JMP EADN
000002FE                           331              
000002FE  4E75                     332              RTS
00000300                           333              
00000300                           334  ; At this point, we know D6 is the size of our opcode
00000300  22FC 414E442E            335  AND         MOVE.L  #'AND.',(A1)+
00000306  5841                     336              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00000308                           337              
00000308  BC3C 0006                338              CMP.B   #%0110,D6            ; See if D6 is size "%100" through "%110"..
0000030C  6700 0026                339              BEQ     ANDLEA              ; If it is, our OpCode is in the format of..
00000310  BC3C 0005                340              CMP.B   #%101,D6            ; .. Dn ~ <EA> --> <EA>
00000314  6700 0028                341              BEQ     ANDWEA
00000318  BC3C 0004                342              CMP.B   #%100,D6
0000031C  6700 002A                343              BEQ     ANDBEA
00000320                           344              
00000320  BC3C 0002                345              CMP.B   #%10,D6             ; See if D6 is size "%000" through "%010"..
00000324  6700 005A                346              BEQ     ANDLDN              ; If it is, our OpCode is in the format of..
00000328  BC3C 0001                347              CMP.B   #%01,D6             ; .. <EA> ~ Dn --> Dn
0000032C  6700 005C                348              BEQ     ANDWDN
00000330  6000 0062                349              BRA     ANDBDN              ; == 000 at this point
00000334                           350              
00000334  12FC 004C                351  ANDLEA      MOVE.B  #'L',(A1)+
00000338  5241                     352              ADDQ    #1,D1               ; We added 1 byte into D1
0000033A  6000 0016                353              BRA     ANDEA
0000033E                           354              
0000033E  12FC 0057                355  ANDWEA      MOVE.B  #'W',(A1)+
00000342  5241                     356              ADDQ    #1,D1               ; We added 1 byte into D1
00000344  6000 000C                357              BRA     ANDEA
00000348                           358  
00000348  12FC 0042                359  ANDBEA      MOVE.B  #'B',(A1)+
0000034C  5241                     360              ADDQ    #1,D1               ; We added 1 byte into D1
0000034E  6000 0002                361              BRA     ANDEA
00000352                           362  
00000352  12FC 0009                363  ANDEA       MOVE.B  #$09,(A1)+          ; Add a spacer into our IOStringLoc
00000356  5241                     364              ADDQ    #1,D1               ; We added 4 bytes, aka 4 spaces
00000358                           365              
00000358  2C05                     366              MOVE.L  D5,D6
0000035A  E08E                     367              LSR.L   #8,D6               ; Shift our OpCode a total of 9 bits to the right
0000035C  E28E                     368              LSR.L   #1,D6               ; 
0000035E  0286 00000007            369              ANDI.L  #$07,D6             ; Isolate our data register
00000364                           370              
Line 371 ERROR: Undefined symbol
00000364  4EB9 004DBB8E            371              JSR EADN
0000036A                           372              
0000036A  12FC 002C                373              MOVE.B  #',',(A1)+
0000036E  5241                     374              ADDQ    #1,D1
00000370                           375              
00000370  2C05                     376              MOVE.L  D5,D6               ; Copy our OpCode again
00000372  0286 0000003F            377              ANDI.L  #$3F,D6             ; Isolate our EA bits
00000378                           378              
Line 379 ERROR: Undefined symbol
00000378  4EB9 004DBB8E            379              JSR EAGETSRCEA  
0000037E                           380              
0000037E  4E75                     381              RTS
00000380                           382              
00000380  12FC 004C                383  ANDLDN      MOVE.B  #'L',(A1)+
00000384  5241                     384              ADDQ    #1,D1               ; We added 1 byte into D1
00000386  6000 0016                385              BRA ANDDN
0000038A                           386              
0000038A  12FC 0057                387  ANDWDN      MOVE.B  #'W',(A1)+
0000038E  5241                     388              ADDQ    #1,D1               ; We added 1 byte into D1
00000390  6000 000C                389              BRA ANDDN
00000394                           390  
00000394  12FC 0042                391  ANDBDN      MOVE.B  #'B',(A1)+
00000398  5241                     392              ADDQ    #1,D1               ; We added 1 byte into D1
0000039A  6000 0002                393              BRA ANDDN  
0000039E                           394  
0000039E                           395  ANDDN
0000039E  12FC 0009                396              MOVE.B  #$09,(A1)+          ; Add a spacer into our IOStringLoc
000003A2  5241                     397              ADDQ    #1,D1               ; We added 4 bytes, aka 4 spaces
000003A4                           398              
000003A4  2C05                     399              MOVE.L  D5,D6               ; Copy our OpCode again
000003A6  0286 0000003F            400              ANDI.L  #$3F,D6             ; Isolate our EA bits
000003AC                           401              
Line 402 ERROR: Undefined symbol
000003AC  4EB9 004DBB8E            402              JSR EAGETSRCEA              
000003B2                           403              
000003B2  12FC 002C                404              MOVE.B  #',',(A1)+
000003B6  5241                     405              ADDQ    #1,D1
000003B8                           406              
000003B8  2C05                     407              MOVE.L  D5,D6
000003BA  E08E                     408              LSR.L   #8,D6               ; Shift our OpCode a total of 9 bits to the right
000003BC  E28E                     409              LSR.L   #1,D6               ; 
000003BE  0286 00000007            410              ANDI.L  #$07,D6             ; Isolate our data register
000003C4                           411              
Line 412 ERROR: Undefined symbol
000003C4  4EB9 004DBB8E            412              JSR EADN
000003CA                           413              
000003CA  4E75                     414              RTS
000003CC                           415  
000003CC                           416  ; This label determines if the code is either ADD or ADDA           
000003CC                           417  ADDADDA     *(Implement)
000003CC                           418                   
000003CC  4E75                     419              RTS
000003CE                           420  
000003CE                           421  ; This label determines if the code is either ASd (ASR) or LSd (LSL) or ROd (ROL) 
000003CE                           422  ASLSRO      *(Implement)
000003CE                           423                   
000003CE  4E75                     424              RTS
000003D0                           425  UNKNOWN
000003D0  22FC 3F3F3F3F            426              MOVE.L  #'????',(A1)+
000003D6  5841                     427              ADDQ    #4,D1           ; We added 4 new characters to our IOStringLoc 
000003D8                           428              
000003D8  22FC 20202020            429              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
000003DE  5841                     430              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
000003E0  32FC 2020                431              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
000003E4  5441                     432              ADDQ    #2,D1               ; We added 2 bytes, aka 2 spaces
000003E6                           433          
000003E6  4E75                     434              RTS
000003E8                           435  * Put variables and constants here
000003E8                           436  
Line 437 WARNING: END directive missing, starting address not set

15 errors detected
1 warning generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDADDA             3CC
ADDI                78
ADDI8               8C
ADDIB               B8
ADDIL               100
ADDIW               DC
AND                 300
ANDBDN              394
ANDBEA              348
ANDDN               39E
ANDEA               352
ANDLDN              380
ANDLEA              334
ANDWDN              38A
ANDWEA              33E
ASLSRO              3CE
BCC                 2AC
CLR                 1EA
CMP                 2B4
CNRJML              182
DIVU                2B0
JSR                 214
LEA                 2A0
MOVEB               124
MOVEL               144
MOVEM               220
MOVEML              246
MOVEMOP             24C
MOVEMPOSTI          284
MOVEMPRED           268
MOVEMW              23C
MOVEOP              154
MOVEQ               2AE
MOVEW               134
MULS                2C8
MULSAND             2B6
NOP                 1EC
OPGETCODE           0
RTS                 200
SUB                 2B2
UNKNOWN             3D0
