00008000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 3/13/2016 3:44:09 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : OpCode
00000000                             3  * Written by : Circles
00000000                             4  * Date       : ##/##/16
00000000                             5  * Description: Operation Codes File
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  * Put program code here
00000000                             9  
00000000                            10  ; Here we assume that A2 contains the address pointing to our OpCode, and
00000000                            11  ;  we assume that A1 contains the address pointing to our IOStringLoc
00000000  3A1A                      12  OPGETCODE   MOVE.W  (A2)+,D5    ; Push our OpCode into D5
00000002  2C05                      13              MOVE.L  D5,D6       ; Also store the OpCode in D6
00000004  E09E                      14              ROR.L   #8,D6       ; Rotate our OpCode to right-most nybble
00000006  E89E                      15              ROR.L   #4,D6       ; 
00000008  0206 000F                 16              ANDI.B  #$0F,D6     ; Isolate our opcode nybble
0000000C  BC3C 0000                 17              CMP.B   #$00,D6
00000010  6700 0066                 18              BEQ     ADDI        ; ADDI 
00000014  BC3C 0001                 19              CMP.B   #$01,D6     
00000018  6700 010A                 20              BEQ     MOVE        ; MOVE.B
0000001C  BC3C 0003                 21              CMP.B   #$03,D6     
00000020  6700 0102                 22              BEQ     MOVE        ; MOVE.W
00000024  BC3C 0002                 23              CMP.B   #$02,D6
00000028  6700 00FA                 24              BEQ     MOVE        ; MOVE.L
0000002C  BC3C 0004                 25              CMP.B   #$04,D6
00000030  6700 01A8                 26              BEQ     CNRJML      ; CLR or NOP or RTS or JSR or MOVEM or LEA
00000034  BC3C 0006                 27              CMP.B   #$06,D6
00000038  6700 048C                 28              BEQ     Bcc         ; Bcc (BCC, BGT, BLE) 
0000003C  BC3C 0007                 29              CMP.B   #$07,D6
00000040  6700 0590                 30              BEQ     MOVEQ       ; MOVEQ 
00000044  BC3C 0008                 31              CMP.B   #$08,D6
00000048  6700 05DA                 32              BEQ     DIVU        ; DIVU
0000004C  BC3C 0009                 33              CMP.B   #$09,D6
00000050  6700 0624                 34              BEQ     SUB         ; SUB
00000054  BC3C 000B                 35              CMP.B   #$0B,D6
00000058  6700 0702                 36              BEQ     CMP         ; CMP 
0000005C  BC3C 000C                 37              CMP.B   #$0C,D6
00000060  6700 079E                 38              BEQ     MULSAND     ; MULS or AND opcodes
00000064  BC3C 000D                 39              CMP.B   #$0D,D6
00000068  6700 0934                 40              BEQ     ADDADDA     ; ADD or ADDA
0000006C  BC3C 000E                 41              CMP.B   #$0E,D6 
00000070  6700 0A7C                 42              BEQ     ASLSRO      ; ASd (ASR) or LSd (LSL) or ROd (ROL)
00000074  6000 0C1A                 43              BRA     UNKNOWN  
00000078                            44              
00000078                            45  ;  Here we assume the first left-most 4 bits have been confirmed: 0000
00000078  2C05                      46  ADDI        MOVE.L  D5,D6               ; Push D5 into D6
0000007A  E09E                      47              ROR.L   #8,D6               ; Rotate left-most middle nybble to the right-most nybble
0000007C  0206 000F                 48              ANDI.B  #$0F,D6             ; Isolate opcode nybble
00000080  BC3C 0006                 49              CMP.B   #$06,D6             ; If it matches ADDI's left-most middle nybble, branch
00000084  6700 0006                 50              BEQ     ADDI8               ; First 8 left-most bits of ADDI confirmed 
00000088  6000 0C06                 51              BRA     UNKNOWN             ; else unknown                       
0000008C                            52  
0000008C                            53  ;  Here we assume the first left-most 8 bits have been confirmed: 0000 0110            
0000008C                            54  ADDI8                                  ; Two consecutive tests for illegal Src EA Modes
0000008C  2C05                      55              MOVE.L  D5,D6              ; Push D5 into D6 
0000008E  0286 0000003F             56              ANDI.L  #$003F,D6          ; Isolate the Src EA bits
00000094  BCBC 0000003C             57              CMP.L   #$003C,D6          ; Compare with illegal EA mode #<data>
0000009A  6700 0BF4                 58              BEQ     UNKNOWN
0000009E                            59              
0000009E  E69E                      60              ROR.L   #3,D6              ; Roll 3 bits right
000000A0  0286 00000007             61              ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
000000A6  BCBC 00000001             62              CMP.L   #$0001, D6         ; Compare with illegal mode An
000000AC  6700 0BE2                 63              BEQ     UNKNOWN
000000B0                            64              *--------------
000000B0                            65                                  
000000B0  2C05                      66              MOVE.L  D5,D6              ; Push D5 into D6 
000000B2  EC8E                      67              LSR.L   #6,D6              ; Shift six bits to the right
000000B4  0286 00000003             68              ANDI.L  #$0003,D6          ; Isolate the size bits
000000BA                            69                         
000000BA  BCBC 00000000             70              CMP.L   #$0000,D6          ; See if the size is '00'..
000000C0  6700 001A                 71              BEQ     ADDIB              ; ..If so, it's ANDI.B
000000C4  BCBC 00000001             72              CMP.L   #$0001,D6          ; See if the size is '01'..
000000CA  6700 0020                 73              BEQ     ADDIW              ; ..If so, it's ANDI.W
000000CE  BCBC 00000002             74              CMP.L   #$0002,D6          ; See if the size is '10'..
000000D4  6700 0026                 75              BEQ     ADDIL              ; ..If so, it's ANDI.L
000000D8                            76              
000000D8  6000 0BB6                 77              BRA     UNKNOWN            ; If it isn't any, then it's Unknown
000000DC                            78              
000000DC                            79  ADDIB       
000000DC  22FC 41444449             80              MOVE.L  #'ADDI',(A1)+
000000E2  32FC 2E42                 81              MOVE.W  #'.B',(A1)+
000000E6  5C41                      82              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc
000000E8  6000 0022                 83              BRA     ADDIOP
000000EC                            84              
000000EC                            85  ADDIW       
000000EC  22FC 41444449             86              MOVE.L  #'ADDI',(A1)+
000000F2  32FC 2E57                 87              MOVE.W  #'.W',(A1)+
000000F6  5C41                      88              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
000000F8  6000 0012                 89              BRA     ADDIOP
000000FC                            90              
000000FC                            91  ADDIL      
000000FC  22FC 41444449             92              MOVE.L  #'ADDI',(A1)+
00000102  32FC 2E4C                 93              MOVE.W  #'.L',(A1)+
00000106  5C41                      94              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
00000108  6000 0002                 95              BRA     ADDIOP
0000010C                            96  
0000010C  22FC 20202020             97  ADDIOP      MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
00000112  5841                      98              ADDQ    #4,D1              ; We added 4 bytes, aka 4 spaces
00000114                            99              
00000114  2C05                     100              MOVE.L  D5,D6              ; Push D5 into D6
00000116  0286 0000003F            101              ANDI.L  #$003F,D6          ; Isolate the Src EA bits 
Line 102 ERROR: Undefined symbol
0000011C  4EB9 004DBB8E            102              JSR EAGETSRCEA             ; Find and print the code stored in D6 
00000122  4E75                     103              RTS
00000124                           104                
00000124                           105  ;  Here we assume the first left-most 4 bits are: 0001, 0011, or 0010
00000124                           106  MOVE                                   ; Two consecutive tests for illegal Dst EA Modes
00000124  2C05                     107              MOVE.L  D5,D6              ; Push D5 into D6
00000126  EC9E                     108              ROR.L   #6,D6              ; Roll 6 bits right 
00000128  0286 0000003F            109              ANDI.L  #$003F,D6          ; Isolate the Dst EA bits
0000012E  BCBC 00000027            110              CMP.L   #$0027, D6         ; Compare with illegal EA mode #<data>
00000134  6700 0B5A                111              BEQ     UNKNOWN
00000138                           112              
00000138  0286 00000007            113              ANDI.L  #$0007,D6          ; Isolate the 3 Dst (Mode) bits
0000013E  BCBC 00000001            114              CMP.L   #$0001, D6         ; Compare with illegal mode An
00000144  6700 0B4A                115              BEQ     UNKNOWN
00000148                           116              *----------------                   
00000148  2C05                     117              MOVE.L  D5,D6              ; Push D5 into D6 
0000014A  EC8E                     118              LSR.L   #6,D6              ; Shift six bits to the right
0000014C  EC8E                     119              LSR.L   #6,D6              ; Shift six bits to the right
0000014E  0286 00000003            120              ANDI.L  #$0003,D6          ; Isolate the size bits
00000154                           121                         
00000154  BCBC 00000001            122              CMP.L   #$0001,D6          ; See if the size is '01'..
0000015A  6700 001A                123              BEQ     MOVEB              ; ..If so, it's MOVE.B
0000015E  BCBC 00000003            124              CMP.L   #$0003,D6          ; See if the size is '11'..
00000164  6700 0022                125              BEQ     MOVEW              ; ..If so, it's MOVE.W
00000168  BCBC 00000002            126              CMP.L   #$0002,D6          ; See if the size is '10'..
0000016E  6700 002A                127              BEQ     MOVEL              ; ..If so, it's MOVE.L
00000172                           128              
00000172  6000 0B1C                129              BRA     UNKNOWN            ; If it isn't any, then it's Unknown
00000176                           130              
00000176                           131  
00000176                           132  
00000176  22FC 4D4F5645            133  MOVEB       MOVE.L  #'MOVE',(A1)+
0000017C  32FC 2E42                134              MOVE.W  #'.B',(A1)+
00000180  5C41                     135              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
00000182                           136              
00000182  7001                     137              MOVE.L  #1,D0               ; Put 1 into D0 to indicate it's a bytesize
00000184                           138              
00000184  6000 0026                139              BRA MOVEOP
00000188                           140              
00000188  22FC 4D4F5645            141  MOVEW       MOVE.L  #'MOVE',(A1)+
0000018E  32FC 2E57                142              MOVE.W  #'.W',(A1)+
00000192  5C41                     143              ADDQ    #6,D1               ; We added 6 new characters to our IOStringLoc 
00000194                           144              
00000194  7002                     145              MOVE.L  #2,D0               ; Put 2 into D0 to indicate it's a wordsize
00000196                           146              
00000196  6000 0014                147              BRA MOVEOP
0000019A                           148              
0000019A  22FC 4D4F5645            149  MOVEL       MOVE.L  #'MOVE',(A1)+
000001A0  32FC 2E4C                150              MOVE.W  #'.L',(A1)+
000001A4  5C41                     151              ADDQ    #6,D1               ; We added 6 new characters to our IOStringLoc 
000001A6                           152              
000001A6  7003                     153              MOVE.L  #3,D0               ; Put 3 into D0 to indicate it's a longsize
000001A8                           154              
000001A8  6000 0002                155              BRA MOVEOP
000001AC                           156              
000001AC  22FC 20202020            157  MOVEOP      MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
000001B2  5841                     158              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
000001B4                           159              
000001B4  2C05                     160              MOVE.L  D5,D6               ; Push D5 into D6
000001B6  0286 0000003F            161              ANDI.L  #$003F,D6           ; Isolate the Src EA bits 
Line 162 ERROR: Undefined symbol
000001BC  4EB9 004DBB8E            162              JSR EAGETSRCEA              ; Find and print the code stored in D6
000001C2                           163              
000001C2  12FC 002C                164              MOVE.B  #',',(A1)+
000001C6  5241                     165              ADDQ    #1,D1
000001C8                           166              
000001C8  2C05                     167              MOVE.L  D5,D6               ; Push D5 into D6
000001CA  EC8E                     168              LSR.L   #6,D6               ; Shift six bits to the right
000001CC  0286 0000003F            169              ANDI.L  #$003F,D6           ; Isolate the Dst EA bits
Line 170 ERROR: Undefined symbol
000001D2  4EB9 004DBB8E            170              JSR EAGETDSTEA
000001D8  4E75                     171              RTS
000001DA                           172              
000001DA                           173  ; This label determines if the code is either CLR or NOP or RTS or JSR or MOVEM or LEA
000001DA                           174  ; Here we assume that the first left-most four bits equal 0100            
000001DA                           175  CNRJML      
000001DA  2C05                     176              MOVE.L  D5,D6              ; Push D5 into D6 (Copy OPcode over isolated nybble)
000001DC                           177              
000001DC                           178              *NOP & RTS's machine code is uniquely hardcoded, check first
000001DC  BCBC 00004E71            179              CMP.L   #$4E71,D6          ; See if the OPcode matches NOP's hardcode
000001E2  6700 010A                180              BEQ     NOP
000001E6  BCBC 00004E75            181              CMP.L   #$4E75,D6          ; See if the OPcode matches RTS's hardcode
000001EC  6700 011A                182              BEQ     RTS
000001F0                           183                                         ; CLR's middle most left nybble is unique (0010)
000001F0  E09E                     184              ROR.L   #8,D6              ; Rotate our OpCode to right-most nybble
000001F2  0206 000F                185              ANDI.B  #$0F,D6            ; Isolate our opcode nybble
000001F6  BC3C 0002                186              CMP.B   #$02,D6            ; See if matches nybble
000001FA  6700 0042                187              BEQ     CLR               
000001FE                           188              
000001FE                           189  *--------------------------------------------------------------------------------------            
000001FE                           190                                         ; LEA's left-most 10 bits are 0100 --- (111)
000001FE  2C05                     191              MOVE.L  D5,D6              ; Push D5 into D6
00000200  EC8E                     192              LSR.L   #6,D6              ; Shift 6 bits to the right 
00000202  0286 00000007            193              ANDI.L  #$0007,D6          ; Isolate 3 right-most bits
00000208  BCBC 00000007            194              CMP.L   #$0007,D6          ; See if matches 111
0000020E  6700 0232                195              BEQ     LEA                ; If equals, branch to LEA     
00000212                           196              
00000212                           197                                         ; JSR's left-most 10 bits are 0100 (111 010)
00000212  2C05                     198              MOVE.L  D5,D6              ; Push D5 into D6
00000214  EC8E                     199              LSR.L   #6,D6              ; Shift 6 bits to the right
00000216  0286 0000003F            200              ANDI.L  #$003F,D6          ; Isolate 6 right-most bit
0000021C  BCBC 0000003A            201              CMP.L   #$003A,D6          ; See if matches 11 1010
00000222  6700 00FE                202              BEQ     JSR                ; If equals, branch JSR
00000226                           203                 
00000226                           204                                         ; MOVEM's left-most 9 bits are 0100 1- (001)
00000226  2C05                     205              MOVE.L  D5,D6              ; Push D5 into D6
00000228  EE8E                     206              LSR.L   #7,D6              ; Shift 7 bits to the right
0000022A  0286 00000007            207              ANDI.L  #$0007,D6          ; Isolate 3 right-most bit
00000230  BCBC 00000001            208              CMP.L   #$0001,D6          ; See if matches 001
00000236  6700 0156                209              BEQ     MOVEM              ; If equals, branch MOVEM
0000023A                           210        
0000023A  6000 0A54                211              BRA     UNKNOWN            ; If it doesnt any match, then it's Unknown
0000023E                           212  
0000023E                           213  ******************************************************************************************
0000023E                           214  *            MOVE.L  D5,D6              ; Push D5 into D6
0000023E                           215  *            LSR.L   #8,D6              ; Shift 8 bits to the right
0000023E                           216  *            
0000023E                           217  *            BTST    #$00,D6            ; See if our right-most bit is set
0000023E                           218  *            BNE     LEA                ; If our bit is set, branch to LEA     
0000023E                           219  *            
0000023E                           220  *            LSR.L   #1,D6              ; Shift another bit
0000023E                           221  *            BTST    #$00,D6            ; See if our right-most bit is set
0000023E                           222  *            BNE     JSR                ; If this one is set, branch to JSR
0000023E                           223  *            
0000023E                           224  **            BRA MOVEM
0000023E                           225  **                                       ; LEA's middle most left nybble is unique (---1)
0000023E                           226  **            BTST    #0,D6              ; Check the right most bit's value
0000023E                           227  **            BNE     LEA                ; If equals 1, branch
0000023E                           228  *               
0000023E                           229  *                                       ; MOVEM's middle most left nybble is unique (1-00)
0000023E                           230  *            ROR.L   #2,D6              ; first bit must be 0, rotate 1 bit 
0000023E                           231  *            BTST    #0,D6               ; Compare again for 00 match
0000023E                           232  *            BNE     MOVEM                           
0000023E                           233  *                                       
0000023E                           234  **            MOVE.L  D5,D6              ; Push D5 into D6; JSR's middle nybbles are unique (1110 10--)
0000023E                           235  **            ROR.L   #6,D6              ; Rotate 6 bits
0000023E                           236  **            ANDI.L  #$00FF,D6          ; Isolate the 8 known bits (00 1110 10)
0000023E                           237  **            CMP.L   #$003A,D6          ; Compare
0000023E                           238  **            BEQ     JSR                ; Branch
0000023E                           239  **            
0000023E                           240  *            BRA     UNKNOWN            ; If it doesnt any match, then it's Unknown
0000023E                           241  *-----------------------------------------------------------------------------------------
0000023E                           242  
0000023E                           243  ;  Here we assume the first left-most 8 bits have been confirmed: 0100 0010
0000023E                           244  CLR                                    ; Two consecutive tests for illegal Src EA Modes
0000023E  2C05                     245              MOVE.L  D5,D6              ; Push D5 into D6 
00000240  0286 0000003F            246              ANDI.L  #$003F,D6          ; Isolate the Src EA bits
00000246  BCBC 0000003C            247              CMP.L   #$003C, D6         ; Compare with illegal EA mode #<data>
0000024C  6700 0A42                248              BEQ     UNKNOWN
00000250                           249              
00000250  E69E                     250              ROR.L   #3,D6              ; Roll 3 bits right
00000252  0286 00000007            251              ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
00000258  BCBC 00000001            252              CMP.L   #$0001,D6          ; Compare with illegal mode An
0000025E  6700 0A30                253              BEQ     UNKNOWN
00000262                           254              *----------------
00000262                           255              
00000262  2C05                     256              MOVE.L  D5,D6              ; Push D5 into D6
00000264  EC8E                     257              LSR.L   #6,D6              ; Shift six bits to the right
00000266  0286 00000003            258              ANDI.L  #$0003,D6          ; Isolate the two size bits
0000026C                           259                         
0000026C  BCBC 00000000            260              CMP.L   #$0000,D6          ; See if the size is '00'..
00000272  6700 001A                261              BEQ     CLRB               ; ..If so, it's CLR.B
00000276  BCBC 00000001            262              CMP.L   #$0001,D6          ; See if the size is '01'..
0000027C  6700 0026                263              BEQ     CLRW               ; ..If so, it's CLR.W
00000280  BCBC 00000002            264              CMP.L   #$0002,D6          ; See if the size is '10'..
00000286  6700 0032                265              BEQ     CLRL               ; ..If so, it's CLR.L
0000028A                           266              
0000028A  6000 0A04                267              BRA     UNKNOWN            ; If it isn't any, then it's Unknown
0000028E                           268              
0000028E  32FC 434C                269  CLRB        MOVE.W  #'CL',(A1)+
00000292  12FC 0052                270              MOVE.B  #'R',(A1)+
00000296  12FC 002E                271              MOVE.B  #'.',(A1)+
0000029A  12FC 0042                272              MOVE.B  #'B',(A1)+
0000029E  5A41                     273              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
000002A0  6000 002E                274              BRA     CLROP
000002A4                           275              
000002A4  32FC 434C                276  CLRW        MOVE.W  #'CL',(A1)+
000002A8  12FC 0052                277              MOVE.B  #'R',(A1)+
000002AC  12FC 002E                278              MOVE.B  #'.',(A1)+
000002B0  12FC 0057                279              MOVE.B  #'W',(A1)+
000002B4  5A41                     280              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
000002B6  6000 0018                281              BRA     CLROP
000002BA                           282  
000002BA  32FC 434C                283  CLRL        MOVE.W  #'CL',(A1)+
000002BE  12FC 0052                284              MOVE.B  #'R',(A1)+
000002C2  12FC 002E                285              MOVE.B  #'.',(A1)+
000002C6  12FC 004C                286              MOVE.B  #'L',(A1)+
000002CA  5A41                     287              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
000002CC  6000 0002                288              BRA     CLROP
000002D0                           289              
000002D0  12FC 0020                290  CLROP       MOVE.B  #' ',(A1)+
000002D4  32FC 2020                291              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
000002D8  32FC 2020                292              MOVE.W  #'  ',(A1)+
000002DC  5A41                     293              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces
000002DE                           294              
000002DE  2C05                     295              MOVE.L  D5,D6              ; Push D5 into D6
000002E0  0286 0000003F            296              ANDI.L  #$003F,D6          ; Isolate the Src EA bits 
Line 297 ERROR: Undefined symbol
000002E6  4EB9 004DBB8E            297              JSR EAGETSRCEA             ; Find and print the code stored in D6
000002EC                           298  
000002EC  4E75                     299              RTS
000002EE                           300              
000002EE                           301  ;  Here we assume that all 16 bits have been confirmed 
000002EE                           302  NOP
000002EE  32FC 4E4F                303              MOVE.W  #'NO',(A1)+
000002F2  12FC 0050                304              MOVE.B  #'P',(A1)+
000002F6  5641                     305              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
000002F8                           306              
000002F8  12FC 0020                307              MOVE.B  #' ',(A1)+       ; Add a spacer into our IOStringLoc
000002FC  32FC 2020                308              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
00000300  32FC 2020                309              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
00000304  5A41                     310              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces        
00000306  4E75                     311              RTS
00000308                           312  
00000308                           313  ;  Here we assume that all 16 bits have been confirmed            
00000308                           314  RTS         
00000308  32FC 5254                315              MOVE.W  #'RT',(A1)+
0000030C  12FC 0053                316              MOVE.B  #'S',(A1)+
00000310  5641                     317              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
00000312                           318              
00000312  12FC 0020                319              MOVE.B  #' ',(A1)+       ; Add a spacer into our IOStringLoc
00000316  32FC 2020                320              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
0000031A  32FC 2020                321              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
0000031E  5A41                     322              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces        
00000320  4E75                     323              RTS
00000322                           324              
00000322                           325  
00000322                           326  ;  Here we assume the first left-most 10 bits have been confirmed: 0100 1110 10 
00000322                           327  JSR                                    ; Five consecutive tests for illegal Src EA Modes
00000322  2C05                     328              MOVE.L  D5,D6              ; Push D5 into D6 
00000324  0286 0000003F            329              ANDI.L  #$003F,D6          ; Isolate the Src EA bits
0000032A  BCBC 0000003C            330              CMP.L   #$003C, D6         ; Compare with illegal EA mode #<data>
00000330  6700 095E                331              BEQ     UNKNOWN
00000334                           332              
00000334  E69E                     333              ROR.L   #3,D6              ; Roll 3 bits right
00000336  0286 00000007            334              ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
0000033C  BCBC 00000000            335              CMP.L   #$0000,D6          ; Compare with illegal mode Dn
00000342  6700 094C                336              BEQ     UNKNOWN
00000346  BCBC 00000001            337              CMP.L   #$0001,D6          ; Compare with illegal mode An
0000034C  6700 0942                338              BEQ     UNKNOWN
00000350  BCBC 00000003            339              CMP.L   #$0003,D6          ; Compare with illegal mode (An)+
00000356  6700 0938                340              BEQ     UNKNOWN
0000035A  BCBC 00000004            341              CMP.L   #$0004,D6          ; Compare with illegal mode -(An)
00000360  6700 092E                342              BEQ     UNKNOWN
00000364                           343              *----------------
00000364                           344  
00000364  32FC 4A53                345              MOVE.W  #'JS',(A1)+
00000368  12FC 0052                346              MOVE.B  #'R',(A1)+
0000036C  5641                     347              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
0000036E                           348              
0000036E  12FC 0020                349              MOVE.B  #' ',(A1)+
00000372  32FC 2020                350              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
00000376  22FC 20202020            351              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
0000037C  5E41                     352              ADDQ    #7,D1              ; We added 4 bytes, aka 4 spaces
0000037E  2C05                     353              MOVE.L  D5,D6              ; Push D5 into D6
00000380                           354              
00000380  0286 0000003F            355              ANDI.L  #$003F,D6          ; Isolate the Src EA bits 
Line 356 ERROR: Undefined symbol
00000386  4EB9 004DBB8E            356              JSR EAGETSRCEA             ; Find and print the code stored in D6 
0000038C  4E75                     357              RTS
0000038E                           358              
0000038E                           359  
0000038E                           360  ;  Here we assume that these left-most bits have been confirmed, where - have not been confirmed: 0100 -- 001
0000038E                           361  MOVEM                                  ; Four consecutive tests for illegal Src EA Modes
0000038E  2C05                     362              MOVE.L  D5,D6              ; Push D5 into D6 
00000390  0286 0000003F            363              ANDI.L  #$003F,D6          ; Isolate the Src EA bits
00000396  BCBC 0000003C            364              CMP.L   #$003C, D6         ; Compare with illegal EA mode #<data>
0000039C  6700 08F2                365              BEQ     UNKNOWN
000003A0                           366              
000003A0  E69E                     367              ROR.L   #3,D6              ; Roll 3 bits right
000003A2  0286 00000007            368              ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
000003A8  BCBC 00000000            369              CMP.L   #$0000,D6          ; Compare with illegal mode Dn
000003AE  6700 08E0                370              BEQ     UNKNOWN
000003B2  BCBC 00000001            371              CMP.L   #$0001,D6          ; Compare with illegal mode An
000003B8  6700 08D6                372              BEQ     UNKNOWN
000003BC  BCBC 00000003            373              CMP.L   #$0003,D6          ; Compare with illegal mode (An)+
000003C2  6700 08CC                374              BEQ     UNKNOWN
000003C6                           375              *----------------
000003C6                           376  
000003C6  22FC 4D4F5645            377              MOVE.L  #'MOVE',(A1)+
000003CC  32FC 4D2E                378              MOVE.W  #'M.',(A1)+
000003D0  5C41                     379              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
000003D2                           380              
000003D2  2C05                     381              MOVE.L  D5,D6              ; Copy our OpCode
000003D4  EC8E                     382              LSR.L   #6,D6              ; Shift it 6 bits to the right
000003D6  0806 0000                383              BTST    #$00,D6            ; If our size bit is 0..
000003DA  6700 0006                384              BEQ     MOVEMW             ; .. Its a MOVEM of size W
000003DE  6000 000C                385              BRA     MOVEML             ; .. Otherwise it's of size L
000003E2                           386  
000003E2  12FC 0057                387  MOVEMW      MOVE.B  #'W',(A1)+
000003E6  5241                     388              ADDQ    #1,D1              ; We've added another character into IOStringLoc
000003E8  6000 0008                389              BRA     MOVEMOP            ; MovemOp label, to skip MovemL label
000003EC                           390              
000003EC  12FC 004C                391  MOVEML      MOVE.B  #'L',(A1)+
000003F0  5241                     392              ADDQ    #1,D1              ; We've added another character into IOStringLoc
000003F2                           393              
000003F2  12FC 0020                394  MOVEMOP     MOVE.B  #' ',(A1)+         ; Add a spacer into our IOStringLoc
000003F6  32FC 2020                395              MOVE.W  #'  ',(A1)+        ;
000003FA  5641                     396              ADDQ    #3,D1              ; We added 4 bytes, aka 4 spaces 
000003FC                           397              
000003FC  E88E                     398              LSR.L   #4,D6              ; Shift our OpCode 4 bits to the left of Size (going to the right)
000003FE  0806 0000                399              BTST    #$00,D6            ; Check our Direction bit
00000402  6700 0006                400              BEQ     MOVEMPRED          ; If it's 0, our direction is Pre Decrement (eg. Move TO the stack)
00000406  6000 001E                401              BRA     MOVEMPOSTI         ; Otherwise, it's Post Increment (eg. Move FROM the stack)
0000040A                           402              
0000040A                           403  MOVEMPRED   ; This part is where we get the gross A0-A6/D0-D7 part
Line 404 ERROR: Undefined symbol
0000040A  4EB9 004DBB8E            404              JSR     EAMOVEMPRED  
00000410                           405              
00000410  12FC 002C                406              MOVE.B  #',',(A1)+
00000414  5241                     407              ADDQ    #1,D1
00000416                           408              
00000416  2C05                     409              MOVE.L  D5,D6              ; Copy our OpCode to D6
00000418  0286 0000003F            410              ANDI.L  #$3F,D6            ; Isolate our EA src bits
0000041E                           411              
Line 412 ERROR: Undefined symbol
0000041E  4EB9 004DBB8E            412              JSR EAGETSRCEA  
00000424                           413            
00000424  4E75                     414              RTS
00000426                           415  
00000426  2C05                     416  MOVEMPOSTI  MOVE.L  D5,D6              ; Copy our OpCode to D6
00000428  0286 0000003F            417              ANDI.L  #$3F,D6            ; Isolate our EA src bits
0000042E                           418              
Line 419 ERROR: Undefined symbol
0000042E  4EB9 004DBB8E            419              JSR EAGETSRCEA  
00000434                           420              
00000434  12FC 002C                421              MOVE.B  #',',(A1)+
00000438  5241                     422              ADDQ    #1,D1
0000043A                           423              
0000043A                           424              ; This part is where we get the gross A0-A6/D0-D7 part
Line 425 ERROR: Undefined symbol
0000043A  4EB9 004DBB8E            425              JSR     EAMOVEMPOSTI
00000440                           426              
00000440  4E75                     427              RTS
00000442                           428              
00000442                           429  
00000442                           430  ;  Here we assume that these left-most bits have been confirmed, where - have not been confirmed: 0100 --- 111            
00000442                           431  LEA                                    ; Five consecutive tests for illegal Src EA Modes
00000442  2C05                     432              MOVE.L  D5,D6              ; Push D5 into D6 
00000444  0286 0000003F            433              ANDI.L  #$003F,D6          ; Isolate the Src EA bits
0000044A  BCBC 0000003C            434              CMP.L   #$003C, D6         ; Compare with illegal EA mode #<data>
00000450  6700 083E                435              BEQ     UNKNOWN
00000454                           436              
00000454  E69E                     437              ROR.L   #3,D6              ; Roll 3 bits right
00000456  0286 00000007            438              ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
0000045C  BCBC 00000000            439              CMP.L   #$0000,D6          ; Compare with illegal mode Dn
00000462  6700 082C                440              BEQ     UNKNOWN
00000466  BCBC 00000001            441              CMP.L   #$0001,D6          ; Compare with illegal mode An
0000046C  6700 0822                442              BEQ     UNKNOWN
00000470  BCBC 00000003            443              CMP.L   #$0003,D6          ; Compare with illegal mode (An)+
00000476  6700 0818                444              BEQ     UNKNOWN
0000047A  BCBC 00000004            445              CMP.L   #$0004,D6          ; Compare with illegal mode -(An)
00000480  6700 080E                446              BEQ     UNKNOWN
00000484                           447              *----------------
00000484                           448              
00000484  32FC 4C45                449              MOVE.W  #'LE',(A1)+
00000488  12FC 0041                450              MOVE.B  #'A',(A1)+
0000048C  5641                     451              ADDQ    #3,D1               ; We added 3 new characters to our IOStringLoc 
0000048E                           452               
0000048E  12FC 0020                453              MOVE.B  #' ',(A1)+          ; Added an extra space here, due to only 3 character OpCode
00000492  22FC 20202020            454              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
00000498  32FC 2020                455              MOVE.W  #'  ',(A1)+ 
0000049C  5E41                     456              ADDQ    #7,D1               ; We added 4 bytes, aka 4 spaces
0000049E                           457              
0000049E  2C05                     458              MOVE.L  D5,D6               ; Copy D5 into D6
000004A0  0286 0000003F            459              ANDI.L  #$003F,D6           ; Isolate the Src EA bits
Line 460 ERROR: Undefined symbol
000004A6  4EB9 004DBB8E            460              JSR EAGETSRCEA
000004AC                           461              
000004AC  12FC 002C                462              MOVE.B  #',',(A1)+
000004B0  5241                     463              ADDQ    #1,D1
000004B2                           464              
000004B2  2C05                     465              MOVE.L  D5,D6               ; Copy D5 into D6
000004B4  E09E                     466              ROR.L   #8,D6               ; Rotate 9 bits to the right (An Dst bits)
000004B6  E29E                     467              ROR.L   #1,D6               ; 
000004B8  0286 00000003            468              ANDI.L  #$0003,D6           ; Isolate the An Destination bits
Line 469 ERROR: Undefined symbol
000004BE  4EF9 004DBB8E            469              JMP EAAN
000004C4  4E75                     470              RTS      
000004C6                           471              
000004C6  2C05                     472  Bcc         MOVE.L  D5,D6               ; Copy our OpCode into D6
000004C8  E15E                     473              ROL.W   #8,D6               ; Rotate our condition bit into place
000004CA  0206 000F                474              ANDI.B  #$0F,D6             ; Isolate the right-most nybble (condition)
000004CE                           475              
000004CE  BC3C 0004                476              CMP.B   #%0100,D6           ; See if our Condition is '0100'
000004D2  6700 0016                477              BEQ     BCCOP               ; If it is, we have a BCC operation
000004D6  BC3C 000E                478              CMP.B   #%1110,D6           ; See if our Condition is '1110'
000004DA  6700 001C                479              BEQ     BGTOP               ; If it is, we have a BGT operation
000004DE  BC3C 000F                480              CMP.B   #%1111,D6           ; See if our Condition is '1111'
000004E2  6700 0022                481              BEQ     BLEOP               ; If it is, we have a BLE operation
000004E6                           482              
000004E6  6000 07A8                483              BRA     UNKNOWN             ; Otherwise we don't know what kind of operation we have
000004EA                           484              
000004EA  32FC 4243                485  BCCOP       MOVE.W  #'BC',(A1)+
000004EE  12FC 0043                486              MOVE.B  #'C',(A1)+
000004F2  5641                     487              ADDQ    #3,D1               ; We've added three characters into our IOStringLoc
000004F4  6000 001E                488              BRA     BccSIZE             ; Branch to find our Bcc Op's Size
000004F8                           489              
000004F8  32FC 4247                490  BGTOP       MOVE.W  #'BG',(A1)+
000004FC  12FC 0054                491              MOVE.B  #'T',(A1)+
00000500  5641                     492              ADDQ    #3,D1               ; We've added three characters into our IOStringLoc
00000502  6000 0010                493              BRA     BccSIZE             ; Branch to find our Bcc Op's Size
00000506                           494              
00000506  32FC 424C                495  BLEOP       MOVE.W  #'BL',(A1)+
0000050A  12FC 0045                496              MOVE.B  #'E',(A1)+
0000050E  5641                     497              ADDQ    #3,D1               ; We've added three characters into our IOStringLoc
00000510  6000 0002                498              BRA     BccSIZE             ; Branch to find our Bcc Op's Size
00000514                           499  
00000514                           500  BccSIZE     ; Find Displacement value
00000514                           501              ; Branch to proper displacement value label
00000514                           502              ; Store the value of A2 into D7
00000514                           503              ; Get our total displacement into D6
00000514                           504              ; Print the new address as D7 +/- D6
00000514                           505              
00000514  12FC 0020                506              MOVE.B  #' ',(A1)+       ; Add a spacer into our IOStringLoc
00000518  32FC 2020                507              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
0000051C  32FC 2020                508              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
00000520  32FC 2020                509              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
00000524  5E41                     510              ADDQ    #7,D1              ; We added 4 bytes, aka 4 spaces   
00000526                           511              
00000526  12FC 0024                512              MOVE.B  #'$',(A1)+
0000052A  5241                     513              ADDQ    #1,D1
0000052C                           514              
0000052C  2C05                     515              MOVE.L  D5,D6
0000052E  0286 000000FF            516              ANDI.L  #$FF,D6             ; Isolate our Size bits
00000534  BC3C 0000                517              CMP.B   #$00,D6             ; If it's equal to $00..
00000538  6700 0032                518              BEQ     Bcc16               ; .. It has a 16 bit displacement
0000053C  0286 000000FF            519              ANDI.L  #$FF,D6             ; If it's equal to $FF..
00000542  6700 0050                520              BEQ     Bcc32               ; .. It has a 32 bit displacement
00000546                           521              ; Otherwise, it's an 8 bit displacement
00000546                           522              
00000546  2E0A                     523              MOVE.L  A2,D7               ; Get our initial address
00000548  4A06                     524              TST.B   D6                  ; Is D6 negative?
0000054A  6B00 0010                525              BMI     Bcc8NEG             ; Branch to Negative
0000054E                           526              
0000054E  DE46                     527              ADD.W   D6,D7               ; Otherwise, Add what we have to D7
00000550                           528              
00000550  2C07                     529              MOVE.L  D7,D6               ; Push our expected address into D6 to print
00000552  4244                     530              CLR     D4                  ; Clear counter
Line 531 ERROR: Undefined symbol
00000554  4EB9 004DBB8E            531              JSR     EAHEXtoASCII        ; Print
0000055A                           532              
0000055A  4E75                     533              RTS 
0000055C                           534              
0000055C  4406                     535  Bcc8NEG     NEG.B   D6 
0000055E  9E46                     536              SUB.W   D6,D7
00000560                           537              
00000560  2C07                     538              MOVE.L  D7,D6               ; Push our expected address into D6 to print
00000562  4244                     539              CLR     D4                  ; Clear counter
Line 540 ERROR: Undefined symbol
00000564  4EB9 004DBB8E            540              JSR     EAHEXtoASCII        ; Print
0000056A                           541              
0000056A  4E75                     542              RTS  
0000056C                           543           
0000056C  2E0A                     544  Bcc16       MOVE.L  A2,D7               ; Get our initial address
0000056E  3C1A                     545              MOVE.W  (A2)+,D6
00000570  4A46                     546              TST.W   D6                  ; Is D6 negative?
00000572  6B00 0010                547              BMI     Bcc16NEG             ; Branch to Negative
00000576                           548              
00000576  DE86                     549              ADD.L   D6,D7               ; Otherwise, Add what we have to D7
00000578                           550              
00000578  2C07                     551              MOVE.L  D7,D6               ; Push our expected address into D6 to print
0000057A  4244                     552              CLR     D4                  ; Clear counter
Line 553 ERROR: Undefined symbol
0000057C  4EB9 004DBB8E            553              JSR     EAHEXtoASCII        ; Print
00000582                           554              
00000582  4E75                     555              RTS 
00000584  4446                     556  Bcc16NEG    NEG.W   D6 
00000586  9E86                     557              SUB.L   D6,D7
00000588                           558              
00000588  2C07                     559              MOVE.L  D7,D6               ; Push our expected address into D6 to print
0000058A  4244                     560              CLR     D4                  ; Clear counter
Line 561 ERROR: Undefined symbol
0000058C  4EB9 004DBB8E            561              JSR     EAHEXtoASCII        ; Print
00000592                           562              
00000592  4E75                     563              RTS  
00000594                           564  
00000594                           565  
00000594  2E0A                     566  Bcc32       MOVE.L  A2,D7               ; Get our initial address
00000596  2C1A                     567              MOVE.L  (A2)+,D6
00000598  4A86                     568              TST.L   D6                  ; Is D6 negative?
0000059A  6BE8                     569              BMI     Bcc16NEG            ; Branch to Negative
0000059C                           570              
0000059C  DE86                     571              ADD.L   D6,D7               ; Otherwise, Add what we have to D7
0000059E                           572              
0000059E  2C07                     573              MOVE.L  D7,D6               ; Push our expected address into D6 to print
000005A0  4244                     574              CLR     D4                  ; Clear counter
000005A2  4846                     575              SWAP    D6
Line 576 ERROR: Undefined symbol
000005A4  4EB9 004DBB8E            576              JSR     EAHEXtoASCII        ; Print
000005AA  4244                     577              CLR     D4                  ; Clear counter
000005AC  4846                     578              SWAP    D6
Line 579 ERROR: Undefined symbol
000005AE  4EB9 004DBB8E            579              JSR     EAHEXtoASCII        ; Print
000005B4                           580              
000005B4  4E75                     581              RTS 
000005B6                           582  
000005B6  4486                     583  Bcc32NEG    NEG.L   D6 
000005B8  9E86                     584              SUB.L   D6,D7
000005BA                           585              
000005BA  2C07                     586              MOVE.L  D7,D6               ; Push our expected address into D6 to print
000005BC  4244                     587              CLR     D4                  ; Clear counter
000005BE  4846                     588              SWAP    D6
Line 589 ERROR: Undefined symbol
000005C0  4EB9 004DBB8E            589              JSR     EAHEXtoASCII        ; Print
000005C6  4244                     590              CLR     D4                  ; Clear counter
000005C8  4846                     591              SWAP    D6
Line 592 ERROR: Undefined symbol
000005CA  4EB9 004DBB8E            592              JSR     EAHEXtoASCII        ; Print
000005D0                           593      
000005D0  4E75                     594              RTS           
000005D2                           595  MOVEQ
000005D2  22FC 4D4F5645            596              MOVE.L  #'MOVE',(A1)+
000005D8  12FC 0051                597              MOVE.B  #'Q',(A1)+
000005DC  5A41                     598              ADDQ    #5,D1               ; We added 4 new characters to our IOStringLoc
000005DE                           599              
000005DE  12FC 0020                600              MOVE.B  #' ',(A1)+
000005E2  32FC 2020                601              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
000005E6  32FC 2020                602              MOVE.W  #'  ',(A1)+
000005EA  5841                     603              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
000005EC                           604              
000005EC  2C05                     605              MOVE.L  D5,D6               ; Copy D5 into D6
000005EE  0286 000000FF            606              ANDI.L  #$00FF,D6           ; Isolate the Src EA bits
000005F4                           607              
000005F4  12FC 0023                608              MOVE.B  #'#',(A1)+
000005F8  12FC 0024                609              MOVE.B  #'$',(A1)+
000005FC  5241                     610              ADDQ    #1,D1               ; We added 4 bytes, aka 4 spaces
000005FE  183C 0002                611              MOVE.B  #2,D4               ; "Start" at 2 characters
00000602  E19E                     612              ROL.L   #$8,D6
Line 613 ERROR: Undefined symbol
00000604  4EB9 004DBB8E            613              JSR     EAHEXtoASCII
0000060A                           614              
0000060A  12FC 002C                615              MOVE.B  #',',(A1)+
0000060E  5241                     616              ADDQ    #1,D1
00000610                           617              
00000610  2C05                     618              MOVE.L  D5,D6               ; Copy D5 into D6
00000612  E09E                     619              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00000614  E29E                     620              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00000616  0286 00000007            621              ANDI.L  #$0007,D6           ; Isolate the Dn Destination bits
Line 622 ERROR: Undefined symbol
0000061C  4EF9 004DBB8E            622              JMP EADN
00000622                           623              
00000622  4E75                     624              RTS 
00000624                           625              
00000624                           626  DIVU 
00000624                           627                                         ; One test for illegal Src EA Mode
00000624  2C05                     628              MOVE.L  D5,D6              ; Push D5 into D6   
00000626  E69E                     629              ROR.L   #3,D6              ; Roll 3 bits right
00000628  0286 00000007            630              ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
0000062E  BCBC 00000001            631              CMP.L   #$0001,D6          ; Compare with illegal mode An
00000634  6700 065A                632              BEQ     UNKNOWN
00000638                           633              *----------------       
00000638  22FC 44495655            634              MOVE.L  #'DIVU',(A1)+
0000063E  5841                     635              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00000640                           636              
00000640  22FC 20202020            637              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
00000646  32FC 2020                638              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
0000064A  5C41                     639              ADDQ    #6,D1               ; We added 4 bytes, aka 4 spaces
0000064C                           640              
0000064C  2C05                     641              MOVE.L  D5,D6               ; Copy D5 into D6
0000064E  0286 0000003F            642              ANDI.L  #$003F,D6           ; Isolate the Src EA bits
00000654  7002                     643              MOVE.L  #2,D0               ; Put 2 into D0 to indicate it's a wordsize
Line 644 ERROR: Undefined symbol
00000656  4EB9 004DBB8E            644              JSR EAGETSRCEA
0000065C                           645              
0000065C  12FC 002C                646              MOVE.B  #',',(A1)+
00000660  5241                     647              ADDQ    #1,D1
00000662                           648              
00000662  2C05                     649              MOVE.L  D5,D6               ; Copy D5 into D6
00000664  E09E                     650              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00000666  E29E                     651              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00000668  0286 00000007            652              ANDI.L  #$0007,D6           ; Isolate the Dn Destination bits
Line 653 ERROR: Undefined symbol
0000066E  4EF9 004DBB8E            653              JMP EADN
00000674                           654              
00000674  4E75                     655              RTS
00000676                           656  
00000676                           657              
00000676  2C05                     658  SUB         MOVE.L  D5,D6               ; Copy D5 into D6
00000678  EC8E                     659              LSR.L   #6,D6               ; Shift the size bits to the far right
0000067A  0206 0004                660              ANDI.B  #$4,D6              ; Isolate the size bits    
0000067E                           661                   
0000067E  BC3C 0004                662              CMP.B   #%0100,D6           ; See if D6 is size "%100" through "%110"..
00000682  6700 0026                663              BEQ     SUBEA              ; If it is, our OpCode is in the format of..
00000686                           664              
00000686  2C05                     665              MOVE.L  D5,D6               ; Copy D5 into D6
00000688  EC8E                     666              LSR.L   #6,D6               ; Shift the size bits to the far right
0000068A  0206 0007                667              ANDI.B  #$7,D6              ; Isolate the size bits    
0000068E                           668              
0000068E  BC3C 0002                669              CMP.B   #%10,D6             ; See if D6 is size "%000" through "%010"..
00000692  6700 0092                670              BEQ     SUBLDN              ; If it is, our OpCode is in the format of..
00000696  BC3C 0001                671              CMP.B   #%01,D6             ; .. <EA> ~ Dn --> Dn
0000069A  6700 009C                672              BEQ     SUBWDN
0000069E  BC3C 0000                673              CMP.B   #%00,D6
000006A2  6700 00A6                674              BEQ     SUBBDN              ; == 000 at this point
000006A6                           675              
000006A6  6000 05E8                676              BRA     UNKNOWN
000006AA                           677              
000006AA  2C05                     678  SUBEA       MOVE.L  D5,D6               ; Copy D5 into D6
000006AC  CC3C 003F                679              AND.B   #$3F,D6             ; Isolate our EA Src bits
000006B0  BC3C 0039                680              CMP.B   #$39,D6             ; Check for Illegal #$ mode
000006B4  6700 05DA                681              BEQ     UNKNOWN
000006B8  CC3C 0038                682              AND.B   #$38,D6             ; Isolate our EA Src Mode bits
000006BC  BC3C 0008                683              CMP.B   #$08,D6             ; Check for Illegal mode An
000006C0  6700 05CE                684              BEQ     UNKNOWN
000006C4  BC3C 0000                685              CMP.B   #$00,D6             ; Check for Illegal mode Dn 
000006C8  6700 05C6                686              BEQ     UNKNOWN
000006CC                           687              
000006CC  2C05                     688              MOVE.L  D5,D6               ; Copy D5 into D6
000006CE  EC8E                     689              LSR.L   #6,D6               ; Shift the size bits to the far right
000006D0  0206 0007                690              ANDI.B  #$7,D6              ; Isolate the size bits    
000006D4                           691                   
000006D4  BC3C 0006                692              CMP.B   #%0110,D6           ; See if D6 is size "%100" through "%110"..
000006D8  6700 0016                693              BEQ     SUBLEA              ; If it is, our OpCode is in the format of..
000006DC  BC3C 0005                694              CMP.B   #%101,D6            ; .. Dn ~ <EA> --> <EA>
000006E0  6700 0020                695              BEQ     SUBWEA
000006E4  BC3C 0004                696              CMP.B   #%100,D6
000006E8  6700 002A                697              BEQ     SUBBEA
000006EC                           698              
000006EC  6000 05A2                699              BRA     UNKNOWN
000006F0                           700  
000006F0  22FC 5355422E            701  SUBLEA      MOVE.L  #'SUB.',(A1)+
000006F6  5841                     702              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000006F8  12FC 004C                703              MOVE.B  #'L',(A1)+
000006FC  5241                     704              ADDQ    #1,D1               ; We added 1 byte into D1
000006FE  6000 0204                705              BRA     ANDEA
00000702                           706              
00000702  22FC 5355422E            707  SUBWEA      MOVE.L  #'SUB.',(A1)+
00000708  5841                     708              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
0000070A  12FC 0057                709              MOVE.B  #'W',(A1)+
0000070E  5241                     710              ADDQ    #1,D1               ; We added 1 byte into D1
00000710  6000 01F2                711              BRA     ANDEA
00000714                           712  
00000714  22FC 5355422E            713  SUBBEA      MOVE.L  #'SUB.',(A1)+
0000071A  5841                     714              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
0000071C  12FC 0042                715              MOVE.B  #'B',(A1)+
00000720  5241                     716              ADDQ    #1,D1               ; We added 1 byte into D1
00000722  6000 01E0                717              BRA     ANDEA
00000726                           718  
00000726  22FC 5355422E            719  SUBLDN      MOVE.L  #'SUB.',(A1)+
0000072C  5841                     720              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
0000072E  12FC 004C                721              MOVE.B  #'L',(A1)+
00000732  5241                     722              ADDQ    #1,D1               ; We added 1 byte into D1
00000734  6000 023A                723              BRA ANDDN
00000738                           724              
00000738  22FC 5355422E            725  SUBWDN      MOVE.L  #'SUB.',(A1)+
0000073E  5841                     726              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00000740  12FC 0057                727              MOVE.B  #'W',(A1)+
00000744  5241                     728              ADDQ    #1,D1               ; We added 1 byte into D1
00000746  6000 0228                729              BRA ANDDN
0000074A                           730  
0000074A  22FC 5355422E            731  SUBBDN      MOVE.L  #'SUB.',(A1)+
00000750  5841                     732              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00000752  12FC 0042                733              MOVE.B  #'B',(A1)+
00000756  5241                     734              ADDQ    #1,D1               ; We added 1 byte into D1
00000758  6000 0216                735              BRA ANDDN  
0000075C                           736  
0000075C                           737  ;  Here we assume that these left-most nybble has been confirmed: 1011  
0000075C                           738  CMP        
0000075C  2C05                     739              MOVE.L  D5,D6               ; Push D5 into D6
0000075E  EC9E                     740              ROR.L   #6,D6               ; Rotate 6 bits to the right
00000760  E38E                     741              LSL.L   #1,D6               ; Add 0 to right most bit
00000762  0206 000F                742              ANDI.B  #$0F,D6             ; Isolate right-most nybble
00000766                           743              
00000766  BC3C 0000                744              CMP.B   #$00,D6             ; If it matches CMP.B's size bit + 0 added to right
0000076A  6700 0016                745              BEQ     CMPB                ; First 4 left-most bits plus size of CMP confirmed
0000076E                           746  
0000076E  BC3C 0002                747              CMP.B   #$02,D6             ; If it matches CMP.W's size bit + 0 added to right
00000772  6700 0026                748              BEQ     CMPW                ; First 4 left-most bits plus size of CMP confirmed 
00000776                           749  
00000776  BC3C 0004                750              CMP.B   #$04,D6             ; If it matches CMP.B's size bit + 0 added to right
0000077A  6700 0036                751              BEQ     CMPL                ; First 4 left-most bits plus size of CMP confirmed 
0000077E                           752   
0000077E  6000 0510                753              BRA     UNKNOWN             ; else unknown 
00000782                           754  
00000782                           755  ;  Here we assume that confirming these bits, 1011 --- 000 --- ---, is enough to identify CMP.B 
00000782  32FC 434D                756  CMPB        MOVE.W  #'CM',(A1)+
00000786  12FC 0050                757              MOVE.B  #'P',(A1)+
0000078A  12FC 002E                758              MOVE.B  #'.',(A1)+
0000078E  12FC 0042                759              MOVE.B  #'B',(A1)+
00000792  5A41                     760              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
00000794  7001                     761              MOVE.L  #1,D0               ; Put 1 into D0 to indicate it's a bytesize
00000796  6000 0032                762              BRA     CMPOP
0000079A                           763  
0000079A                           764  ;  Here we assume that confirming these bits, 1011 --- 001 --- ---, is enough to identify CMP.W   
0000079A  32FC 434D                765  CMPW        MOVE.W  #'CM',(A1)+
0000079E  12FC 0050                766              MOVE.B  #'P',(A1)+
000007A2  12FC 002E                767              MOVE.B  #'.',(A1)+
000007A6  12FC 0057                768              MOVE.B  #'W',(A1)+
000007AA  5A41                     769              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
000007AC  7002                     770              MOVE.L  #2,D0               ; Put 2 into D0 to indicate it's a wordsize
000007AE  6000 001A                771              BRA     CMPOP
000007B2                           772              
000007B2                           773  ;  Here we assume that confirming these bits, 1011 --- 010 --- ---, is enough to identify CMP.L
000007B2  32FC 434D                774  CMPL        MOVE.W  #'CM',(A1)+
000007B6  12FC 0050                775              MOVE.B  #'P',(A1)+
000007BA  12FC 002E                776              MOVE.B  #'.',(A1)+
000007BE  12FC 004C                777              MOVE.B  #'L',(A1)+
000007C2  5A41                     778              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
000007C4  7003                     779              MOVE.L  #3,D0               ; Put 3 into D0 to indicate it's a longsize
000007C6  6000 0002                780              BRA     CMPOP
000007CA                           781              
000007CA  12FC 0020                782  CMPOP       MOVE.B  #' ',(A1)+
000007CE  32FC 2020                783              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
000007D2  32FC 2020                784              MOVE.W  #'  ',(A1)+
000007D6  5A41                     785              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces
000007D8                           786              
000007D8  2C05                     787              MOVE.L  D5,D6               ; Push D5 into D6
000007DA  0286 0000003F            788              ANDI.L  #$003F,D6           ; Isolate the Src EA bits 
Line 789 ERROR: Undefined symbol
000007E0  4EB9 004DBB8E            789              JSR EAGETSRCEA              ; Find and print the code stored in D6
000007E6                           790              
000007E6  12FC 002C                791              MOVE.B  #',',(A1)+
000007EA  5241                     792              ADDQ    #1,D1
000007EC                           793              
000007EC  2C05                     794              MOVE.L  D5,D6               ; Copy D5 into D6
000007EE  E09E                     795              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
000007F0  E29E                     796              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
000007F2  0286 00000007            797              ANDI.L  #$0007,D6           ; Isolate the Dn Destination bits
Line 798 ERROR: Undefined symbol
000007F8  4EF9 004DBB8E            798              JMP EADN
000007FE                           799              
000007FE  4E75                     800              RTS          
00000800                           801          
00000800                           802  ; This label determines if the code is either MULS or AND, by looking at it's size bits     
00000800  2C05                     803  MULSAND     MOVE.L  D5,D6               ; Copy D5 into D6
00000802  CC3C 0038                804              AND.B   #$38,D6             ; Check if the Src is of mode An
00000806  BC3C 0008                805              CMP.B   #$08,D6
0000080A  6700 0484                806              BEQ     UNKNOWN             ; An is Invalid, branch to Unknown  
0000080E  2C05                     807              MOVE.L  D5,D6               ; Copy D5 into D6 
00000810  EC8E                     808              LSR.L   #6,D6               ; Shift the size bits to the far right
00000812  0206 0007                809              ANDI.B  #$7,D6              ; Isolate the size bits
00000816  BC3C 0007                810              CMP.B   #7,D6               ; See if the size is '111'..
0000081A  6704                     811              BEQ.S   MULS                ; ..If so, it's a MULS opcode
0000081C  6000 0040                812              BRA     AND                 ; Otherwise, it's an AND code
00000820                           813          
00000820                           814  MULS                                   ; One test for illegal Src EA Mode
00000820                           815  *            MOVE.L  D5,D6              ; Push D5 into D6   
00000820                           816  *            ROR.L   #3,D6              ; Roll 3 bits right
00000820                           817  *            ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
00000820                           818  *            CMP.L   #$0001,D6          ; Compare with illegal mode An
00000820                           819  *            BEQ     UNKNOWN
00000820                           820              *----------------
00000820  22FC 4D554C53            821              MOVE.L  #'MULS',(A1)+
00000826  5841                     822              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00000828                           823              
00000828  22FC 20202020            824              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
0000082E  32FC 2020                825              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
00000832  5C41                     826              ADDQ    #6,D1               ; We added 4 bytes, aka 4 spaces
00000834                           827              
00000834  7002                     828              MOVE.L  #2,D0               ; Put 2 into D0 to indicate it's a wordsize
00000836  2C05                     829              MOVE.L  D5,D6               ; Copy D5 into D6
00000838  0286 0000003F            830              ANDI.L  #$003F,D6           ; Isolate the Src EA bits
Line 831 ERROR: Undefined symbol
0000083E  4EB9 004DBB8E            831              JSR EAGETSRCEA
00000844                           832              
00000844  12FC 002C                833              MOVE.B  #',',(A1)+
00000848  5241                     834              ADDQ    #1,D1
0000084A                           835              
0000084A  2C05                     836              MOVE.L  D5,D6               ; Copy D5 into D6
0000084C  E09E                     837              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
0000084E  E29E                     838              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00000850  0286 00000007            839              ANDI.L  #$0007,D6           ; Isolate the Dn Destination bits
Line 840 ERROR: Undefined symbol
00000856  4EF9 004DBB8E            840              JMP EADN
0000085C                           841              
0000085C  4E75                     842              RTS
0000085E                           843              
0000085E                           844  ; At this point, we know D6 is the size of our opcode
0000085E  CC3C 0004                845  AND         AND.B   #$04,D6
00000862  BC3C 0004                846              CMP.B   #%0100,D6           ; See if D6 is size "%100" through "%110"..
00000866  6700 0026                847              BEQ     ANDEACH             ; .. Dn ~ <EA> --> <EA>
0000086A                           848              
0000086A  2C05                     849              MOVE.L  D5,D6               ; Copy D5 into D6
0000086C  EC8E                     850              LSR.L   #6,D6               ; Shift the size bits to the far right
0000086E  0206 0007                851              ANDI.B  #$7,D6              ; Isolate the size bits 
00000872                           852              
00000872  BC3C 0002                853              CMP.B   #%10,D6             ; See if D6 is size "%000" through "%010"..
00000876  6700 00C2                854              BEQ     ANDLDN              ; If it is, our OpCode is in the format of..
0000087A  BC3C 0001                855              CMP.B   #%01,D6             ; .. <EA> ~ Dn --> Dn
0000087E  6700 00CC                856              BEQ     ANDWDN
00000882  BC3C 0000                857              CMP.B   #%00,D6
00000886  6700 00D6                858              BEQ     ANDBDN              ; == 000 at this point
0000088A                           859              
0000088A  6000 0404                860              BRA     UNKNOWN
0000088E                           861  
0000088E  2C05                     862  ANDEACH     MOVE.L  D5,D6               ; Copy D5 into D6
00000890  CC3C 003F                863              AND.B   #$3F,D6             ; Isolate our EA Src bits
00000894  BC3C 0039                864              CMP.B   #$39,D6             ; Check for Illegal #$ mode
00000898  6700 03F6                865              BEQ     UNKNOWN
0000089C  CC3C 0038                866              AND.B   #$38,D6             ; Isolate our EA Src Mode bits
000008A0  BC3C 0008                867              CMP.B   #$08,D6             ; Check for Illegal mode An
000008A4  6700 03EA                868              BEQ     UNKNOWN
000008A8  BC3C 0000                869              CMP.B   #$00,D6             ; Check for Illegal mode Dn 
000008AC  6700 03E2                870              BEQ     UNKNOWN
000008B0                           871              
000008B0  2C05                     872              MOVE.L  D5,D6               ; Copy D5 into D6
000008B2  EC8E                     873              LSR.L   #6,D6               ; Shift the size bits to the far right
000008B4  0206 0007                874              ANDI.B  #$7,D6              ; Isolate the size bits    
000008B8                           875                   
000008B8  BC3C 0006                876              CMP.B   #%0110,D6           ; See if D6 is size "%100" through "%110"..
000008BC  6700 0016                877              BEQ     ANDLEA              ; If it is, our OpCode is in the format of..
000008C0  BC3C 0005                878              CMP.B   #%101,D6            ; .. Dn ~ <EA> --> <EA>
000008C4  6700 001E                879              BEQ     ANDWEA
000008C8  BC3C 0004                880              CMP.B   #%100,D6
000008CC  6700 0026                881              BEQ     ANDBEA
000008D0                           882              
000008D0  6000 03BE                883              BRA     UNKNOWN
000008D4                           884  
000008D4                           885              
000008D4  22FC 414E442E            886  ANDLEA      MOVE.L  #'AND.',(A1)+
000008DA  12FC 004C                887              MOVE.B  #'L',(A1)+
000008DE  5A41                     888              ADDQ    #5,D1               ; We added 5 byte into D1
000008E0  6000 0022                889              BRA     ANDEA
000008E4                           890              
000008E4  22FC 414E442E            891  ANDWEA      MOVE.L  #'AND.',(A1)+
000008EA  12FC 0057                892              MOVE.B  #'W',(A1)+
000008EE  5A41                     893              ADDQ    #5,D1               ; We added 5 byte into D1
000008F0  6000 0012                894              BRA     ANDEA
000008F4                           895  
000008F4  22FC 414E442E            896  ANDBEA      MOVE.L  #'AND.',(A1)+
000008FA  12FC 0042                897              MOVE.B  #'B',(A1)+
000008FE  5A41                     898              ADDQ    #5,D1               ; We added 5 byte into D1
00000900  6000 0002                899              BRA     ANDEA
00000904                           900  
00000904  12FC 0020                901  ANDEA       MOVE.B  #' ',(A1)+          ; Add a spacer into our IOStringLoc
00000908  32FC 2020                902              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
0000090C  32FC 2020                903              MOVE.W  #'  ',(A1)+          ; Add a spacer into our IOStringLoc
00000910  5A41                     904              ADDQ    #5,D1               ; We added 4 bytes, aka 4 spaces
00000912                           905              
00000912  2C05                     906              MOVE.L  D5,D6
00000914  E08E                     907              LSR.L   #8,D6               ; Shift our OpCode a total of 9 bits to the right
00000916  E28E                     908              LSR.L   #1,D6               ; 
00000918  0286 00000007            909              ANDI.L  #$07,D6             ; Isolate our data register
0000091E                           910              
Line 911 ERROR: Undefined symbol
0000091E  4EB9 004DBB8E            911              JSR EADN
00000924                           912              
00000924  12FC 002C                913              MOVE.B  #',',(A1)+
00000928  5241                     914              ADDQ    #1,D1
0000092A                           915              
0000092A  2C05                     916              MOVE.L  D5,D6               ; Copy our OpCode again
0000092C  0286 0000003F            917              ANDI.L  #$3F,D6             ; Isolate our EA bits
00000932                           918              
Line 919 ERROR: Undefined symbol
00000932  4EB9 004DBB8E            919              JSR EAGETSRCEA  
00000938                           920              
00000938  4E75                     921              RTS
0000093A                           922              
0000093A  22FC 414E442E            923  ANDLDN      MOVE.L  #'AND.',(A1)+
00000940  5841                     924              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00000942  12FC 004C                925              MOVE.B  #'L',(A1)+
00000946  5241                     926              ADDQ    #1,D1               ; We added 1 byte into D1
00000948  6000 0026                927              BRA ANDDN
0000094C                           928              
0000094C  22FC 414E442E            929  ANDWDN      MOVE.L  #'AND.',(A1)+
00000952  5841                     930              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00000954  12FC 0057                931              MOVE.B  #'W',(A1)+
00000958  5241                     932              ADDQ    #1,D1               ; We added 1 byte into D1
0000095A  6000 0014                933              BRA ANDDN
0000095E                           934  
0000095E  22FC 414E442E            935  ANDBDN      MOVE.L  #'AND.',(A1)+
00000964  5841                     936              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00000966  12FC 0042                937              MOVE.B  #'B',(A1)+
0000096A  5241                     938              ADDQ    #1,D1               ; We added 1 byte into D1
0000096C  6000 0002                939              BRA ANDDN  
00000970                           940  
00000970                           941  ANDDN
00000970  12FC 0009                942              MOVE.B  #$09,(A1)+          ; Add a spacer into our IOStringLoc
00000974  5241                     943              ADDQ    #1,D1               ; We added 4 bytes, aka 4 spaces
00000976                           944              
00000976  2C05                     945              MOVE.L  D5,D6               ; Copy our OpCode again
00000978  0286 0000003F            946              ANDI.L  #$3F,D6             ; Isolate our EA bits
0000097E                           947              
Line 948 ERROR: Undefined symbol
0000097E  4EB9 004DBB8E            948              JSR EAGETSRCEA              
00000984                           949              
00000984  12FC 002C                950              MOVE.B  #',',(A1)+
00000988  5241                     951              ADDQ    #1,D1
0000098A                           952              
0000098A  2C05                     953              MOVE.L  D5,D6
0000098C  E08E                     954              LSR.L   #8,D6               ; Shift our OpCode a total of 9 bits to the right
0000098E  E28E                     955              LSR.L   #1,D6               ; 
00000990  0286 00000007            956              ANDI.L  #$07,D6             ; Isolate our data register
00000996                           957              
Line 958 ERROR: Undefined symbol
00000996  4EB9 004DBB8E            958              JSR EADN
0000099C                           959              
0000099C  4E75                     960              RTS
0000099E                           961  
0000099E                           962  ; This label determines if the code is either ADD or ADDA           
0000099E  2C05                     963  ADDADDA     MOVE.L  D5,D6               ; Copy D5 into D6
000009A0  EC8E                     964              LSR.L   #6,D6               ; Shift the size bits to the far right
000009A2  0206 0004                965              ANDI.B  #$4,D6              ; Isolate the size bits
000009A6                           966              
000009A6  BC3C 0004                967              CMP.B   #%0100,D6           ; See if D6 is size "%100" through "%110"..
000009AA  6700 006C                968              BEQ     ADDEA              ; .. Dn ~ <EA> --> <EA>
000009AE                           969              
000009AE  2C05                     970              MOVE.L  D5,D6               ; Copy D5 into D6
000009B0  EC8E                     971              LSR.L   #6,D6               ; Shift the size bits to the far right
000009B2  0206 0007                972              ANDI.B  #$7,D6              ; Isolate the size bits
000009B6                           973  
000009B6                           974              
000009B6  BC3C 0002                975              CMP.B   #%10,D6             ; See if D6 is size "%000" through "%010"..
000009BA  6700 0026                976              BEQ     ADDLDN              ; If it is, our OpCode is in the format of..
000009BE  BC3C 0001                977              CMP.B   #%01,D6             ; .. <EA> ~ Dn --> Dn
000009C2  6700 0030                978              BEQ     ADDWDN
000009C6  BC3C 0000                979              CMP.B   #%00,D6
000009CA  6700 003A                980              BEQ     ADDBDN              ; == 000 at this point
000009CE                           981              
000009CE  BC3C 0003                982              CMP.B   #%011,D6            ; ADDA Word Operation <EA> -> An 
000009D2  6700 00C2                983              BEQ     ADDAW
000009D6  BC3C 0007                984              CMP.B   #%111,D6            ; ADDA Word Operation <EA> -> An  
000009DA  6700 00CE                985              BEQ     ADDAL
000009DE  6000 02B0                986              BRA     UNKNOWN
000009E2                           987              
000009E2  22FC 4144442E            988  ADDLDN      MOVE.L  #'ADD.',(A1)+
000009E8  5841                     989              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000009EA  12FC 004C                990              MOVE.B  #'L',(A1)+
000009EE  5241                     991              ADDQ    #1,D1               ; We added 1 byte into D1
000009F0  6000 FF7E                992              BRA ANDDN
000009F4                           993              
000009F4  22FC 4144442E            994  ADDWDN      MOVE.L  #'ADD.',(A1)+
000009FA  5841                     995              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000009FC  12FC 0057                996              MOVE.B  #'W',(A1)+
00000A00  5241                     997              ADDQ    #1,D1               ; We added 1 byte into D1
00000A02  6000 FF6C                998              BRA ANDDN
00000A06                           999  
00000A06  22FC 4144442E           1000  ADDBDN      MOVE.L  #'ADD.',(A1)+
00000A0C  5841                    1001              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00000A0E  12FC 0042               1002              MOVE.B  #'B',(A1)+
00000A12  5241                    1003              ADDQ    #1,D1               ; We added 1 byte into D1
00000A14  6000 FF5A               1004              BRA ANDDN  
00000A18                          1005  
00000A18  2C05                    1006  ADDEA       MOVE.L  D5,D6               ; Copy D5 into D6
00000A1A  CC3C 003F               1007              AND.B   #$3F,D6             ; Isolate our EA Src bits
00000A1E  BC3C 0039               1008              CMP.B   #$39,D6             ; Check for Illegal #$ mode
00000A22  6700 026C               1009              BEQ     UNKNOWN
00000A26  CC3C 0038               1010              AND.B   #$38,D6             ; Isolate our EA Src Mode bits
00000A2A  BC3C 0008               1011              CMP.B   #$08,D6             ; Check for Illegal mode An
00000A2E  6700 0260               1012              BEQ     UNKNOWN
00000A32  BC3C 0000               1013              CMP.B   #$00,D6             ; Check for Illegal mode Dn 
00000A36  6700 0258               1014              BEQ     UNKNOWN
00000A3A                          1015              
00000A3A  2C05                    1016              MOVE.L  D5,D6               ; Copy D5 into D6
00000A3C  EC8E                    1017              LSR.L   #6,D6               ; Shift the size bits to the far right
00000A3E  0206 0007               1018              ANDI.B  #$7,D6              ; Isolate the size bits    
00000A42                          1019                   
00000A42  BC3C 0006               1020              CMP.B   #%0110,D6           ; See if D6 is size "%100" through "%110"..
00000A46  6700 0016               1021              BEQ     ADDLEA              ; If it is, our OpCode is in the format of..
00000A4A  BC3C 0005               1022              CMP.B   #%101,D6            ; .. Dn ~ <EA> --> <EA>
00000A4E  6700 0020               1023              BEQ     ADDWEA
00000A52  BC3C 0004               1024              CMP.B   #%100,D6
00000A56  6700 002A               1025              BEQ     ADDBEA
00000A5A                          1026              
00000A5A  6000 0234               1027              BRA     UNKNOWN
00000A5E                          1028  
00000A5E                          1029              
00000A5E  22FC 4144442E           1030  ADDLEA      MOVE.L  #'ADD.',(A1)+
00000A64  5841                    1031              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00000A66  12FC 004C               1032              MOVE.B  #'L',(A1)+
00000A6A  5241                    1033              ADDQ    #1,D1               ; We added 1 byte into D1
00000A6C  6000 FE96               1034              BRA     ANDEA
00000A70                          1035              
00000A70  22FC 4144442E           1036  ADDWEA      MOVE.L  #'ADD.',(A1)+
00000A76  5841                    1037              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00000A78  12FC 0057               1038              MOVE.B  #'W',(A1)+
00000A7C  5241                    1039              ADDQ    #1,D1               ; We added 1 byte into D1
00000A7E  6000 FE84               1040              BRA     ANDEA
00000A82                          1041  
00000A82  22FC 4144442E           1042  ADDBEA      MOVE.L  #'ADD.',(A1)+
00000A88  5841                    1043              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00000A8A  12FC 0042               1044              MOVE.B  #'B',(A1)+
00000A8E  5241                    1045              ADDQ    #1,D1               ; We added 1 byte into D1
00000A90  7001                    1046              MOVE.L  #1,D0               ; Move 1 into D0 to indicate bytesize
00000A92  6000 FE70               1047              BRA     ANDEA
00000A96                          1048              
00000A96  22FC 41444441           1049  ADDAW       MOVE.L  #'ADDA',(A1)+
00000A9C  5841                    1050              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00000A9E  32FC 2E57               1051              MOVE.W  #'.W',(A1)+
00000AA2  5441                    1052              ADDQ    #2,D1               ; We added 1 byte into D1
00000AA4  7002                    1053              MOVE.L  #2,D0               ; Move 2 into D0 to indicate wordsize
00000AA6  6000 0016               1054              BRA     ADDAN
00000AAA                          1055              
00000AAA  22FC 41444441           1056  ADDAL       MOVE.L  #'ADDA',(A1)+
00000AB0  5841                    1057              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00000AB2  32FC 2E4C               1058              MOVE.W  #'.L',(A1)+
00000AB6  5441                    1059              ADDQ    #2,D1               ; We added 1 byte into D1
00000AB8  7003                    1060              MOVE.L  #3,D0               ; Move 3 into D0 to indicate longsize
00000ABA  6000 0002               1061              BRA     ADDAN
00000ABE                          1062         
00000ABE                          1063  ADDAN
00000ABE  22FC 20202020           1064              MOVE.L  #'    ',(A1)+          ; Add a spacer into our IOStringLoc
00000AC4                          1065              
00000AC4  5841                    1066              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
00000AC6                          1067              
00000AC6  2C05                    1068              MOVE.L  D5,D6               ; Copy our OpCode again
00000AC8  0286 0000003F           1069              ANDI.L  #$3F,D6             ; Isolate our EA bits
00000ACE                          1070              
Line 1071 ERROR: Undefined symbol
00000ACE  4EB9 004DBB8E           1071              JSR EAGETSRCEA              
00000AD4                          1072              
00000AD4  12FC 002C               1073              MOVE.B  #',',(A1)+
00000AD8  5241                    1074              ADDQ    #1,D1
00000ADA                          1075              
00000ADA  2C05                    1076              MOVE.L  D5,D6
00000ADC  E08E                    1077              LSR.L   #8,D6               ; Shift our OpCode a total of 9 bits to the right
00000ADE  E28E                    1078              LSR.L   #1,D6               ; 
00000AE0  0286 00000007           1079              ANDI.L  #$07,D6             ; Isolate our data register
00000AE6                          1080              
Line 1081 ERROR: Undefined symbol
00000AE6  4EB9 004DBB8E           1081              JSR EAAN
00000AEC                          1082              
00000AEC  4E75                    1083              RTS
00000AEE                          1084  ; This label determines if the code is either ASd (ASR) or LSd (LSL) or ROd (ROL) 
00000AEE                          1085  ASLSRO
00000AEE  2C05                    1086              MOVE.L  D5,D6               ; Copy our OpCode
00000AF0  EC4E                    1087              LSR.W   #6,D6               ; Shift our size bits into place
00000AF2  0206 0003               1088              ANDI.B  #$03,D6             ; Isolate our size bits
00000AF6  BC3C 0003               1089              CMP.B   #%11,D6             ; If our size is '11'..
00000AFA  6700 00E2               1090              BEQ     AASLSRO             ; ..this is an address ASLSRO
00000AFE                          1091              
00000AFE  2C05                    1092              MOVE.L  D5,D6               ; Copy our OpCode
00000B00  E64E                    1093              LSR.W   #3,D6               ; Shift our identification bits over
00000B02  0206 0003               1094              ANDI.B  #03,D6              ;  and isolate them
00000B06                          1095              
00000B06  BC3C 0000               1096              CMP.B   #%00,D6             ; If '00', this is a ASd op
00000B0A  6700 0016               1097              BEQ     ASD
00000B0E  BC3C 0001               1098              CMP.B   #%01,D6             ; If '01', this is a LSd op
00000B12  6700 0018               1099              BEQ     LSD
00000B16  BC3C 0003               1100              CMP.B   #%11,D6             ; If '11', this is a ROd op
00000B1A  6700 001A               1101              BEQ     ROD
00000B1E                          1102              
00000B1E  6000 0170               1103              BRA     UNKNOWN             ; This catches for ROX, non-required op
00000B22                          1104  
00000B22  32FC 4153               1105  ASD         MOVE.W  #'AS',(A1)+
00000B26  5441                    1106              ADDQ    #2,D1
00000B28  6000 0016               1107              BRA     ASLSRODR
00000B2C                          1108              
00000B2C  32FC 4C53               1109  LSD         MOVE.W  #'LS',(A1)+
00000B30  5441                    1110              ADDQ    #2,D1
00000B32  6000 000C               1111              BRA     ASLSRODR
00000B36                          1112              
00000B36  32FC 524F               1113  ROD         MOVE.W  #'RO',(A1)+
00000B3A  5441                    1114              ADDQ    #2,D1
00000B3C  6000 0002               1115              BRA     ASLSRODR
00000B40                          1116              
00000B40                          1117  ; This section checks our ASd/LSd/ROd direction, and defaults to Right 
00000B40  2C05                    1118  ASLSRODR    MOVE.L  D5,D6               ; Copy our OpCode
00000B42  E09E                    1119              ROR.L   #8,D6               ; Shift our direction bit into place
00000B44  0806 0000               1120              BTST    #$00,D6             ; Check our right-most bit 
00000B48  6600 0010               1121              BNE     ASLSRODL            ; If it's '1', our direction is left
00000B4C                          1122              
00000B4C  12FC 0052               1123              MOVE.B  #'R',(A1)+          ; Otherwise it's right
00000B50  12FC 002E               1124              MOVE.B  #'.',(A1)+
00000B54  5441                    1125              ADDQ    #2,D1
00000B56                          1126              
00000B56  6000 000C               1127              BRA ASLSROSIZE
00000B5A                          1128              
00000B5A                          1129  ; This section is our ASd/LSd/ROd left direction
00000B5A  12FC 004C               1130  ASLSRODL    MOVE.B  #'L',(A1)+          ; L for Left
00000B5E  12FC 002E               1131              MOVE.B  #'.',(A1)+
00000B62  5441                    1132              ADDQ    #2,D1
00000B64                          1133              ; Carry into our Size determiner
00000B64                          1134  ; Determines what size our ASd/LSd/ROd is
00000B64                          1135  ;  Our previous operations on D6 leave our size bits
00000B64                          1136  ;  just our of range, so we shift them in
00000B64                          1137  ASLSROSIZE  
00000B64  E59E                    1138              ROL.L   #2,D6               ; Shift our size bits in
00000B66  0206 0003               1139              ANDI.B  #$03,D6             ; Isolate our size bits
00000B6A  BC3C 0000               1140              CMP.B   #%00,D6             ; If our size is '00'..
00000B6E  6700 0012               1141              BEQ     ASLSROB             ; ..Then it's a byte op
00000B72  BC3C 0001               1142              CMP.B   #%01,D6             ; If our size is '01'..
00000B76  6700 0012               1143              BEQ     ASLSROW             ; ..Then it's a word op
00000B7A                          1144              ; Otherwise it's a long op, because we accounted for '11' earlier
00000B7A                          1145              
00000B7A  12FC 004C               1146              MOVE.B  #'L',(A1)+          ; Add L for Long
00000B7E  6000 000E               1147              BRA     ASLSROIR            ; Complete the rest of the ASLSRO Op
00000B82                          1148              
00000B82  12FC 0042               1149  ASLSROB     MOVE.B  #'B',(A1)+          ; Add B for Byte
00000B86  6000 0006               1150              BRA     ASLSROIR            ; Complete the rest of the ASLSRO Op
00000B8A                          1151              
00000B8A  12FC 0057               1152  ASLSROW     MOVE.B  #'W',(A1)+          ; Add W for Word
00000B8E                          1153              ; Carry through to complete the rest of the ASLSRO Op  
00000B8E                          1154       
00000B8E                          1155  ; This section determines if our ASLSRO is an Immediate or Dn shfit, and defaults to Immediate
00000B8E  12FC 0020               1156  ASLSROIR    MOVE.B  #' ',(A1)+
00000B92  32FC 2020               1157              MOVE.W  #'  ',(A1)+
00000B96  32FC 2020               1158              MOVE.W  #'  ',(A1)+
00000B9A  5C41                    1159              ADDQ    #6,D1               ; We've added 5 new characters (Size char, plus spaces)
00000B9C                          1160              
00000B9C                          1161              ;MOVE.L  D5,D6
00000B9C  E39E                    1162              ROL.L   #1,D6               ; Get our Immediate / Register bit out front
00000B9E  0806 0000               1163              BTST.L  #$00,D6
00000BA2  6600 000C               1164              BNE     ASLSROIRDN          ; If it's '1', we have a Dn ASLSRO
00000BA6                          1165              ; Otherwise, assume immediate ASLSRO
00000BA6  12FC 0023               1166              MOVE.B  #'#',(A1)+
00000BAA  5241                    1167              ADDQ    #1,D1
00000BAC  6000 0008               1168              BRA     ASLSROOP            ; Branch to our ASLSRO Op finish
00000BB0                          1169  ; An ASLSRO of Dn Register type   
00000BB0  12FC 0044               1170  ASLSROIRDN  MOVE.B  #'D',(A1)+
00000BB4  5241                    1171              ADDQ    #1,D1
00000BB6                          1172              ; Continue through to our ASLSRO Op finish
00000BB6                          1173  ; Finishes the ASLSRO Op
00000BB6                          1174  ASLSROOP
00000BB6  2C05                    1175              MOVE.L  D5,D6               ; Copy our OpCode into D6
00000BB8  E09E                    1176              ROR.L   #8,D6               ; Shift our Count/Reg bits into place
00000BBA  E29E                    1177              ROR.L   #1,D6               ;
00000BBC  0206 0007               1178              ANDI.B  #$07,D6             ; Isolate the Count/Reg bits
00000BC0                          1179              
00000BC0  0606 0030               1180              ADDI.B  #48,D6 
00000BC4  12C6                    1181              MOVE.B  D6,(A1)+            ; Push our number to the IOStringLoc
00000BC6  5241                    1182              ADDQ    #1,D1
00000BC8                          1183              
00000BC8  12FC 002C               1184              MOVE.B  #',',(A1)+
00000BCC  5241                    1185              ADDQ    #1,D1
00000BCE                          1186              
00000BCE  2C05                    1187              MOVE.L  D5,D6               ; Isolate our Dn affected num bits
00000BD0  0286 00000007           1188              ANDI.L  #$07,D6             ;
Line 1189 ERROR: Undefined symbol
00000BD6  4EB9 004DBB8E           1189              JSR     EADN
00000BDC                          1190              
00000BDC  4E75                    1191              RTS
00000BDE                          1192  ; Start of the Effective Address version of ASLSRO
00000BDE  2C05                    1193  AASLSRO     MOVE.L  D5,D6               ; Copy our OpCode into D6
00000BE0  CCBC 0000003F           1194              AND.L   #$3F,D6             ; Isolate the EA Srcs bits
00000BE6  BC3C 0039               1195              CMP.B   #$39,D6             ; Check for illegal #$ mode
00000BEA  6700 00A4               1196              BEQ     UNKNOWN
00000BEE  CCBC 00000038           1197              AND.L   #$38,D6             ; Isolate the EA src mode bits
00000BF4  BC3C 0008               1198              CMP.B   #$08,D6             ; Check for illegal An Mode
00000BF8  6700 0096               1199              BEQ     UNKNOWN
00000BFC  BC3C 0000               1200              CMP.B   #$00,D6             ; Check for illegal Dn mode
00000C00  6700 008E               1201              BEQ     UNKNOWN
00000C04                          1202              
00000C04                          1203  
00000C04  2C05                    1204              MOVE.L  D5,D6               ; Copy our OpCode into D6
00000C06  EF5E                    1205              ROL.W   #7,D6               ; Shift our determination bits to the far right
00000C08  0206 0007               1206              ANDI.B  #$07,D6             ; Isolate the determination bits   
00000C0C                          1207              
00000C0C  BC3C 0001               1208              CMP.B   #$01,D6             ; If our determination is '001'..
00000C10  6700 0020               1209              BEQ     ALSD                ; It's a Logical Shift
00000C14  BC3C 0003               1210              CMP.B   #$03,D6             ; If it's '011'
00000C18  6700 0022               1211              BEQ     AROD                ; It's a Rotation 
00000C1C  BC3C 0000               1212              CMP.B   #$00,D6             ; If it's '000'
00000C20  6700 0006               1213              BEQ     AASD                ; It's an Arithmetic Shift
00000C24                          1214              
00000C24  6000 006A               1215              BRA     UNKNOWN              ; Otherwise it's data
00000C28                          1216  
00000C28  32FC 4153               1217  AASD        MOVE.W  #'AS',(A1)+
00000C2C  5441                    1218              ADDQ    #2,D1
00000C2E  6000 0016               1219              BRA     AASLSRODR
00000C32                          1220              
00000C32  32FC 4C53               1221  ALSD        MOVE.W  #'LS',(A1)+
00000C36  5441                    1222              ADDQ    #2,D1
00000C38  6000 000C               1223              BRA     AASLSRODR
00000C3C                          1224              
00000C3C  32FC 524F               1225  AROD        MOVE.W  #'RO',(A1)+
00000C40  5441                    1226              ADDQ    #2,D1
00000C42  6000 0002               1227              BRA     AASLSRODR
00000C46                          1228              
00000C46                          1229  ; This section checks our ASd/LSd/ROd direction, and defaults to Right 
00000C46  2C05                    1230  AASLSRODR   MOVE.L  D5,D6              ; Copy our OpCode
00000C48  E09E                    1231              ROR.L   #8,D6               ; Shift our direction bit into place
00000C4A  0806 0000               1232              BTST    #$00,D6             ; Check our right-most bit 
00000C4E  6600 000C               1233              BNE     AASLSRODL           ; If it's '1', our direction is left
00000C52                          1234              
00000C52  12FC 0052               1235              MOVE.B  #'R',(A1)+          ; Otherwise it's right
00000C56  5241                    1236              ADDQ    #1,D1
00000C58                          1237              
00000C58  6000 0008               1238              BRA AASLSROOP
00000C5C                          1239              
00000C5C                          1240  ; This section is our ASd/LSd/ROd left direction
00000C5C  12FC 004C               1241  AASLSRODL   MOVE.B  #'L',(A1)+          ; L for Left
00000C60  5241                    1242              ADDQ    #1,D1
00000C62                          1243              ; Carry into finishing AASLSRO op
00000C62                          1244  
00000C62                          1245  ; This section finishes off our Effective Address ASLSRO Op
00000C62  2C05                    1246  AASLSROOP   MOVE.L  D5,D6               ; Copy our OpCode
00000C64  0286 0000003F           1247              ANDI.L  #$3F,D6             ; Isolate our EA bits
00000C6A                          1248              
00000C6A  12FC 002E               1249              MOVE.B  #'.',(A1)+
00000C6E  12FC 0057               1250              MOVE.B  #'W',(A1)+
00000C72  12FC 0020               1251              MOVE.B  #' ',(A1)+
00000C76  12FC 0020               1252              MOVE.B  #' ',(A1)+
00000C7A  12FC 0020               1253              MOVE.B  #' ',(A1)+
00000C7E  12FC 0020               1254              MOVE.B  #' ',(A1)+
00000C82  12FC 0020               1255              MOVE.B  #' ',(A1)+
00000C86  5E41                    1256              ADDQ    #7,D1
00000C88                          1257              
Line 1258 ERROR: Undefined symbol
00000C88  4EB9 004DBB8E           1258              JSR EAGETSRCEA
00000C8E                          1259              
00000C8E  4E75                    1260              RTS
00000C90                          1261  UNKNOWN
00000C90  22FC 44415441           1262              MOVE.L  #'DATA',(A1)+
00000C96  5841                    1263              ADDQ    #4,D1           ; We added 4 new characters to our IOStringLoc 
00000C98                          1264              
00000C98  22FC 20202020           1265              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
00000C9E  32FC 2020               1266              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
00000CA2  5C41                    1267              ADDQ    #6,D1               ; We added 6 bytes, aka 6 spaces
00000CA4                          1268              
00000CA4  12FC 0024               1269              MOVE.B  #'$',(A1)+
00000CA8  5241                    1270              ADDQ    #1,D1
00000CAA                          1271              
00000CAA  2C05                    1272              MOVE.L  D5,D6
Line 1273 ERROR: Undefined symbol
00000CAC  4EB9 004DBB8E           1273              JSR     EAHEXtoASCII
00000CB2                          1274              
00000CB2  4E75                    1275              RTS
00000CB4                          1276  * Put variables and constants here
00000CB4                          1277  
00000CB4                          1278  
00000CB4                          1279  
00000CB4                          1280  
00000CB4                          1281  
00000CB4                          1282  
00000CB4                          1283  
00000CB4                          1284  
00000CB4                          1285  
00000CB4                          1286  
00000CB4                          1287  
00000CB4                          1288  
00000CB4                          1289  
00000CB4                          1290  
Line 1291 WARNING: END directive missing, starting address not set

36 errors detected
1 warning generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AASD                C28
AASLSRO             BDE
AASLSRODL           C5C
AASLSRODR           C46
AASLSROOP           C62
ADDADDA             99E
ADDAL               AAA
ADDAN               ABE
ADDAW               A96
ADDBDN              A06
ADDBEA              A82
ADDEA               A18
ADDI                78
ADDI8               8C
ADDIB               DC
ADDIL               FC
ADDIOP              10C
ADDIW               EC
ADDLDN              9E2
ADDLEA              A5E
ADDWDN              9F4
ADDWEA              A70
ALSD                C32
AND                 85E
ANDBDN              95E
ANDBEA              8F4
ANDDN               970
ANDEA               904
ANDEACH             88E
ANDLDN              93A
ANDLEA              8D4
ANDWDN              94C
ANDWEA              8E4
AROD                C3C
ASD                 B22
ASLSRO              AEE
ASLSROB             B82
ASLSRODL            B5A
ASLSRODR            B40
ASLSROIR            B8E
ASLSROIRDN          BB0
ASLSROOP            BB6
ASLSROSIZE          B64
ASLSROW             B8A
BCC                 4C6
BCC16               56C
BCC16NEG            584
BCC32               594
BCC32NEG            5B6
BCC8NEG             55C
BCCOP               4EA
BCCSIZE             514
BGTOP               4F8
BLEOP               506
CLR                 23E
CLRB                28E
CLRL                2BA
CLROP               2D0
CLRW                2A4
CMP                 75C
CMPB                782
CMPL                7B2
CMPOP               7CA
CMPW                79A
CNRJML              1DA
DIVU                624
JSR                 322
LEA                 442
LSD                 B2C
MOVE                124
MOVEB               176
MOVEL               19A
MOVEM               38E
MOVEML              3EC
MOVEMOP             3F2
MOVEMPOSTI          426
MOVEMPRED           40A
MOVEMW              3E2
MOVEOP              1AC
MOVEQ               5D2
MOVEW               188
MULS                820
MULSAND             800
NOP                 2EE
OPGETCODE           0
ROD                 B36
RTS                 308
SUB                 676
SUBBDN              74A
SUBBEA              714
SUBEA               6AA
SUBLDN              726
SUBLEA              6F0
SUBWDN              738
SUBWEA              702
UNKNOWN             C90
