00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 3/13/2016 9:30:47 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : OpCode
00000000                             3  * Written by : Circles
00000000                             4  * Date       : ##/##/16
00000000                             5  * Description: Operation Codes File
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  * Put program code here
00000000                             9  
00000000                            10  ; Here we assume that A2 contains the address pointing to our OpCode, and
00000000                            11  ;  we assume that A1 contains the address pointing to our IOStringLoc
00000000  3A1A                      12  OPGETCODE   MOVE.W  (A2)+,D5    ; Push our OpCode into D5
00000002  2C05                      13              MOVE.L  D5,D6       ; Also store the OpCode in D6
00000004  E09E                      14              ROR.L   #8,D6       ; Rotate our OpCode to right-most nybble
00000006  E89E                      15              ROR.L   #4,D6       ; 
00000008  0206 000F                 16              ANDI.B  #$0F,D6     ; Isolate our opcode nybble
0000000C  BC3C 0000                 17              CMP.B   #$00,D6
00000010  6700 0066                 18              BEQ     ADDI        ; ADDI 
00000014  BC3C 0001                 19              CMP.B   #$01,D6     
00000018  6700 0194                 20              BEQ     MOVE        ; MOVE.B
0000001C  BC3C 0003                 21              CMP.B   #$03,D6     
00000020  6700 018C                 22              BEQ     MOVE        ; MOVE.W
00000024  BC3C 0002                 23              CMP.B   #$02,D6
00000028  6700 0184                 24              BEQ     MOVE        ; MOVE.L
0000002C  BC3C 0004                 25              CMP.B   #$04,D6
00000030  6700 0232                 26              BEQ     CNRJML      ; CLR or NOP or RTS or JSR or MOVEM or LEA
00000034  BC3C 0006                 27              CMP.B   #$06,D6
00000038  6700 0522                 28              BEQ     Bcc         ; Bcc (BCC, BGT, BLE) 
0000003C  BC3C 0007                 29              CMP.B   #$07,D6
00000040  6700 0626                 30              BEQ     MOVEQ       ; MOVEQ 
00000044  BC3C 0008                 31              CMP.B   #$08,D6
00000048  6700 0670                 32              BEQ     DIVU        ; DIVU
0000004C  BC3C 0009                 33              CMP.B   #$09,D6
00000050  6700 06BA                 34              BEQ     SUB         ; SUB
00000054  BC3C 000B                 35              CMP.B   #$0B,D6
00000058  6700 0798                 36              BEQ     CMP         ; CMP 
0000005C  BC3C 000C                 37              CMP.B   #$0C,D6
00000060  6700 0834                 38              BEQ     MULSAND     ; MULS or AND opcodes
00000064  BC3C 000D                 39              CMP.B   #$0D,D6
00000068  6700 09C8                 40              BEQ     ADDADDA     ; ADD or ADDA
0000006C  BC3C 000E                 41              CMP.B   #$0E,D6 
00000070  6700 0B10                 42              BEQ     ASLSRO      ; ASd (ASR) or LSd (LSL) or ROd (ROL)
00000074  6000 0CAE                 43              BRA     UNKNOWN  
00000078                            44              
00000078                            45  ;  Here we assume the first left-most 4 bits have been confirmed: 0000
00000078  2C05                      46  ADDI        MOVE.L  D5,D6               ; Push D5 into D6
0000007A  E09E                      47              ROR.L   #8,D6               ; Rotate left-most middle nybble to the right-most nybble
0000007C  0206 000F                 48              ANDI.B  #$0F,D6             ; Isolate opcode nybble
00000080  BC3C 0006                 49              CMP.B   #$06,D6             ; If it matches ADDI's left-most middle nybble, branch
00000084  6700 0006                 50              BEQ     ADDI8               ; First 8 left-most bits of ADDI confirmed 
00000088  6000 0C9A                 51              BRA     UNKNOWN             ; else unknown                       
0000008C                            52  
0000008C                            53  ;  Here we assume the first left-most 8 bits have been confirmed: 0000 0110            
0000008C                            54  ADDI8                                  ; Two consecutive tests for illegal Src EA Modes
0000008C  2C05                      55              MOVE.L  D5,D6              ; Push D5 into D6 
0000008E  0286 0000003F             56              ANDI.L  #$003F,D6          ; Isolate the Src EA bits
00000094  BCBC 0000003C             57              CMP.L   #$003C,D6          ; Compare with illegal EA mode #<data>
0000009A  6700 0C88                 58              BEQ     UNKNOWN
0000009E                            59              
0000009E  E69E                      60              ROR.L   #3,D6              ; Roll 3 bits right
000000A0  0286 00000007             61              ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
000000A6  BCBC 00000001             62              CMP.L   #$0001, D6         ; Compare with illegal mode An
000000AC  6700 0C76                 63              BEQ     UNKNOWN
000000B0                            64              *--------------
000000B0                            65                                  
000000B0  2C05                      66              MOVE.L  D5,D6              ; Push D5 into D6 
000000B2  EC8E                      67              LSR.L   #6,D6              ; Shift six bits to the right
000000B4  0286 00000003             68              ANDI.L  #$0003,D6          ; Isolate the size bits
000000BA                            69                         
000000BA  BCBC 00000000             70              CMP.L   #$0000,D6          ; See if the size is '00'..
000000C0  6700 001A                 71              BEQ     ADDIB              ; ..If so, it's ANDI.B
000000C4  BCBC 00000001             72              CMP.L   #$0001,D6          ; See if the size is '01'..
000000CA  6700 0054                 73              BEQ     ADDIW              ; ..If so, it's ANDI.W
000000CE  BCBC 00000002             74              CMP.L   #$0002,D6          ; See if the size is '10'..
000000D4  6700 008A                 75              BEQ     ADDIL              ; ..If so, it's ANDI.L
000000D8                            76              
000000D8  6000 0C4A                 77              BRA     UNKNOWN            ; If it isn't any, then it's Unknown
000000DC                            78  
000000DC  22FC 41444449             79  ADDIB       MOVE.L  #'ADDI',(A1)+
000000E2  32FC 2E42                 80              MOVE.W  #'.B',(A1)+
000000E6  22FC 20202020             81              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
000000EC  5041                      82              ADDQ    #8,D1              ; We added 10 bytes, aka 4 spaces 6 characters
000000EE  5441                      83              ADDQ    #2,D1
000000F0                            84              
000000F0  32FC 2324                 85              MOVE.W  #'#$',(A1)+
000000F4  5441                      86              ADDQ    #2,D1
000000F6                            87              
000000F6  4246                      88              CLR     D6
000000F8  4244                      89              CLR     D4
000000FA  3C1A                      90              MOVE.W  (A2)+,D6
000000FC  0246 000F                 91              ANDI.W  #$0F,D6
Line 92 ERROR: Undefined symbol
00000100  4EB9 004DBB8E             92              JSR     EAHEXtoASCII
00000106                            93                          
00000106  12FC 002C                 94              MOVE.B #',',(A1)+      ; Add a spacer into our IOStringLoc
0000010A  5241                      95              ADDQ    #1,D1              ; We added 4 bytes, aka 4 spaces
0000010C                            96              
0000010C  2C05                      97              MOVE.L  D5,D6              ; Push D5 into D6
0000010E  0286 0000003F             98              ANDI.L  #$003F,D6          ; Isolate the Dst EA bits 
00000114  103C 0001                 99              MOVE.B  #1,D0              ; Push 3 into D0 to indicate bytesize
Line 100 ERROR: Undefined symbol
00000118  4EB9 004DBB8E            100              JSR EAGETSRCEA             ; Find and print the code stored in D6 
0000011E                           101              
0000011E  4E75                     102              RTS
00000120                           103              
00000120  22FC 41444449            104  ADDIW       MOVE.L  #'ADDI',(A1)+
00000126  32FC 2E57                105              MOVE.W  #'.W',(A1)+
0000012A  22FC 20202020            106              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
00000130  5041                     107              ADDQ    #8,D1              ; We added 10 bytes, aka 4 spaces 6 characters
00000132  5441                     108              ADDQ    #2,D1
00000134                           109              
00000134  32FC 2324                110              MOVE.W  #'#$',(A1)+
00000138  5441                     111              ADDQ    #2,D1
0000013A                           112              
0000013A  4246                     113              CLR     D6
0000013C  4244                     114              CLR     D4
0000013E  3C1A                     115              MOVE.W  (A2)+,D6
Line 116 ERROR: Undefined symbol
00000140  4EB9 004DBB8E            116              JSR     EAHEXtoASCII
00000146                           117                          
00000146  12FC 002C                118              MOVE.B  #',',(A1)+      ; Add a spacer into our IOStringLoc
0000014A  5241                     119              ADDQ    #1,D1              ; We added 4 bytes, aka 4 spaces
0000014C                           120              
0000014C  2C05                     121              MOVE.L  D5,D6              ; Push D5 into D6
0000014E  0286 0000003F            122              ANDI.L  #$003F,D6          ; Isolate the Dst EA bits 
00000154  103C 0002                123              MOVE.B  #2,D0              ; Push 3 into D0 to indicate wordsize
Line 124 ERROR: Undefined symbol
00000158  4EB9 004DBB8E            124              JSR EAGETSRCEA             ; Find and print the code stored in D6 
0000015E                           125              
0000015E  4E75                     126              RTS
00000160                           127              
00000160  22FC 41444449            128  ADDIL       MOVE.L  #'ADDI',(A1)+
00000166  32FC 2E4C                129              MOVE.W  #'.L',(A1)+
0000016A  22FC 20202020            130              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
00000170  5041                     131              ADDQ    #8,D1              ; We added 10 bytes, aka 4 spaces 6 characters
00000172  5441                     132              ADDQ    #2,D1
00000174                           133              
00000174  32FC 2324                134              MOVE.W  #'#$',(A1)+
00000178  5441                     135              ADDQ    #2,D1
0000017A                           136              
0000017A  4246                     137              CLR     D6
0000017C  4244                     138              CLR     D4
0000017E  2C1A                     139              MOVE.L  (A2)+,D6
00000180  4846                     140              SWAP    D6
Line 141 ERROR: Undefined symbol
00000182  4EB9 004DBB8E            141              JSR     EAHEXtoASCII
00000188  4244                     142              CLR     D4
0000018A  4246                     143              CLR     D6
0000018C  4846                     144              SWAP    D6
Line 145 ERROR: Undefined symbol
0000018E  4EB9 004DBB8E            145              JSR     EAHEXtoASCII
00000194                           146                          
00000194  12FC 002C                147              MOVE.B  #',',(A1)+      ; Add a spacer into our IOStringLoc
00000198  5241                     148              ADDQ    #1,D1              ; We added 4 bytes, aka 4 spaces
0000019A                           149              
0000019A  2C05                     150              MOVE.L  D5,D6              ; Push D5 into D6
0000019C  0286 0000003F            151              ANDI.L  #$003F,D6          ; Isolate the Dst EA bits 
000001A2  103C 0003                152              MOVE.B  #3,D0              ; Push 3 into D0 to indicate longsize
Line 153 ERROR: Undefined symbol
000001A6  4EB9 004DBB8E            153              JSR EAGETSRCEA             ; Find and print the code stored in D6 
000001AC                           154              
000001AC  4E75                     155              RTS
000001AE                           156                
000001AE                           157  ;  Here we assume the first left-most 4 bits are: 0001, 0011, or 0010
000001AE                           158  MOVE                                   ; Two consecutive tests for illegal Dst EA Modes
000001AE  2C05                     159              MOVE.L  D5,D6              ; Push D5 into D6
000001B0  EC9E                     160              ROR.L   #6,D6              ; Roll 6 bits right 
000001B2  0286 0000003F            161              ANDI.L  #$003F,D6          ; Isolate the Dst EA bits
000001B8  BCBC 00000027            162              CMP.L   #$0027, D6         ; Compare with illegal EA mode #<data>
000001BE  6700 0B64                163              BEQ     UNKNOWN
000001C2                           164              
000001C2  0286 00000007            165              ANDI.L  #$0007,D6          ; Isolate the 3 Dst (Mode) bits
000001C8  BCBC 00000001            166              CMP.L   #$0001, D6         ; Compare with illegal mode An
000001CE  6700 0B54                167              BEQ     UNKNOWN
000001D2                           168              *----------------                   
000001D2  2C05                     169              MOVE.L  D5,D6              ; Push D5 into D6 
000001D4  EC8E                     170              LSR.L   #6,D6              ; Shift six bits to the right
000001D6  EC8E                     171              LSR.L   #6,D6              ; Shift six bits to the right
000001D8  0286 00000003            172              ANDI.L  #$0003,D6          ; Isolate the size bits
000001DE                           173                         
000001DE  BCBC 00000001            174              CMP.L   #$0001,D6          ; See if the size is '01'..
000001E4  6700 001A                175              BEQ     MOVEB              ; ..If so, it's MOVE.B
000001E8  BCBC 00000003            176              CMP.L   #$0003,D6          ; See if the size is '11'..
000001EE  6700 0022                177              BEQ     MOVEW              ; ..If so, it's MOVE.W
000001F2  BCBC 00000002            178              CMP.L   #$0002,D6          ; See if the size is '10'..
000001F8  6700 002A                179              BEQ     MOVEL              ; ..If so, it's MOVE.L
000001FC                           180              
000001FC  6000 0B26                181              BRA     UNKNOWN            ; If it isn't any, then it's Unknown
00000200                           182              
00000200                           183  
00000200                           184  
00000200  22FC 4D4F5645            185  MOVEB       MOVE.L  #'MOVE',(A1)+
00000206  32FC 2E42                186              MOVE.W  #'.B',(A1)+
0000020A  5C41                     187              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
0000020C                           188              
0000020C  7001                     189              MOVE.L  #1,D0               ; Put 1 into D0 to indicate it's a bytesize
0000020E                           190              
0000020E  6000 0026                191              BRA MOVEOP
00000212                           192              
00000212  22FC 4D4F5645            193  MOVEW       MOVE.L  #'MOVE',(A1)+
00000218  32FC 2E57                194              MOVE.W  #'.W',(A1)+
0000021C  5C41                     195              ADDQ    #6,D1               ; We added 6 new characters to our IOStringLoc 
0000021E                           196              
0000021E  7002                     197              MOVE.L  #2,D0               ; Put 2 into D0 to indicate it's a wordsize
00000220                           198              
00000220  6000 0014                199              BRA MOVEOP
00000224                           200              
00000224  22FC 4D4F5645            201  MOVEL       MOVE.L  #'MOVE',(A1)+
0000022A  32FC 2E4C                202              MOVE.W  #'.L',(A1)+
0000022E  5C41                     203              ADDQ    #6,D1               ; We added 6 new characters to our IOStringLoc 
00000230                           204              
00000230  7003                     205              MOVE.L  #3,D0               ; Put 3 into D0 to indicate it's a longsize
00000232                           206              
00000232  6000 0002                207              BRA MOVEOP
00000236                           208              
00000236  22FC 20202020            209  MOVEOP      MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
0000023C  5841                     210              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
0000023E                           211              
0000023E  2C05                     212              MOVE.L  D5,D6               ; Push D5 into D6
00000240  0286 0000003F            213              ANDI.L  #$003F,D6           ; Isolate the Src EA bits 
Line 214 ERROR: Undefined symbol
00000246  4EB9 004DBB8E            214              JSR EAGETSRCEA              ; Find and print the code stored in D6
0000024C                           215              
0000024C  12FC 002C                216              MOVE.B  #',',(A1)+
00000250  5241                     217              ADDQ    #1,D1
00000252                           218              
00000252  2C05                     219              MOVE.L  D5,D6               ; Push D5 into D6
00000254  EC8E                     220              LSR.L   #6,D6               ; Shift six bits to the right
00000256  0286 0000003F            221              ANDI.L  #$003F,D6           ; Isolate the Dst EA bits
Line 222 ERROR: Undefined symbol
0000025C  4EB9 004DBB8E            222              JSR EAGETDSTEA
00000262  4E75                     223              RTS
00000264                           224              
00000264                           225  ; This label determines if the code is either CLR or NOP or RTS or JSR or MOVEM or LEA
00000264                           226  ; Here we assume that the first left-most four bits equal 0100            
00000264                           227  CNRJML      
00000264  2C05                     228              MOVE.L  D5,D6              ; Push D5 into D6 (Copy OPcode over isolated nybble)
00000266                           229              
00000266                           230              *NOP & RTS's machine code is uniquely hardcoded, check first
00000266  BCBC 00004E71            231              CMP.L   #$4E71,D6          ; See if the OPcode matches NOP's hardcode
0000026C  6700 010A                232              BEQ     NOP
00000270  BCBC 00004E75            233              CMP.L   #$4E75,D6          ; See if the OPcode matches RTS's hardcode
00000276  6700 011A                234              BEQ     RTS
0000027A                           235                                         ; CLR's middle most left nybble is unique (0010)
0000027A  E09E                     236              ROR.L   #8,D6              ; Rotate our OpCode to right-most nybble
0000027C  0206 000F                237              ANDI.B  #$0F,D6            ; Isolate our opcode nybble
00000280  BC3C 0002                238              CMP.B   #$02,D6            ; See if matches nybble
00000284  6700 0042                239              BEQ     CLR               
00000288                           240              
00000288                           241  *--------------------------------------------------------------------------------------            
00000288                           242                                         ; LEA's left-most 10 bits are 0100 --- (111)
00000288  2C05                     243              MOVE.L  D5,D6              ; Push D5 into D6
0000028A  EC8E                     244              LSR.L   #6,D6              ; Shift 6 bits to the right 
0000028C  0286 00000007            245              ANDI.L  #$0007,D6          ; Isolate 3 right-most bits
00000292  BCBC 00000007            246              CMP.L   #$0007,D6          ; See if matches 111
00000298  6700 023E                247              BEQ     LEA                ; If equals, branch to LEA     
0000029C                           248              
0000029C                           249                                         ; JSR's left-most 10 bits are 0100 (111 010)
0000029C  2C05                     250              MOVE.L  D5,D6              ; Push D5 into D6
0000029E  EC8E                     251              LSR.L   #6,D6              ; Shift 6 bits to the right
000002A0  0286 0000003F            252              ANDI.L  #$003F,D6          ; Isolate 6 right-most bit
000002A6  BCBC 0000003A            253              CMP.L   #$003A,D6          ; See if matches 11 1010
000002AC  6700 00FE                254              BEQ     JSR                ; If equals, branch JSR
000002B0                           255                 
000002B0                           256                                         ; MOVEM's left-most 9 bits are 0100 1- (001)
000002B0  2C05                     257              MOVE.L  D5,D6              ; Push D5 into D6
000002B2  EE8E                     258              LSR.L   #7,D6              ; Shift 7 bits to the right
000002B4  0286 00000007            259              ANDI.L  #$0007,D6          ; Isolate 3 right-most bit
000002BA  BCBC 00000001            260              CMP.L   #$0001,D6          ; See if matches 001
000002C0  6700 0156                261              BEQ     MOVEM              ; If equals, branch MOVEM
000002C4                           262        
000002C4  6000 0A5E                263              BRA     UNKNOWN            ; If it doesnt any match, then it's Unknown
000002C8                           264  
000002C8                           265  ******************************************************************************************
000002C8                           266  *            MOVE.L  D5,D6              ; Push D5 into D6
000002C8                           267  *            LSR.L   #8,D6              ; Shift 8 bits to the right
000002C8                           268  *            
000002C8                           269  *            BTST    #$00,D6            ; See if our right-most bit is set
000002C8                           270  *            BNE     LEA                ; If our bit is set, branch to LEA     
000002C8                           271  *            
000002C8                           272  *            LSR.L   #1,D6              ; Shift another bit
000002C8                           273  *            BTST    #$00,D6            ; See if our right-most bit is set
000002C8                           274  *            BNE     JSR                ; If this one is set, branch to JSR
000002C8                           275  *            
000002C8                           276  **            BRA MOVEM
000002C8                           277  **                                       ; LEA's middle most left nybble is unique (---1)
000002C8                           278  **            BTST    #0,D6              ; Check the right most bit's value
000002C8                           279  **            BNE     LEA                ; If equals 1, branch
000002C8                           280  *               
000002C8                           281  *                                       ; MOVEM's middle most left nybble is unique (1-00)
000002C8                           282  *            ROR.L   #2,D6              ; first bit must be 0, rotate 1 bit 
000002C8                           283  *            BTST    #0,D6               ; Compare again for 00 match
000002C8                           284  *            BNE     MOVEM                           
000002C8                           285  *                                       
000002C8                           286  **            MOVE.L  D5,D6              ; Push D5 into D6; JSR's middle nybbles are unique (1110 10--)
000002C8                           287  **            ROR.L   #6,D6              ; Rotate 6 bits
000002C8                           288  **            ANDI.L  #$00FF,D6          ; Isolate the 8 known bits (00 1110 10)
000002C8                           289  **            CMP.L   #$003A,D6          ; Compare
000002C8                           290  **            BEQ     JSR                ; Branch
000002C8                           291  **            
000002C8                           292  *            BRA     UNKNOWN            ; If it doesnt any match, then it's Unknown
000002C8                           293  *-----------------------------------------------------------------------------------------
000002C8                           294  
000002C8                           295  ;  Here we assume the first left-most 8 bits have been confirmed: 0100 0010
000002C8                           296  CLR                                    ; Two consecutive tests for illegal Src EA Modes
000002C8  2C05                     297              MOVE.L  D5,D6              ; Push D5 into D6 
000002CA  0286 0000003F            298              ANDI.L  #$003F,D6          ; Isolate the Src EA bits
000002D0  BCBC 0000003C            299              CMP.L   #$003C, D6         ; Compare with illegal EA mode #<data>
000002D6  6700 0A4C                300              BEQ     UNKNOWN
000002DA                           301              
000002DA  E69E                     302              ROR.L   #3,D6              ; Roll 3 bits right
000002DC  0286 00000007            303              ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
000002E2  BCBC 00000001            304              CMP.L   #$0001,D6          ; Compare with illegal mode An
000002E8  6700 0A3A                305              BEQ     UNKNOWN
000002EC                           306              *----------------
000002EC                           307              
000002EC  2C05                     308              MOVE.L  D5,D6              ; Push D5 into D6
000002EE  EC8E                     309              LSR.L   #6,D6              ; Shift six bits to the right
000002F0  0286 00000003            310              ANDI.L  #$0003,D6          ; Isolate the two size bits
000002F6                           311                         
000002F6  BCBC 00000000            312              CMP.L   #$0000,D6          ; See if the size is '00'..
000002FC  6700 001A                313              BEQ     CLRB               ; ..If so, it's CLR.B
00000300  BCBC 00000001            314              CMP.L   #$0001,D6          ; See if the size is '01'..
00000306  6700 0026                315              BEQ     CLRW               ; ..If so, it's CLR.W
0000030A  BCBC 00000002            316              CMP.L   #$0002,D6          ; See if the size is '10'..
00000310  6700 0032                317              BEQ     CLRL               ; ..If so, it's CLR.L
00000314                           318              
00000314  6000 0A0E                319              BRA     UNKNOWN            ; If it isn't any, then it's Unknown
00000318                           320              
00000318  32FC 434C                321  CLRB        MOVE.W  #'CL',(A1)+
0000031C  12FC 0052                322              MOVE.B  #'R',(A1)+
00000320  12FC 002E                323              MOVE.B  #'.',(A1)+
00000324  12FC 0042                324              MOVE.B  #'B',(A1)+
00000328  5A41                     325              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
0000032A  6000 002E                326              BRA     CLROP
0000032E                           327              
0000032E  32FC 434C                328  CLRW        MOVE.W  #'CL',(A1)+
00000332  12FC 0052                329              MOVE.B  #'R',(A1)+
00000336  12FC 002E                330              MOVE.B  #'.',(A1)+
0000033A  12FC 0057                331              MOVE.B  #'W',(A1)+
0000033E  5A41                     332              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
00000340  6000 0018                333              BRA     CLROP
00000344                           334  
00000344  32FC 434C                335  CLRL        MOVE.W  #'CL',(A1)+
00000348  12FC 0052                336              MOVE.B  #'R',(A1)+
0000034C  12FC 002E                337              MOVE.B  #'.',(A1)+
00000350  12FC 004C                338              MOVE.B  #'L',(A1)+
00000354  5A41                     339              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
00000356  6000 0002                340              BRA     CLROP
0000035A                           341              
0000035A  12FC 0020                342  CLROP       MOVE.B  #' ',(A1)+
0000035E  32FC 2020                343              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
00000362  32FC 2020                344              MOVE.W  #'  ',(A1)+
00000366  5A41                     345              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces
00000368                           346              
00000368  2C05                     347              MOVE.L  D5,D6              ; Push D5 into D6
0000036A  0286 0000003F            348              ANDI.L  #$003F,D6          ; Isolate the Src EA bits 
Line 349 ERROR: Undefined symbol
00000370  4EB9 004DBB8E            349              JSR EAGETSRCEA             ; Find and print the code stored in D6
00000376                           350  
00000376  4E75                     351              RTS
00000378                           352              
00000378                           353  ;  Here we assume that all 16 bits have been confirmed 
00000378                           354  NOP
00000378  32FC 4E4F                355              MOVE.W  #'NO',(A1)+
0000037C  12FC 0050                356              MOVE.B  #'P',(A1)+
00000380  5641                     357              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
00000382                           358              
00000382  12FC 0020                359              MOVE.B  #' ',(A1)+       ; Add a spacer into our IOStringLoc
00000386  32FC 2020                360              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
0000038A  32FC 2020                361              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
0000038E  5A41                     362              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces        
00000390  4E75                     363              RTS
00000392                           364  
00000392                           365  ;  Here we assume that all 16 bits have been confirmed            
00000392                           366  RTS         
00000392  32FC 5254                367              MOVE.W  #'RT',(A1)+
00000396  12FC 0053                368              MOVE.B  #'S',(A1)+
0000039A  5641                     369              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
0000039C                           370              
0000039C  12FC 0020                371              MOVE.B  #' ',(A1)+       ; Add a spacer into our IOStringLoc
000003A0  32FC 2020                372              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
000003A4  32FC 2020                373              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
000003A8  5A41                     374              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces        
000003AA  4E75                     375              RTS
000003AC                           376              
000003AC                           377  
000003AC                           378  ;  Here we assume the first left-most 10 bits have been confirmed: 0100 1110 10 
000003AC                           379  JSR                                    ; Five consecutive tests for illegal Src EA Modes
000003AC  2C05                     380              MOVE.L  D5,D6              ; Push D5 into D6 
000003AE  0286 0000003F            381              ANDI.L  #$003F,D6          ; Isolate the Src EA bits
000003B4  BCBC 0000003C            382              CMP.L   #$003C, D6         ; Compare with illegal EA mode #<data>
000003BA  6700 0968                383              BEQ     UNKNOWN
000003BE                           384              
000003BE  E69E                     385              ROR.L   #3,D6              ; Roll 3 bits right
000003C0  0286 00000007            386              ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
000003C6  BCBC 00000000            387              CMP.L   #$0000,D6          ; Compare with illegal mode Dn
000003CC  6700 0956                388              BEQ     UNKNOWN
000003D0  BCBC 00000001            389              CMP.L   #$0001,D6          ; Compare with illegal mode An
000003D6  6700 094C                390              BEQ     UNKNOWN
000003DA  BCBC 00000003            391              CMP.L   #$0003,D6          ; Compare with illegal mode (An)+
000003E0  6700 0942                392              BEQ     UNKNOWN
000003E4  BCBC 00000004            393              CMP.L   #$0004,D6          ; Compare with illegal mode -(An)
000003EA  6700 0938                394              BEQ     UNKNOWN
000003EE                           395              *----------------
000003EE                           396  
000003EE  32FC 4A53                397              MOVE.W  #'JS',(A1)+
000003F2  12FC 0052                398              MOVE.B  #'R',(A1)+
000003F6  5641                     399              ADDQ    #3,D1              ; We added 3 new characters to our IOStringLoc 
000003F8                           400              
000003F8  12FC 0020                401              MOVE.B  #' ',(A1)+
000003FC  32FC 2020                402              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
00000400  22FC 20202020            403              MOVE.L  #'    ',(A1)+      ; Add a spacer into our IOStringLoc
00000406  5E41                     404              ADDQ    #7,D1              ; We added 4 bytes, aka 4 spaces
00000408  2C05                     405              MOVE.L  D5,D6              ; Push D5 into D6
0000040A                           406              
0000040A  0286 0000003F            407              ANDI.L  #$003F,D6          ; Isolate the Src EA bits 
Line 408 ERROR: Undefined symbol
00000410  4EB9 004DBB8E            408              JSR EAGETSRCEA             ; Find and print the code stored in D6 
00000416  4E75                     409              RTS
00000418                           410              
00000418                           411  
00000418                           412  ;  Here we assume that these left-most bits have been confirmed, where - have not been confirmed: 0100 -- 001
00000418                           413  MOVEM                                  ; Four consecutive tests for illegal Src EA Modes
00000418  2C05                     414              MOVE.L  D5,D6              ; Push D5 into D6 
0000041A  0286 0000003F            415              ANDI.L  #$003F,D6          ; Isolate the Src EA bits
00000420  BCBC 0000003C            416              CMP.L   #$003C, D6         ; Compare with illegal EA mode #<data>
00000426  6700 08FC                417              BEQ     UNKNOWN
0000042A                           418              
0000042A  E69E                     419              ROR.L   #3,D6              ; Roll 3 bits right
0000042C  0286 00000007            420              ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
00000432  BCBC 00000000            421              CMP.L   #$0000,D6          ; Compare with illegal mode Dn
00000438  6700 08EA                422              BEQ     UNKNOWN
0000043C  BCBC 00000001            423              CMP.L   #$0001,D6          ; Compare with illegal mode An
00000442  6700 08E0                424              BEQ     UNKNOWN
00000446                           425              
00000446  2C05                     426              MOVE.L  D5,D6              ; Copy D5 into D6
00000448  0246 0438                427              ANDI.W  #$0438,D6          ; Isolate our direction and EA mode bits
0000044C  BC7C 0018                428              CMP.W   #$0018,D6          ; If it equals $0018..
00000450  6700 08D2                429              BEQ     UNKNOWN            ; Dr 0, (An)+ case..
00000454  BC7C 0420                430              CMP.W   #$0420,D6          ; If it equals $0420..
00000458  6700 08CA                431              BEQ     UNKNOWN            ; Dr 1, -(An) case..
0000045C                           432              *----------------
0000045C                           433  
0000045C  22FC 4D4F5645            434              MOVE.L  #'MOVE',(A1)+
00000462  32FC 4D2E                435              MOVE.W  #'M.',(A1)+
00000466  5C41                     436              ADDQ    #6,D1              ; We added 6 new characters to our IOStringLoc 
00000468                           437              
00000468  2C05                     438              MOVE.L  D5,D6              ; Copy our OpCode
0000046A  EC8E                     439              LSR.L   #6,D6              ; Shift it 6 bits to the right
0000046C  0806 0000                440              BTST    #$00,D6            ; If our size bit is 0..
00000470  6700 0006                441              BEQ     MOVEMW             ; .. Its a MOVEM of size W
00000474  6000 000C                442              BRA     MOVEML             ; .. Otherwise it's of size L
00000478                           443  
00000478  12FC 0057                444  MOVEMW      MOVE.B  #'W',(A1)+
0000047C  5241                     445              ADDQ    #1,D1              ; We've added another character into IOStringLoc
0000047E  6000 0008                446              BRA     MOVEMOP            ; MovemOp label, to skip MovemL label
00000482                           447              
00000482  12FC 004C                448  MOVEML      MOVE.B  #'L',(A1)+
00000486  5241                     449              ADDQ    #1,D1              ; We've added another character into IOStringLoc
00000488                           450              
00000488  12FC 0020                451  MOVEMOP     MOVE.B  #' ',(A1)+         ; Add a spacer into our IOStringLoc
0000048C  32FC 2020                452              MOVE.W  #'  ',(A1)+        ;
00000490  5641                     453              ADDQ    #3,D1              ; We added 4 bytes, aka 4 spaces 
00000492                           454              
00000492  E88E                     455              LSR.L   #4,D6              ; Shift our OpCode 4 bits to the left of Size (going to the right)
00000494  0806 0000                456              BTST    #$00,D6            ; Check our Direction bit
00000498  6700 0006                457              BEQ     MOVEMPRED          ; If it's 0, our direction is Pre Decrement (eg. Move TO the stack)
0000049C  6000 001E                458              BRA     MOVEMPOSTI         ; Otherwise, it's Post Increment (eg. Move FROM the stack)
000004A0                           459              
000004A0                           460  MOVEMPRED   ; This part is where we get the gross A0-A6/D0-D7 part
Line 461 ERROR: Undefined symbol
000004A0  4EB9 004DBB8E            461              JSR     EAMOVEMPRED  
000004A6                           462              
000004A6  12FC 002C                463              MOVE.B  #',',(A1)+
000004AA  5241                     464              ADDQ    #1,D1
000004AC                           465              
000004AC  2C05                     466              MOVE.L  D5,D6              ; Copy our OpCode to D6
000004AE  0286 0000003F            467              ANDI.L  #$3F,D6            ; Isolate our EA src bits
000004B4                           468              
Line 469 ERROR: Undefined symbol
000004B4  4EB9 004DBB8E            469              JSR EAGETSRCEA  
000004BA                           470            
000004BA  4E75                     471              RTS
000004BC                           472  
000004BC  2C05                     473  MOVEMPOSTI  MOVE.L  D5,D6              ; Copy our OpCode to D6
000004BE  0286 0000003F            474              ANDI.L  #$3F,D6            ; Isolate our EA src bits
000004C4                           475              
Line 476 ERROR: Undefined symbol
000004C4  4EB9 004DBB8E            476              JSR EAGETSRCEA  
000004CA                           477              
000004CA  12FC 002C                478              MOVE.B  #',',(A1)+
000004CE  5241                     479              ADDQ    #1,D1
000004D0                           480              
000004D0                           481              ; This part is where we get the gross A0-A6/D0-D7 part
Line 482 ERROR: Undefined symbol
000004D0  4EB9 004DBB8E            482              JSR     EAMOVEMPOSTI
000004D6                           483              
000004D6  4E75                     484              RTS
000004D8                           485              
000004D8                           486  
000004D8                           487  ;  Here we assume that these left-most bits have been confirmed, where - have not been confirmed: 0100 --- 111            
000004D8                           488  LEA                                    ; Five consecutive tests for illegal Src EA Modes
000004D8  2C05                     489              MOVE.L  D5,D6              ; Push D5 into D6 
000004DA  0286 0000003F            490              ANDI.L  #$003F,D6          ; Isolate the Src EA bits
000004E0  BCBC 0000003C            491              CMP.L   #$003C, D6         ; Compare with illegal EA mode #<data>
000004E6  6700 083C                492              BEQ     UNKNOWN
000004EA                           493              
000004EA  E69E                     494              ROR.L   #3,D6              ; Roll 3 bits right
000004EC  0286 00000007            495              ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
000004F2  BCBC 00000000            496              CMP.L   #$0000,D6          ; Compare with illegal mode Dn
000004F8  6700 082A                497              BEQ     UNKNOWN
000004FC  BCBC 00000001            498              CMP.L   #$0001,D6          ; Compare with illegal mode An
00000502  6700 0820                499              BEQ     UNKNOWN
00000506  BCBC 00000003            500              CMP.L   #$0003,D6          ; Compare with illegal mode (An)+
0000050C  6700 0816                501              BEQ     UNKNOWN
00000510  BCBC 00000004            502              CMP.L   #$0004,D6          ; Compare with illegal mode -(An)
00000516  6700 080C                503              BEQ     UNKNOWN
0000051A                           504              *----------------
0000051A                           505              
0000051A  32FC 4C45                506              MOVE.W  #'LE',(A1)+
0000051E  12FC 0041                507              MOVE.B  #'A',(A1)+
00000522  5641                     508              ADDQ    #3,D1               ; We added 3 new characters to our IOStringLoc 
00000524                           509               
00000524  12FC 0020                510              MOVE.B  #' ',(A1)+          ; Added an extra space here, due to only 3 character OpCode
00000528  22FC 20202020            511              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
0000052E  32FC 2020                512              MOVE.W  #'  ',(A1)+ 
00000532  5E41                     513              ADDQ    #7,D1               ; We added 4 bytes, aka 4 spaces
00000534                           514              
00000534  2C05                     515              MOVE.L  D5,D6               ; Copy D5 into D6
00000536  0286 0000003F            516              ANDI.L  #$003F,D6           ; Isolate the Src EA bits
Line 517 ERROR: Undefined symbol
0000053C  4EB9 004DBB8E            517              JSR EAGETSRCEA
00000542                           518              
00000542  12FC 002C                519              MOVE.B  #',',(A1)+
00000546  5241                     520              ADDQ    #1,D1
00000548                           521              
00000548  2C05                     522              MOVE.L  D5,D6               ; Copy D5 into D6
0000054A  E09E                     523              ROR.L   #8,D6               ; Rotate 9 bits to the right (An Dst bits)
0000054C  E29E                     524              ROR.L   #1,D6               ; 
0000054E  0286 00000005            525              ANDI.L  #$0005,D6           ; Isolate the An Destination bits
Line 526 ERROR: Undefined symbol
00000554  4EF9 004DBB8E            526              JMP EAAN
0000055A  4E75                     527              RTS      
0000055C                           528              
0000055C  2C05                     529  Bcc         MOVE.L  D5,D6               ; Copy our OpCode into D6
0000055E  E15E                     530              ROL.W   #8,D6               ; Rotate our condition bit into place
00000560  0206 000F                531              ANDI.B  #$0F,D6             ; Isolate the right-most nybble (condition)
00000564                           532              
00000564  BC3C 0004                533              CMP.B   #%0100,D6           ; See if our Condition is '0100'
00000568  6700 0016                534              BEQ     BCCOP               ; If it is, we have a BCC operation
0000056C  BC3C 000E                535              CMP.B   #%1110,D6           ; See if our Condition is '1110'
00000570  6700 001C                536              BEQ     BGTOP               ; If it is, we have a BGT operation
00000574  BC3C 000F                537              CMP.B   #%1111,D6           ; See if our Condition is '1111'
00000578  6700 0022                538              BEQ     BLEOP               ; If it is, we have a BLE operation
0000057C                           539              
0000057C  6000 07A6                540              BRA     UNKNOWN             ; Otherwise we don't know what kind of operation we have
00000580                           541              
00000580  32FC 4243                542  BCCOP       MOVE.W  #'BC',(A1)+
00000584  12FC 0043                543              MOVE.B  #'C',(A1)+
00000588  5641                     544              ADDQ    #3,D1               ; We've added three characters into our IOStringLoc
0000058A  6000 001E                545              BRA     BccSIZE             ; Branch to find our Bcc Op's Size
0000058E                           546              
0000058E  32FC 4247                547  BGTOP       MOVE.W  #'BG',(A1)+
00000592  12FC 0054                548              MOVE.B  #'T',(A1)+
00000596  5641                     549              ADDQ    #3,D1               ; We've added three characters into our IOStringLoc
00000598  6000 0010                550              BRA     BccSIZE             ; Branch to find our Bcc Op's Size
0000059C                           551              
0000059C  32FC 424C                552  BLEOP       MOVE.W  #'BL',(A1)+
000005A0  12FC 0045                553              MOVE.B  #'E',(A1)+
000005A4  5641                     554              ADDQ    #3,D1               ; We've added three characters into our IOStringLoc
000005A6  6000 0002                555              BRA     BccSIZE             ; Branch to find our Bcc Op's Size
000005AA                           556  
000005AA                           557  BccSIZE     ; Find Displacement value
000005AA                           558              ; Branch to proper displacement value label
000005AA                           559              ; Store the value of A2 into D7
000005AA                           560              ; Get our total displacement into D6
000005AA                           561              ; Print the new address as D7 +/- D6
000005AA                           562              
000005AA  12FC 0020                563              MOVE.B  #' ',(A1)+       ; Add a spacer into our IOStringLoc
000005AE  32FC 2020                564              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
000005B2  32FC 2020                565              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
000005B6  32FC 2020                566              MOVE.W  #'  ',(A1)+       ; Add a spacer into our IOStringLoc
000005BA  5E41                     567              ADDQ    #7,D1              ; We added 4 bytes, aka 4 spaces   
000005BC                           568              
000005BC  12FC 0024                569              MOVE.B  #'$',(A1)+
000005C0  5241                     570              ADDQ    #1,D1
000005C2                           571              
000005C2  2C05                     572              MOVE.L  D5,D6
000005C4  0286 000000FF            573              ANDI.L  #$FF,D6             ; Isolate our Size bits
000005CA  BC3C 0000                574              CMP.B   #$00,D6             ; If it's equal to $00..
000005CE  6700 0032                575              BEQ     Bcc16               ; .. It has a 16 bit displacement
000005D2  0286 000000FF            576              ANDI.L  #$FF,D6             ; If it's equal to $FF..
000005D8  6700 0050                577              BEQ     Bcc32               ; .. It has a 32 bit displacement
000005DC                           578              ; Otherwise, it's an 8 bit displacement
000005DC                           579              
000005DC  2E0A                     580              MOVE.L  A2,D7               ; Get our initial address
000005DE  4A06                     581              TST.B   D6                  ; Is D6 negative?
000005E0  6B00 0010                582              BMI     Bcc8NEG             ; Branch to Negative
000005E4                           583              
000005E4  DE46                     584              ADD.W   D6,D7               ; Otherwise, Add what we have to D7
000005E6                           585              
000005E6  2C07                     586              MOVE.L  D7,D6               ; Push our expected address into D6 to print
000005E8  4244                     587              CLR     D4                  ; Clear counter
Line 588 ERROR: Undefined symbol
000005EA  4EB9 004DBB8E            588              JSR     EAHEXtoASCII        ; Print
000005F0                           589              
000005F0  4E75                     590              RTS 
000005F2                           591              
000005F2  4406                     592  Bcc8NEG     NEG.B   D6 
000005F4  9E46                     593              SUB.W   D6,D7
000005F6                           594              
000005F6  2C07                     595              MOVE.L  D7,D6               ; Push our expected address into D6 to print
000005F8  4244                     596              CLR     D4                  ; Clear counter
Line 597 ERROR: Undefined symbol
000005FA  4EB9 004DBB8E            597              JSR     EAHEXtoASCII        ; Print
00000600                           598              
00000600  4E75                     599              RTS  
00000602                           600           
00000602  2E0A                     601  Bcc16       MOVE.L  A2,D7               ; Get our initial address
00000604  3C1A                     602              MOVE.W  (A2)+,D6
00000606  4A46                     603              TST.W   D6                  ; Is D6 negative?
00000608  6B00 0010                604              BMI     Bcc16NEG             ; Branch to Negative
0000060C                           605              
0000060C  DE86                     606              ADD.L   D6,D7               ; Otherwise, Add what we have to D7
0000060E                           607              
0000060E  2C07                     608              MOVE.L  D7,D6               ; Push our expected address into D6 to print
00000610  4244                     609              CLR     D4                  ; Clear counter
Line 610 ERROR: Undefined symbol
00000612  4EB9 004DBB8E            610              JSR     EAHEXtoASCII        ; Print
00000618                           611              
00000618  4E75                     612              RTS 
0000061A  4446                     613  Bcc16NEG    NEG.W   D6 
0000061C  9E86                     614              SUB.L   D6,D7
0000061E                           615              
0000061E  2C07                     616              MOVE.L  D7,D6               ; Push our expected address into D6 to print
00000620  4244                     617              CLR     D4                  ; Clear counter
Line 618 ERROR: Undefined symbol
00000622  4EB9 004DBB8E            618              JSR     EAHEXtoASCII        ; Print
00000628                           619              
00000628  4E75                     620              RTS  
0000062A                           621  
0000062A                           622  
0000062A  2E0A                     623  Bcc32       MOVE.L  A2,D7               ; Get our initial address
0000062C  2C1A                     624              MOVE.L  (A2)+,D6
0000062E  4A86                     625              TST.L   D6                  ; Is D6 negative?
00000630  6BE8                     626              BMI     Bcc16NEG            ; Branch to Negative
00000632                           627              
00000632  DE86                     628              ADD.L   D6,D7               ; Otherwise, Add what we have to D7
00000634                           629              
00000634  2C07                     630              MOVE.L  D7,D6               ; Push our expected address into D6 to print
00000636  4244                     631              CLR     D4                  ; Clear counter
00000638  4846                     632              SWAP    D6
Line 633 ERROR: Undefined symbol
0000063A  4EB9 004DBB8E            633              JSR     EAHEXtoASCII        ; Print
00000640  4244                     634              CLR     D4                  ; Clear counter
00000642  4846                     635              SWAP    D6
Line 636 ERROR: Undefined symbol
00000644  4EB9 004DBB8E            636              JSR     EAHEXtoASCII        ; Print
0000064A                           637              
0000064A  4E75                     638              RTS 
0000064C                           639  
0000064C  4486                     640  Bcc32NEG    NEG.L   D6 
0000064E  9E86                     641              SUB.L   D6,D7
00000650                           642              
00000650  2C07                     643              MOVE.L  D7,D6               ; Push our expected address into D6 to print
00000652  4244                     644              CLR     D4                  ; Clear counter
00000654  4846                     645              SWAP    D6
Line 646 ERROR: Undefined symbol
00000656  4EB9 004DBB8E            646              JSR     EAHEXtoASCII        ; Print
0000065C  4244                     647              CLR     D4                  ; Clear counter
0000065E  4846                     648              SWAP    D6
Line 649 ERROR: Undefined symbol
00000660  4EB9 004DBB8E            649              JSR     EAHEXtoASCII        ; Print
00000666                           650      
00000666  4E75                     651              RTS           
00000668                           652  MOVEQ
00000668  22FC 4D4F5645            653              MOVE.L  #'MOVE',(A1)+
0000066E  12FC 0051                654              MOVE.B  #'Q',(A1)+
00000672  5A41                     655              ADDQ    #5,D1               ; We added 4 new characters to our IOStringLoc
00000674                           656              
00000674  12FC 0020                657              MOVE.B  #' ',(A1)+
00000678  32FC 2020                658              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
0000067C  32FC 2020                659              MOVE.W  #'  ',(A1)+
00000680  5841                     660              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
00000682                           661              
00000682  2C05                     662              MOVE.L  D5,D6               ; Copy D5 into D6
00000684  0286 000000FF            663              ANDI.L  #$00FF,D6           ; Isolate the Src EA bits
0000068A                           664              
0000068A  12FC 0023                665              MOVE.B  #'#',(A1)+
0000068E  12FC 0024                666              MOVE.B  #'$',(A1)+
00000692  5241                     667              ADDQ    #1,D1               ; We added 4 bytes, aka 4 spaces
00000694  183C 0002                668              MOVE.B  #2,D4               ; "Start" at 2 characters
00000698  E19E                     669              ROL.L   #$8,D6
Line 670 ERROR: Undefined symbol
0000069A  4EB9 004DBB8E            670              JSR     EAHEXtoASCII
000006A0                           671              
000006A0  12FC 002C                672              MOVE.B  #',',(A1)+
000006A4  5241                     673              ADDQ    #1,D1
000006A6                           674              
000006A6  2C05                     675              MOVE.L  D5,D6               ; Copy D5 into D6
000006A8  E09E                     676              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
000006AA  E29E                     677              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
000006AC  0286 00000007            678              ANDI.L  #$0007,D6           ; Isolate the Dn Destination bits
Line 679 ERROR: Undefined symbol
000006B2  4EF9 004DBB8E            679              JMP EADN
000006B8                           680              
000006B8  4E75                     681              RTS 
000006BA                           682              
000006BA                           683  DIVU 
000006BA                           684                                         ; One test for illegal Src EA Mode
000006BA  2C05                     685              MOVE.L  D5,D6              ; Push D5 into D6   
000006BC  E69E                     686              ROR.L   #3,D6              ; Roll 3 bits right
000006BE  0286 00000007            687              ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
000006C4  BCBC 00000001            688              CMP.L   #$0001,D6          ; Compare with illegal mode An
000006CA  6700 0658                689              BEQ     UNKNOWN
000006CE                           690              *----------------       
000006CE  22FC 44495655            691              MOVE.L  #'DIVU',(A1)+
000006D4  5841                     692              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000006D6                           693              
000006D6  22FC 20202020            694              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
000006DC  32FC 2020                695              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
000006E0  5C41                     696              ADDQ    #6,D1               ; We added 4 bytes, aka 4 spaces
000006E2                           697              
000006E2  2C05                     698              MOVE.L  D5,D6               ; Copy D5 into D6
000006E4  0286 0000003F            699              ANDI.L  #$003F,D6           ; Isolate the Src EA bits
000006EA  7002                     700              MOVE.L  #2,D0               ; Put 2 into D0 to indicate it's a wordsize
Line 701 ERROR: Undefined symbol
000006EC  4EB9 004DBB8E            701              JSR EAGETSRCEA
000006F2                           702              
000006F2  12FC 002C                703              MOVE.B  #',',(A1)+
000006F6  5241                     704              ADDQ    #1,D1
000006F8                           705              
000006F8  2C05                     706              MOVE.L  D5,D6               ; Copy D5 into D6
000006FA  E09E                     707              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
000006FC  E29E                     708              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
000006FE  0286 00000007            709              ANDI.L  #$0007,D6           ; Isolate the Dn Destination bits
Line 710 ERROR: Undefined symbol
00000704  4EF9 004DBB8E            710              JMP EADN
0000070A                           711              
0000070A  4E75                     712              RTS
0000070C                           713  
0000070C                           714              
0000070C  2C05                     715  SUB         MOVE.L  D5,D6               ; Copy D5 into D6
0000070E  EC8E                     716              LSR.L   #6,D6               ; Shift the size bits to the far right
00000710  0206 0004                717              ANDI.B  #$4,D6              ; Isolate the size bits    
00000714                           718                   
00000714  BC3C 0004                719              CMP.B   #%0100,D6           ; See if D6 is size "%100" through "%110"..
00000718  6700 0026                720              BEQ     SUBEA              ; If it is, our OpCode is in the format of..
0000071C                           721              
0000071C  2C05                     722              MOVE.L  D5,D6               ; Copy D5 into D6
0000071E  EC8E                     723              LSR.L   #6,D6               ; Shift the size bits to the far right
00000720  0206 0007                724              ANDI.B  #$7,D6              ; Isolate the size bits    
00000724                           725              
00000724  BC3C 0002                726              CMP.B   #%10,D6             ; See if D6 is size "%000" through "%010"..
00000728  6700 0092                727              BEQ     SUBLDN              ; If it is, our OpCode is in the format of..
0000072C  BC3C 0001                728              CMP.B   #%01,D6             ; .. <EA> ~ Dn --> Dn
00000730  6700 009C                729              BEQ     SUBWDN
00000734  BC3C 0000                730              CMP.B   #%00,D6
00000738  6700 00A6                731              BEQ     SUBBDN              ; == 000 at this point
0000073C                           732              
0000073C  6000 05E6                733              BRA     UNKNOWN
00000740                           734              
00000740  2C05                     735  SUBEA       MOVE.L  D5,D6               ; Copy D5 into D6
00000742  CC3C 003F                736              AND.B   #$3F,D6             ; Isolate our EA Src bits
00000746  BC3C 0039                737              CMP.B   #$39,D6             ; Check for Illegal #$ mode
0000074A  6700 05D8                738              BEQ     UNKNOWN
0000074E  CC3C 0038                739              AND.B   #$38,D6             ; Isolate our EA Src Mode bits
00000752  BC3C 0008                740              CMP.B   #$08,D6             ; Check for Illegal mode An
00000756  6700 05CC                741              BEQ     UNKNOWN
0000075A  BC3C 0000                742              CMP.B   #$00,D6             ; Check for Illegal mode Dn 
0000075E  6700 05C4                743              BEQ     UNKNOWN
00000762                           744              
00000762  2C05                     745              MOVE.L  D5,D6               ; Copy D5 into D6
00000764  EC8E                     746              LSR.L   #6,D6               ; Shift the size bits to the far right
00000766  0206 0007                747              ANDI.B  #$7,D6              ; Isolate the size bits    
0000076A                           748                   
0000076A  BC3C 0006                749              CMP.B   #%0110,D6           ; See if D6 is size "%100" through "%110"..
0000076E  6700 0016                750              BEQ     SUBLEA              ; If it is, our OpCode is in the format of..
00000772  BC3C 0005                751              CMP.B   #%101,D6            ; .. Dn ~ <EA> --> <EA>
00000776  6700 0020                752              BEQ     SUBWEA
0000077A  BC3C 0004                753              CMP.B   #%100,D6
0000077E  6700 002A                754              BEQ     SUBBEA
00000782                           755              
00000782  6000 05A0                756              BRA     UNKNOWN
00000786                           757  
00000786  22FC 5355422E            758  SUBLEA      MOVE.L  #'SUB.',(A1)+
0000078C  5841                     759              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
0000078E  12FC 004C                760              MOVE.B  #'L',(A1)+
00000792  5241                     761              ADDQ    #1,D1               ; We added 1 byte into D1
00000794  6000 0202                762              BRA     ANDEA
00000798                           763              
00000798  22FC 5355422E            764  SUBWEA      MOVE.L  #'SUB.',(A1)+
0000079E  5841                     765              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000007A0  12FC 0057                766              MOVE.B  #'W',(A1)+
000007A4  5241                     767              ADDQ    #1,D1               ; We added 1 byte into D1
000007A6  6000 01F0                768              BRA     ANDEA
000007AA                           769  
000007AA  22FC 5355422E            770  SUBBEA      MOVE.L  #'SUB.',(A1)+
000007B0  5841                     771              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000007B2  12FC 0042                772              MOVE.B  #'B',(A1)+
000007B6  5241                     773              ADDQ    #1,D1               ; We added 1 byte into D1
000007B8  6000 01DE                774              BRA     ANDEA
000007BC                           775  
000007BC  22FC 5355422E            776  SUBLDN      MOVE.L  #'SUB.',(A1)+
000007C2  5841                     777              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000007C4  12FC 004C                778              MOVE.B  #'L',(A1)+
000007C8  5241                     779              ADDQ    #1,D1               ; We added 1 byte into D1
000007CA  6000 0238                780              BRA ANDDN
000007CE                           781              
000007CE  22FC 5355422E            782  SUBWDN      MOVE.L  #'SUB.',(A1)+
000007D4  5841                     783              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000007D6  12FC 0057                784              MOVE.B  #'W',(A1)+
000007DA  5241                     785              ADDQ    #1,D1               ; We added 1 byte into D1
000007DC  6000 0226                786              BRA ANDDN
000007E0                           787  
000007E0  22FC 5355422E            788  SUBBDN      MOVE.L  #'SUB.',(A1)+
000007E6  5841                     789              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000007E8  12FC 0042                790              MOVE.B  #'B',(A1)+
000007EC  5241                     791              ADDQ    #1,D1               ; We added 1 byte into D1
000007EE  6000 0214                792              BRA ANDDN  
000007F2                           793  
000007F2                           794  ;  Here we assume that these left-most nybble has been confirmed: 1011  
000007F2                           795  CMP        
000007F2  2C05                     796              MOVE.L  D5,D6               ; Push D5 into D6
000007F4  EC9E                     797              ROR.L   #6,D6               ; Rotate 6 bits to the right
000007F6  E38E                     798              LSL.L   #1,D6               ; Add 0 to right most bit
000007F8  0206 000F                799              ANDI.B  #$0F,D6             ; Isolate right-most nybble
000007FC                           800              
000007FC  BC3C 0000                801              CMP.B   #$00,D6             ; If it matches CMP.B's size bit + 0 added to right
00000800  6700 0016                802              BEQ     CMPB                ; First 4 left-most bits plus size of CMP confirmed
00000804                           803  
00000804  BC3C 0002                804              CMP.B   #$02,D6             ; If it matches CMP.W's size bit + 0 added to right
00000808  6700 0026                805              BEQ     CMPW                ; First 4 left-most bits plus size of CMP confirmed 
0000080C                           806  
0000080C  BC3C 0004                807              CMP.B   #$04,D6             ; If it matches CMP.B's size bit + 0 added to right
00000810  6700 0036                808              BEQ     CMPL                ; First 4 left-most bits plus size of CMP confirmed 
00000814                           809   
00000814  6000 050E                810              BRA     UNKNOWN             ; else unknown 
00000818                           811  
00000818                           812  ;  Here we assume that confirming these bits, 1011 --- 000 --- ---, is enough to identify CMP.B 
00000818  32FC 434D                813  CMPB        MOVE.W  #'CM',(A1)+
0000081C  12FC 0050                814              MOVE.B  #'P',(A1)+
00000820  12FC 002E                815              MOVE.B  #'.',(A1)+
00000824  12FC 0042                816              MOVE.B  #'B',(A1)+
00000828  5A41                     817              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
0000082A  7001                     818              MOVE.L  #1,D0               ; Put 1 into D0 to indicate it's a bytesize
0000082C  6000 0032                819              BRA     CMPOP
00000830                           820  
00000830                           821  ;  Here we assume that confirming these bits, 1011 --- 001 --- ---, is enough to identify CMP.W   
00000830  32FC 434D                822  CMPW        MOVE.W  #'CM',(A1)+
00000834  12FC 0050                823              MOVE.B  #'P',(A1)+
00000838  12FC 002E                824              MOVE.B  #'.',(A1)+
0000083C  12FC 0057                825              MOVE.B  #'W',(A1)+
00000840  5A41                     826              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
00000842  7002                     827              MOVE.L  #2,D0               ; Put 2 into D0 to indicate it's a wordsize
00000844  6000 001A                828              BRA     CMPOP
00000848                           829              
00000848                           830  ;  Here we assume that confirming these bits, 1011 --- 010 --- ---, is enough to identify CMP.L
00000848  32FC 434D                831  CMPL        MOVE.W  #'CM',(A1)+
0000084C  12FC 0050                832              MOVE.B  #'P',(A1)+
00000850  12FC 002E                833              MOVE.B  #'.',(A1)+
00000854  12FC 004C                834              MOVE.B  #'L',(A1)+
00000858  5A41                     835              ADDQ    #5,D1              ; We added 5 new characters to our IOStringLoc 
0000085A  7003                     836              MOVE.L  #3,D0               ; Put 3 into D0 to indicate it's a longsize
0000085C  6000 0002                837              BRA     CMPOP
00000860                           838              
00000860  12FC 0020                839  CMPOP       MOVE.B  #' ',(A1)+
00000864  32FC 2020                840              MOVE.W  #'  ',(A1)+      ; Add a spacer into our IOStringLoc
00000868  32FC 2020                841              MOVE.W  #'  ',(A1)+
0000086C  5A41                     842              ADDQ    #5,D1              ; We added 4 bytes, aka 4 spaces
0000086E                           843              
0000086E  2C05                     844              MOVE.L  D5,D6               ; Push D5 into D6
00000870  0286 0000003F            845              ANDI.L  #$003F,D6           ; Isolate the Src EA bits 
Line 846 ERROR: Undefined symbol
00000876  4EB9 004DBB8E            846              JSR EAGETSRCEA              ; Find and print the code stored in D6
0000087C                           847              
0000087C  12FC 002C                848              MOVE.B  #',',(A1)+
00000880  5241                     849              ADDQ    #1,D1
00000882                           850              
00000882  2C05                     851              MOVE.L  D5,D6               ; Copy D5 into D6
00000884  E09E                     852              ROR.L   #8,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00000886  E29E                     853              ROR.L   #1,D6               ; Rotate 9 bits to the right (Dn Dst bits)
00000888  0286 00000007            854              ANDI.L  #$0007,D6           ; Isolate the Dn Destination bits
Line 855 ERROR: Undefined symbol
0000088E  4EF9 004DBB8E            855              JMP EADN
00000894                           856              
00000894  4E75                     857              RTS          
00000896                           858          
00000896                           859  ; This label determines if the code is either MULS or AND, by looking at it's size bits     
00000896  2C05                     860  MULSAND     MOVE.L  D5,D6               ; Copy D5 into D6
00000898  CC3C 0038                861              AND.B   #$38,D6             ; Check if the Src is of mode An
0000089C  BC3C 0008                862              CMP.B   #$08,D6
000008A0  6700 0482                863              BEQ     UNKNOWN             ; An is Invalid, branch to Unknown  
000008A4  2C05                     864              MOVE.L  D5,D6               ; Copy D5 into D6 
000008A6  EC8E                     865              LSR.L   #6,D6               ; Shift the size bits to the far right
000008A8  0206 0007                866              ANDI.B  #$7,D6              ; Isolate the size bits
000008AC  BC3C 0007                867              CMP.B   #7,D6               ; See if the size is '111'..
000008B0  6704                     868              BEQ.S   MULS                ; ..If so, it's a MULS opcode
000008B2  6000 003E                869              BRA     AND                 ; Otherwise, it's an AND code
000008B6                           870          
000008B6                           871  MULS                                   ; One test for illegal Src EA Mode
000008B6                           872  *            MOVE.L  D5,D6              ; Push D5 into D6   
000008B6                           873  *            ROR.L   #3,D6              ; Roll 3 bits right
000008B6                           874  *            ANDI.L  #$0007,D6          ; Isolate the 3 Src (Mode) bits
000008B6                           875  *            CMP.L   #$0001,D6          ; Compare with illegal mode An
000008B6                           876  *            BEQ     UNKNOWN
000008B6                           877              *----------------
000008B6  22FC 4D554C53            878              MOVE.L  #'MULS',(A1)+
000008BC  5841                     879              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000008BE                           880              
000008BE  22FC 20202020            881              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
000008C4  32FC 2020                882              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
000008C8  5C41                     883              ADDQ    #6,D1               ; We added 4 bytes, aka 4 spaces
000008CA                           884              
000008CA  7002                     885              MOVE.L  #2,D0               ; Put 2 into D0 to indicate it's a wordsize
000008CC  2C05                     886              MOVE.L  D5,D6               ; Copy D5 into D6
000008CE                           887              ;DC.L    0,0,0,0             ; Fault Bandaid
000008CE  0286 0000003F            888              ANDI.L  #$003F,D6           ; Isolate the Src EA bits
Line 889 ERROR: Undefined symbol
000008D4  4EB9 004DBB8E            889              JSR EAGETSRCEA
000008DA                           890              
000008DA  12FC 002C                891              MOVE.B  #',',(A1)+
000008DE  5241                     892              ADDQ    #1,D1
000008E0                           893              
000008E0  2C05                     894              MOVE.L  D5,D6               ; Copy D5 into D6
000008E2  EF5E                     895              ROL.W   #7,D6               ; Rotate 9 bits to the right (Dn Dst bits)
000008E4  0286 00000007            896              ANDI.L  #$0007,D6           ; Isolate the Dn Destination bits
Line 897 ERROR: Undefined symbol
000008EA  4EF9 004DBB8E            897              JMP EADN
000008F0                           898              
000008F0  4E75                     899              RTS
000008F2                           900              
000008F2                           901  ; At this point, we know D6 is the size of our opcode
000008F2  CC3C 0004                902  AND         AND.B   #$04,D6
000008F6  BC3C 0004                903              CMP.B   #%0100,D6           ; See if D6 is size "%100" through "%110"..
000008FA  6700 0026                904              BEQ     ANDEACH             ; .. Dn ~ <EA> --> <EA>
000008FE                           905              
000008FE  2C05                     906              MOVE.L  D5,D6               ; Copy D5 into D6
00000900  EC8E                     907              LSR.L   #6,D6               ; Shift the size bits to the far right
00000902  0206 0007                908              ANDI.B  #$7,D6              ; Isolate the size bits 
00000906                           909              
00000906  BC3C 0002                910              CMP.B   #%10,D6             ; See if D6 is size "%000" through "%010"..
0000090A  6700 00C2                911              BEQ     ANDLDN              ; If it is, our OpCode is in the format of..
0000090E  BC3C 0001                912              CMP.B   #%01,D6             ; .. <EA> ~ Dn --> Dn
00000912  6700 00CC                913              BEQ     ANDWDN
00000916  BC3C 0000                914              CMP.B   #%00,D6
0000091A  6700 00D6                915              BEQ     ANDBDN              ; == 000 at this point
0000091E                           916              
0000091E  6000 0404                917              BRA     UNKNOWN
00000922                           918  
00000922  2C05                     919  ANDEACH     MOVE.L  D5,D6               ; Copy D5 into D6
00000924  CC3C 003F                920              AND.B   #$3F,D6             ; Isolate our EA Src bits
00000928  BC3C 0039                921              CMP.B   #$39,D6             ; Check for Illegal #$ mode
0000092C  6700 03F6                922              BEQ     UNKNOWN
00000930  CC3C 0038                923              AND.B   #$38,D6             ; Isolate our EA Src Mode bits
00000934  BC3C 0008                924              CMP.B   #$08,D6             ; Check for Illegal mode An
00000938  6700 03EA                925              BEQ     UNKNOWN
0000093C  BC3C 0000                926              CMP.B   #$00,D6             ; Check for Illegal mode Dn 
00000940  6700 03E2                927              BEQ     UNKNOWN
00000944                           928              
00000944  2C05                     929              MOVE.L  D5,D6               ; Copy D5 into D6
00000946  EC8E                     930              LSR.L   #6,D6               ; Shift the size bits to the far right
00000948  0206 0007                931              ANDI.B  #$7,D6              ; Isolate the size bits    
0000094C                           932                   
0000094C  BC3C 0006                933              CMP.B   #%0110,D6           ; See if D6 is size "%100" through "%110"..
00000950  6700 0016                934              BEQ     ANDLEA              ; If it is, our OpCode is in the format of..
00000954  BC3C 0005                935              CMP.B   #%101,D6            ; .. Dn ~ <EA> --> <EA>
00000958  6700 001E                936              BEQ     ANDWEA
0000095C  BC3C 0004                937              CMP.B   #%100,D6
00000960  6700 0026                938              BEQ     ANDBEA
00000964                           939              
00000964  6000 03BE                940              BRA     UNKNOWN
00000968                           941  
00000968                           942              
00000968  22FC 414E442E            943  ANDLEA      MOVE.L  #'AND.',(A1)+
0000096E  12FC 004C                944              MOVE.B  #'L',(A1)+
00000972  5A41                     945              ADDQ    #5,D1               ; We added 5 byte into D1
00000974  6000 0022                946              BRA     ANDEA
00000978                           947              
00000978  22FC 414E442E            948  ANDWEA      MOVE.L  #'AND.',(A1)+
0000097E  12FC 0057                949              MOVE.B  #'W',(A1)+
00000982  5A41                     950              ADDQ    #5,D1               ; We added 5 byte into D1
00000984  6000 0012                951              BRA     ANDEA
00000988                           952  
00000988  22FC 414E442E            953  ANDBEA      MOVE.L  #'AND.',(A1)+
0000098E  12FC 0042                954              MOVE.B  #'B',(A1)+
00000992  5A41                     955              ADDQ    #5,D1               ; We added 5 byte into D1
00000994  6000 0002                956              BRA     ANDEA
00000998                           957  
00000998  12FC 0020                958  ANDEA       MOVE.B  #' ',(A1)+          ; Add a spacer into our IOStringLoc
0000099C  32FC 2020                959              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
000009A0  32FC 2020                960              MOVE.W  #'  ',(A1)+          ; Add a spacer into our IOStringLoc
000009A4  5A41                     961              ADDQ    #5,D1               ; We added 4 bytes, aka 4 spaces
000009A6                           962              
000009A6  2C05                     963              MOVE.L  D5,D6
000009A8  E08E                     964              LSR.L   #8,D6               ; Shift our OpCode a total of 9 bits to the right
000009AA  E28E                     965              LSR.L   #1,D6               ; 
000009AC  0286 00000007            966              ANDI.L  #$07,D6             ; Isolate our data register
000009B2                           967              
Line 968 ERROR: Undefined symbol
000009B2  4EB9 004DBB8E            968              JSR EADN
000009B8                           969              
000009B8  12FC 002C                970              MOVE.B  #',',(A1)+
000009BC  5241                     971              ADDQ    #1,D1
000009BE                           972              
000009BE  2C05                     973              MOVE.L  D5,D6               ; Copy our OpCode again
000009C0  0286 0000003F            974              ANDI.L  #$3F,D6             ; Isolate our EA bits
000009C6                           975              
Line 976 ERROR: Undefined symbol
000009C6  4EB9 004DBB8E            976              JSR EAGETSRCEA  
000009CC                           977              
000009CC  4E75                     978              RTS
000009CE                           979              
000009CE  22FC 414E442E            980  ANDLDN      MOVE.L  #'AND.',(A1)+
000009D4  5841                     981              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000009D6  12FC 004C                982              MOVE.B  #'L',(A1)+
000009DA  5241                     983              ADDQ    #1,D1               ; We added 1 byte into D1
000009DC  6000 0026                984              BRA ANDDN
000009E0                           985              
000009E0  22FC 414E442E            986  ANDWDN      MOVE.L  #'AND.',(A1)+
000009E6  5841                     987              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000009E8  12FC 0057                988              MOVE.B  #'W',(A1)+
000009EC  5241                     989              ADDQ    #1,D1               ; We added 1 byte into D1
000009EE  6000 0014                990              BRA ANDDN
000009F2                           991  
000009F2  22FC 414E442E            992  ANDBDN      MOVE.L  #'AND.',(A1)+
000009F8  5841                     993              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
000009FA  12FC 0042                994              MOVE.B  #'B',(A1)+
000009FE  5241                     995              ADDQ    #1,D1               ; We added 1 byte into D1
00000A00  6000 0002                996              BRA ANDDN  
00000A04                           997  
00000A04                           998  ANDDN
00000A04  12FC 0009                999              MOVE.B  #$09,(A1)+          ; Add a spacer into our IOStringLoc
00000A08  5241                    1000              ADDQ    #1,D1               ; We added 4 bytes, aka 4 spaces
00000A0A                          1001              
00000A0A  2C05                    1002              MOVE.L  D5,D6               ; Copy our OpCode again
00000A0C  0286 0000003F           1003              ANDI.L  #$3F,D6             ; Isolate our EA bits
00000A12                          1004              
Line 1005 ERROR: Undefined symbol
00000A12  4EB9 004DBB8E           1005              JSR EAGETSRCEA              
00000A18                          1006              
00000A18  12FC 002C               1007              MOVE.B  #',',(A1)+
00000A1C  5241                    1008              ADDQ    #1,D1
00000A1E                          1009              
00000A1E  2C05                    1010              MOVE.L  D5,D6
00000A20  E08E                    1011              LSR.L   #8,D6               ; Shift our OpCode a total of 9 bits to the right
00000A22  E28E                    1012              LSR.L   #1,D6               ; 
00000A24  0286 00000007           1013              ANDI.L  #$07,D6             ; Isolate our data register
00000A2A                          1014              
Line 1015 ERROR: Undefined symbol
00000A2A  4EB9 004DBB8E           1015              JSR EADN
00000A30                          1016              
00000A30  4E75                    1017              RTS
00000A32                          1018  
00000A32                          1019  ; This label determines if the code is either ADD or ADDA           
00000A32  2C05                    1020  ADDADDA     MOVE.L  D5,D6               ; Copy D5 into D6
00000A34  EC8E                    1021              LSR.L   #6,D6               ; Shift the size bits to the far right
00000A36  0206 0004               1022              ANDI.B  #$4,D6              ; Isolate the size bits
00000A3A                          1023              
00000A3A  BC3C 0004               1024              CMP.B   #%0100,D6           ; See if D6 is size "%100" through "%110"..
00000A3E  6700 006C               1025              BEQ     ADDEA              ; .. Dn ~ <EA> --> <EA>
00000A42                          1026              
00000A42  2C05                    1027              MOVE.L  D5,D6               ; Copy D5 into D6
00000A44  EC8E                    1028              LSR.L   #6,D6               ; Shift the size bits to the far right
00000A46  0206 0007               1029              ANDI.B  #$7,D6              ; Isolate the size bits
00000A4A                          1030  
00000A4A                          1031              
00000A4A  BC3C 0002               1032              CMP.B   #%10,D6             ; See if D6 is size "%000" through "%010"..
00000A4E  6700 0026               1033              BEQ     ADDLDN              ; If it is, our OpCode is in the format of..
00000A52  BC3C 0001               1034              CMP.B   #%01,D6             ; .. <EA> ~ Dn --> Dn
00000A56  6700 0030               1035              BEQ     ADDWDN
00000A5A  BC3C 0000               1036              CMP.B   #%00,D6
00000A5E  6700 003A               1037              BEQ     ADDBDN              ; == 000 at this point
00000A62                          1038              
00000A62  BC3C 0003               1039              CMP.B   #%011,D6            ; ADDA Word Operation <EA> -> An 
00000A66  6700 00C2               1040              BEQ     ADDAW
00000A6A  BC3C 0007               1041              CMP.B   #%111,D6            ; ADDA Word Operation <EA> -> An  
00000A6E  6700 00CE               1042              BEQ     ADDAL
00000A72  6000 02B0               1043              BRA     UNKNOWN
00000A76                          1044              
00000A76  22FC 4144442E           1045  ADDLDN      MOVE.L  #'ADD.',(A1)+
00000A7C  5841                    1046              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00000A7E  12FC 004C               1047              MOVE.B  #'L',(A1)+
00000A82  5241                    1048              ADDQ    #1,D1               ; We added 1 byte into D1
00000A84  6000 FF7E               1049              BRA ANDDN
00000A88                          1050              
00000A88  22FC 4144442E           1051  ADDWDN      MOVE.L  #'ADD.',(A1)+
00000A8E  5841                    1052              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00000A90  12FC 0057               1053              MOVE.B  #'W',(A1)+
00000A94  5241                    1054              ADDQ    #1,D1               ; We added 1 byte into D1
00000A96  6000 FF6C               1055              BRA ANDDN
00000A9A                          1056  
00000A9A  22FC 4144442E           1057  ADDBDN      MOVE.L  #'ADD.',(A1)+
00000AA0  5841                    1058              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00000AA2  12FC 0042               1059              MOVE.B  #'B',(A1)+
00000AA6  5241                    1060              ADDQ    #1,D1               ; We added 1 byte into D1
00000AA8  6000 FF5A               1061              BRA ANDDN  
00000AAC                          1062  
00000AAC  2C05                    1063  ADDEA       MOVE.L  D5,D6               ; Copy D5 into D6
00000AAE  CC3C 003F               1064              AND.B   #$3F,D6             ; Isolate our EA Src bits
00000AB2  BC3C 0039               1065              CMP.B   #$39,D6             ; Check for Illegal #$ mode
00000AB6  6700 026C               1066              BEQ     UNKNOWN
00000ABA  CC3C 0038               1067              AND.B   #$38,D6             ; Isolate our EA Src Mode bits
00000ABE  BC3C 0008               1068              CMP.B   #$08,D6             ; Check for Illegal mode An
00000AC2  6700 0260               1069              BEQ     UNKNOWN
00000AC6  BC3C 0000               1070              CMP.B   #$00,D6             ; Check for Illegal mode Dn 
00000ACA  6700 0258               1071              BEQ     UNKNOWN
00000ACE                          1072              
00000ACE  2C05                    1073              MOVE.L  D5,D6               ; Copy D5 into D6
00000AD0  EC8E                    1074              LSR.L   #6,D6               ; Shift the size bits to the far right
00000AD2  0206 0007               1075              ANDI.B  #$7,D6              ; Isolate the size bits    
00000AD6                          1076                   
00000AD6  BC3C 0006               1077              CMP.B   #%0110,D6           ; See if D6 is size "%100" through "%110"..
00000ADA  6700 0016               1078              BEQ     ADDLEA              ; If it is, our OpCode is in the format of..
00000ADE  BC3C 0005               1079              CMP.B   #%101,D6            ; .. Dn ~ <EA> --> <EA>
00000AE2  6700 0020               1080              BEQ     ADDWEA
00000AE6  BC3C 0004               1081              CMP.B   #%100,D6
00000AEA  6700 002A               1082              BEQ     ADDBEA
00000AEE                          1083              
00000AEE  6000 0234               1084              BRA     UNKNOWN
00000AF2                          1085  
00000AF2                          1086              
00000AF2  22FC 4144442E           1087  ADDLEA      MOVE.L  #'ADD.',(A1)+
00000AF8  5841                    1088              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00000AFA  12FC 004C               1089              MOVE.B  #'L',(A1)+
00000AFE  5241                    1090              ADDQ    #1,D1               ; We added 1 byte into D1
00000B00  6000 FE96               1091              BRA     ANDEA
00000B04                          1092              
00000B04  22FC 4144442E           1093  ADDWEA      MOVE.L  #'ADD.',(A1)+
00000B0A  5841                    1094              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00000B0C  12FC 0057               1095              MOVE.B  #'W',(A1)+
00000B10  5241                    1096              ADDQ    #1,D1               ; We added 1 byte into D1
00000B12  6000 FE84               1097              BRA     ANDEA
00000B16                          1098  
00000B16  22FC 4144442E           1099  ADDBEA      MOVE.L  #'ADD.',(A1)+
00000B1C  5841                    1100              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00000B1E  12FC 0042               1101              MOVE.B  #'B',(A1)+
00000B22  5241                    1102              ADDQ    #1,D1               ; We added 1 byte into D1
00000B24  7001                    1103              MOVE.L  #1,D0               ; Move 1 into D0 to indicate bytesize
00000B26  6000 FE70               1104              BRA     ANDEA
00000B2A                          1105              
00000B2A  22FC 41444441           1106  ADDAW       MOVE.L  #'ADDA',(A1)+
00000B30  5841                    1107              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00000B32  32FC 2E57               1108              MOVE.W  #'.W',(A1)+
00000B36  5441                    1109              ADDQ    #2,D1               ; We added 1 byte into D1
00000B38  7002                    1110              MOVE.L  #2,D0               ; Move 2 into D0 to indicate wordsize
00000B3A  6000 0016               1111              BRA     ADDAN
00000B3E                          1112              
00000B3E  22FC 41444441           1113  ADDAL       MOVE.L  #'ADDA',(A1)+
00000B44  5841                    1114              ADDQ    #4,D1               ; We added 4 new characters to our IOStringLoc
00000B46  32FC 2E4C               1115              MOVE.W  #'.L',(A1)+
00000B4A  5441                    1116              ADDQ    #2,D1               ; We added 1 byte into D1
00000B4C  7003                    1117              MOVE.L  #3,D0               ; Move 3 into D0 to indicate longsize
00000B4E  6000 0002               1118              BRA     ADDAN
00000B52                          1119         
00000B52                          1120  ADDAN
00000B52  22FC 20202020           1121              MOVE.L  #'    ',(A1)+          ; Add a spacer into our IOStringLoc
00000B58                          1122              
00000B58  5841                    1123              ADDQ    #4,D1               ; We added 4 bytes, aka 4 spaces
00000B5A                          1124              
00000B5A  2C05                    1125              MOVE.L  D5,D6               ; Copy our OpCode again
00000B5C  0286 0000003F           1126              ANDI.L  #$3F,D6             ; Isolate our EA bits
00000B62                          1127              
Line 1128 ERROR: Undefined symbol
00000B62  4EB9 004DBB8E           1128              JSR EAGETSRCEA              
00000B68                          1129              
00000B68  12FC 002C               1130              MOVE.B  #',',(A1)+
00000B6C  5241                    1131              ADDQ    #1,D1
00000B6E                          1132              
00000B6E  2C05                    1133              MOVE.L  D5,D6
00000B70  E08E                    1134              LSR.L   #8,D6               ; Shift our OpCode a total of 9 bits to the right
00000B72  E28E                    1135              LSR.L   #1,D6               ; 
00000B74  0286 00000007           1136              ANDI.L  #$07,D6             ; Isolate our data register
00000B7A                          1137              
Line 1138 ERROR: Undefined symbol
00000B7A  4EB9 004DBB8E           1138              JSR EAAN
00000B80                          1139              
00000B80  4E75                    1140              RTS
00000B82                          1141  ; This label determines if the code is either ASd (ASR) or LSd (LSL) or ROd (ROL) 
00000B82                          1142  ASLSRO
00000B82  2C05                    1143              MOVE.L  D5,D6               ; Copy our OpCode
00000B84  EC4E                    1144              LSR.W   #6,D6               ; Shift our size bits into place
00000B86  0206 0003               1145              ANDI.B  #$03,D6             ; Isolate our size bits
00000B8A  BC3C 0003               1146              CMP.B   #%11,D6             ; If our size is '11'..
00000B8E  6700 00E2               1147              BEQ     AASLSRO             ; ..this is an address ASLSRO
00000B92                          1148              
00000B92  2C05                    1149              MOVE.L  D5,D6               ; Copy our OpCode
00000B94  E64E                    1150              LSR.W   #3,D6               ; Shift our identification bits over
00000B96  0206 0003               1151              ANDI.B  #03,D6              ;  and isolate them
00000B9A                          1152              
00000B9A  BC3C 0000               1153              CMP.B   #%00,D6             ; If '00', this is a ASd op
00000B9E  6700 0016               1154              BEQ     ASD
00000BA2  BC3C 0001               1155              CMP.B   #%01,D6             ; If '01', this is a LSd op
00000BA6  6700 0018               1156              BEQ     LSD
00000BAA  BC3C 0003               1157              CMP.B   #%11,D6             ; If '11', this is a ROd op
00000BAE  6700 001A               1158              BEQ     ROD
00000BB2                          1159              
00000BB2  6000 0170               1160              BRA     UNKNOWN             ; This catches for ROX, non-required op
00000BB6                          1161  
00000BB6  32FC 4153               1162  ASD         MOVE.W  #'AS',(A1)+
00000BBA  5441                    1163              ADDQ    #2,D1
00000BBC  6000 0016               1164              BRA     ASLSRODR
00000BC0                          1165              
00000BC0  32FC 4C53               1166  LSD         MOVE.W  #'LS',(A1)+
00000BC4  5441                    1167              ADDQ    #2,D1
00000BC6  6000 000C               1168              BRA     ASLSRODR
00000BCA                          1169              
00000BCA  32FC 524F               1170  ROD         MOVE.W  #'RO',(A1)+
00000BCE  5441                    1171              ADDQ    #2,D1
00000BD0  6000 0002               1172              BRA     ASLSRODR
00000BD4                          1173              
00000BD4                          1174  ; This section checks our ASd/LSd/ROd direction, and defaults to Right 
00000BD4  2C05                    1175  ASLSRODR    MOVE.L  D5,D6               ; Copy our OpCode
00000BD6  E09E                    1176              ROR.L   #8,D6               ; Shift our direction bit into place
00000BD8  0806 0000               1177              BTST    #$00,D6             ; Check our right-most bit 
00000BDC  6600 0010               1178              BNE     ASLSRODL            ; If it's '1', our direction is left
00000BE0                          1179              
00000BE0  12FC 0052               1180              MOVE.B  #'R',(A1)+          ; Otherwise it's right
00000BE4  12FC 002E               1181              MOVE.B  #'.',(A1)+
00000BE8  5441                    1182              ADDQ    #2,D1
00000BEA                          1183              
00000BEA  6000 000C               1184              BRA ASLSROSIZE
00000BEE                          1185              
00000BEE                          1186  ; This section is our ASd/LSd/ROd left direction
00000BEE  12FC 004C               1187  ASLSRODL    MOVE.B  #'L',(A1)+          ; L for Left
00000BF2  12FC 002E               1188              MOVE.B  #'.',(A1)+
00000BF6  5441                    1189              ADDQ    #2,D1
00000BF8                          1190              ; Carry into our Size determiner
00000BF8                          1191  ; Determines what size our ASd/LSd/ROd is
00000BF8                          1192  ;  Our previous operations on D6 leave our size bits
00000BF8                          1193  ;  just our of range, so we shift them in
00000BF8                          1194  ASLSROSIZE  
00000BF8  E59E                    1195              ROL.L   #2,D6               ; Shift our size bits in
00000BFA  0206 0003               1196              ANDI.B  #$03,D6             ; Isolate our size bits
00000BFE  BC3C 0000               1197              CMP.B   #%00,D6             ; If our size is '00'..
00000C02  6700 0012               1198              BEQ     ASLSROB             ; ..Then it's a byte op
00000C06  BC3C 0001               1199              CMP.B   #%01,D6             ; If our size is '01'..
00000C0A  6700 0012               1200              BEQ     ASLSROW             ; ..Then it's a word op
00000C0E                          1201              ; Otherwise it's a long op, because we accounted for '11' earlier
00000C0E                          1202              
00000C0E  12FC 004C               1203              MOVE.B  #'L',(A1)+          ; Add L for Long
00000C12  6000 000E               1204              BRA     ASLSROIR            ; Complete the rest of the ASLSRO Op
00000C16                          1205              
00000C16  12FC 0042               1206  ASLSROB     MOVE.B  #'B',(A1)+          ; Add B for Byte
00000C1A  6000 0006               1207              BRA     ASLSROIR            ; Complete the rest of the ASLSRO Op
00000C1E                          1208              
00000C1E  12FC 0057               1209  ASLSROW     MOVE.B  #'W',(A1)+          ; Add W for Word
00000C22                          1210              ; Carry through to complete the rest of the ASLSRO Op  
00000C22                          1211       
00000C22                          1212  ; This section determines if our ASLSRO is an Immediate or Dn shfit, and defaults to Immediate
00000C22  12FC 0020               1213  ASLSROIR    MOVE.B  #' ',(A1)+
00000C26  32FC 2020               1214              MOVE.W  #'  ',(A1)+
00000C2A  32FC 2020               1215              MOVE.W  #'  ',(A1)+
00000C2E  5C41                    1216              ADDQ    #6,D1               ; We've added 5 new characters (Size char, plus spaces)
00000C30                          1217              
00000C30                          1218              ;MOVE.L  D5,D6
00000C30  E39E                    1219              ROL.L   #1,D6               ; Get our Immediate / Register bit out front
00000C32  0806 0000               1220              BTST.L  #$00,D6
00000C36  6600 000C               1221              BNE     ASLSROIRDN          ; If it's '1', we have a Dn ASLSRO
00000C3A                          1222              ; Otherwise, assume immediate ASLSRO
00000C3A  12FC 0023               1223              MOVE.B  #'#',(A1)+
00000C3E  5241                    1224              ADDQ    #1,D1
00000C40  6000 0008               1225              BRA     ASLSROOP            ; Branch to our ASLSRO Op finish
00000C44                          1226  ; An ASLSRO of Dn Register type   
00000C44  12FC 0044               1227  ASLSROIRDN  MOVE.B  #'D',(A1)+
00000C48  5241                    1228              ADDQ    #1,D1
00000C4A                          1229              ; Continue through to our ASLSRO Op finish
00000C4A                          1230  ; Finishes the ASLSRO Op
00000C4A                          1231  ASLSROOP
00000C4A  2C05                    1232              MOVE.L  D5,D6               ; Copy our OpCode into D6
00000C4C  E09E                    1233              ROR.L   #8,D6               ; Shift our Count/Reg bits into place
00000C4E  E29E                    1234              ROR.L   #1,D6               ;
00000C50  0206 0007               1235              ANDI.B  #$07,D6             ; Isolate the Count/Reg bits
00000C54                          1236              
00000C54  0606 0030               1237              ADDI.B  #48,D6 
00000C58  12C6                    1238              MOVE.B  D6,(A1)+            ; Push our number to the IOStringLoc
00000C5A  5241                    1239              ADDQ    #1,D1
00000C5C                          1240              
00000C5C  12FC 002C               1241              MOVE.B  #',',(A1)+
00000C60  5241                    1242              ADDQ    #1,D1
00000C62                          1243              
00000C62  2C05                    1244              MOVE.L  D5,D6               ; Isolate our Dn affected num bits
00000C64  0286 00000007           1245              ANDI.L  #$07,D6             ;
Line 1246 ERROR: Undefined symbol
00000C6A  4EB9 004DBB8E           1246              JSR     EADN
00000C70                          1247              
00000C70  4E75                    1248              RTS
00000C72                          1249  ; Start of the Effective Address version of ASLSRO
00000C72  2C05                    1250  AASLSRO     MOVE.L  D5,D6               ; Copy our OpCode into D6
00000C74  CCBC 0000003F           1251              AND.L   #$3F,D6             ; Isolate the EA Srcs bits
00000C7A  BC3C 0039               1252              CMP.B   #$39,D6             ; Check for illegal #$ mode
00000C7E  6700 00A4               1253              BEQ     UNKNOWN
00000C82  CCBC 00000038           1254              AND.L   #$38,D6             ; Isolate the EA src mode bits
00000C88  BC3C 0008               1255              CMP.B   #$08,D6             ; Check for illegal An Mode
00000C8C  6700 0096               1256              BEQ     UNKNOWN
00000C90  BC3C 0000               1257              CMP.B   #$00,D6             ; Check for illegal Dn mode
00000C94  6700 008E               1258              BEQ     UNKNOWN
00000C98                          1259              
00000C98                          1260  
00000C98  2C05                    1261              MOVE.L  D5,D6               ; Copy our OpCode into D6
00000C9A  EF5E                    1262              ROL.W   #7,D6               ; Shift our determination bits to the far right
00000C9C  0206 0007               1263              ANDI.B  #$07,D6             ; Isolate the determination bits   
00000CA0                          1264              
00000CA0  BC3C 0001               1265              CMP.B   #$01,D6             ; If our determination is '001'..
00000CA4  6700 0020               1266              BEQ     ALSD                ; It's a Logical Shift
00000CA8  BC3C 0003               1267              CMP.B   #$03,D6             ; If it's '011'
00000CAC  6700 0022               1268              BEQ     AROD                ; It's a Rotation 
00000CB0  BC3C 0000               1269              CMP.B   #$00,D6             ; If it's '000'
00000CB4  6700 0006               1270              BEQ     AASD                ; It's an Arithmetic Shift
00000CB8                          1271              
00000CB8  6000 006A               1272              BRA     UNKNOWN              ; Otherwise it's data
00000CBC                          1273  
00000CBC  32FC 4153               1274  AASD        MOVE.W  #'AS',(A1)+
00000CC0  5441                    1275              ADDQ    #2,D1
00000CC2  6000 0016               1276              BRA     AASLSRODR
00000CC6                          1277              
00000CC6  32FC 4C53               1278  ALSD        MOVE.W  #'LS',(A1)+
00000CCA  5441                    1279              ADDQ    #2,D1
00000CCC  6000 000C               1280              BRA     AASLSRODR
00000CD0                          1281              
00000CD0  32FC 524F               1282  AROD        MOVE.W  #'RO',(A1)+
00000CD4  5441                    1283              ADDQ    #2,D1
00000CD6  6000 0002               1284              BRA     AASLSRODR
00000CDA                          1285              
00000CDA                          1286  ; This section checks our ASd/LSd/ROd direction, and defaults to Right 
00000CDA  2C05                    1287  AASLSRODR   MOVE.L  D5,D6              ; Copy our OpCode
00000CDC  E09E                    1288              ROR.L   #8,D6               ; Shift our direction bit into place
00000CDE  0806 0000               1289              BTST    #$00,D6             ; Check our right-most bit 
00000CE2  6600 000C               1290              BNE     AASLSRODL           ; If it's '1', our direction is left
00000CE6                          1291              
00000CE6  12FC 0052               1292              MOVE.B  #'R',(A1)+          ; Otherwise it's right
00000CEA  5241                    1293              ADDQ    #1,D1
00000CEC                          1294              
00000CEC  6000 0008               1295              BRA AASLSROOP
00000CF0                          1296              
00000CF0                          1297  ; This section is our ASd/LSd/ROd left direction
00000CF0  12FC 004C               1298  AASLSRODL   MOVE.B  #'L',(A1)+          ; L for Left
00000CF4  5241                    1299              ADDQ    #1,D1
00000CF6                          1300              ; Carry into finishing AASLSRO op
00000CF6                          1301  
00000CF6                          1302  ; This section finishes off our Effective Address ASLSRO Op
00000CF6  2C05                    1303  AASLSROOP   MOVE.L  D5,D6               ; Copy our OpCode
00000CF8  0286 0000003F           1304              ANDI.L  #$3F,D6             ; Isolate our EA bits
00000CFE                          1305              
00000CFE  12FC 002E               1306              MOVE.B  #'.',(A1)+
00000D02  12FC 0057               1307              MOVE.B  #'W',(A1)+
00000D06  12FC 0020               1308              MOVE.B  #' ',(A1)+
00000D0A  12FC 0020               1309              MOVE.B  #' ',(A1)+
00000D0E  12FC 0020               1310              MOVE.B  #' ',(A1)+
00000D12  12FC 0020               1311              MOVE.B  #' ',(A1)+
00000D16  12FC 0020               1312              MOVE.B  #' ',(A1)+
00000D1A  5E41                    1313              ADDQ    #7,D1
00000D1C                          1314              
Line 1315 ERROR: Undefined symbol
00000D1C  4EB9 004DBB8E           1315              JSR EAGETSRCEA
00000D22                          1316              
00000D22  4E75                    1317              RTS
00000D24                          1318  UNKNOWN
00000D24  22FC 44415441           1319              MOVE.L  #'DATA',(A1)+
00000D2A  5841                    1320              ADDQ    #4,D1           ; We added 4 new characters to our IOStringLoc 
00000D2C                          1321              
00000D2C  22FC 20202020           1322              MOVE.L  #'    ',(A1)+       ; Add a spacer into our IOStringLoc
00000D32  32FC 2020               1323              MOVE.W  #'  ',(A1)+         ; Add a spacer into our IOStringLoc
00000D36  5C41                    1324              ADDQ    #6,D1               ; We added 6 bytes, aka 6 spaces
00000D38                          1325              
00000D38  12FC 0024               1326              MOVE.B  #'$',(A1)+
00000D3C  5241                    1327              ADDQ    #1,D1
00000D3E                          1328              
00000D3E  2C05                    1329              MOVE.L  D5,D6
Line 1330 ERROR: Undefined symbol
00000D40  4EB9 004DBB8E           1330              JSR     EAHEXtoASCII
00000D46                          1331              
00000D46  4E75                    1332              RTS
00000D48                          1333  * Put variables and constants here
00000D48                          1334  
00000D48                          1335  
00000D48                          1336  
00000D48                          1337  
00000D48                          1338  
00000D48                          1339  
00000D48                          1340  
00000D48                          1341  
00000D48                          1342  
00000D48                          1343  
00000D48                          1344  
00000D48                          1345  
00000D48                          1346  
00000D48                          1347  
00000D48                          1348  
Line 1349 WARNING: END directive missing, starting address not set

42 errors detected
1 warning generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AASD                CBC
AASLSRO             C72
AASLSRODL           CF0
AASLSRODR           CDA
AASLSROOP           CF6
ADDADDA             A32
ADDAL               B3E
ADDAN               B52
ADDAW               B2A
ADDBDN              A9A
ADDBEA              B16
ADDEA               AAC
ADDI                78
ADDI8               8C
ADDIB               DC
ADDIL               160
ADDIW               120
ADDLDN              A76
ADDLEA              AF2
ADDWDN              A88
ADDWEA              B04
ALSD                CC6
AND                 8F2
ANDBDN              9F2
ANDBEA              988
ANDDN               A04
ANDEA               998
ANDEACH             922
ANDLDN              9CE
ANDLEA              968
ANDWDN              9E0
ANDWEA              978
AROD                CD0
ASD                 BB6
ASLSRO              B82
ASLSROB             C16
ASLSRODL            BEE
ASLSRODR            BD4
ASLSROIR            C22
ASLSROIRDN          C44
ASLSROOP            C4A
ASLSROSIZE          BF8
ASLSROW             C1E
BCC                 55C
BCC16               602
BCC16NEG            61A
BCC32               62A
BCC32NEG            64C
BCC8NEG             5F2
BCCOP               580
BCCSIZE             5AA
BGTOP               58E
BLEOP               59C
CLR                 2C8
CLRB                318
CLRL                344
CLROP               35A
CLRW                32E
CMP                 7F2
CMPB                818
CMPL                848
CMPOP               860
CMPW                830
CNRJML              264
DIVU                6BA
JSR                 3AC
LEA                 4D8
LSD                 BC0
MOVE                1AE
MOVEB               200
MOVEL               224
MOVEM               418
MOVEML              482
MOVEMOP             488
MOVEMPOSTI          4BC
MOVEMPRED           4A0
MOVEMW              478
MOVEOP              236
MOVEQ               668
MOVEW               212
MULS                8B6
MULSAND             896
NOP                 378
OPGETCODE           0
ROD                 BCA
RTS                 392
SUB                 70C
SUBBDN              7E0
SUBBEA              7AA
SUBEA               740
SUBLDN              7BC
SUBLEA              786
SUBWDN              7CE
SUBWEA              798
UNKNOWN             D24
